{
    "docs": [
        {
            "location": "/",
            "text": "Adventure Works Knowzy Backlog\n\n\nThere are four User Stories that we are focusing on for this iteration. Each User Story is split into multiple deliverables that each contains several tasks. Tasks marked as committed have been committed to our leadership, and task marked as proposed have been requested or proposed.\n\n\nUser stories are mostly self contained, they do not have dependencies to other stories. However, as you get farther along in a specific user story, you might run into tasks that depend on other User Stories. Therefore, the recommendation is to assign the user stories to members of your team and to tackle them in parallel. \n\n\nIf you are blocked, a representative from the leadership team is always there to help, don't be afraid to reach out.\n\n\nThe source code for our applications is all open source and can be found on \nour github account\n.\n\n\n\n\n\n\nUser Story\n - The shipping department has a fast, responsive, and powerful application for managing day to day duties\n\n\n\n\nDeliverable\n - Make app more responsive\n\n\n1.1.1\n [Committed] - Build a responsive Web App\n\n\n1.1.2\n [Committed] - Generate Progressive Web App (d. 1.1.1)\n\n\n1.1.3\n [Committed] - Update Web App to PWA (d. 1.1.1) \n\n\n1.1.4\n [Committed] - Test Your App (d. 1.1.1) \n\n\n\n\n\n\nDeliverable\n - Add Native functionality\n\n\n1.2.1\n [Committed] - Add Live Tile (d. 1.1.1) \n\n\n1.2.2\n [Proposed] - Add Share and Secondary Pinning (d. 1.1.2)\n\n\n1.2.3\n [Proposed] - Make PWA Linkable (d. 1.1.2)\n\n\n1.2.4\n [Proposed] - Add In-Memory Caching\n\n\n\n\n\n\n\n\n\n\n\n\nUser Story\n - The product department has a modern, secure and forward-looking platform for managing product development life cycle\n\n\n\n\nDeliverable\n - Enable integration of UWP APIs\n\n\n2.1.1\n [Committed] - Add Desktop Bridge support in Visual Studio\n\n\n2.1.2\n [Committed] - Debugging a Windows Desktop Bridge App (d. 2.1.1)\n\n\n2.1.3\n [Committed] - Adding UWP APIs to a Desktop Bridge App (d. 2.1.2)        \n\n\n2.1.4\n [Committed] - Integrate Windows Hello authentication (d. 2.1.3)\n\n\n\n\n\n\nDeliverable\n - Add UWP XAML support\n\n\n2.2.1\n [Proposed] - Create a new XAML view as part of app package (d. 2.1.1)\n\n\n2.2.2\n [Proposed] - Add support for other apps to share images and create new items (d. 2.1.1)\n\n\n2.2.3\n [Proposed] - Create a new UWP app that integrates with App Services (d. 2.1.1)\n\n\n\n\n\n\nDeliverable\n - Build enhanced UWP experience (d. 2.2.*)\n\n\n2.3.1\n [Proposed] - Add support for ink (d. 2.2.*)\n\n\n2.3.2\n [Proposed] - Add complete support for Windows Hello Authentication (d. 2.1.3)\n\n\n2.3.3\n [Proposed] - Add support for more UWP features (d. 2.2.*)\n\n\n\n\n\n\n\n\n\n\n\n\nUser Story\n - Consumers have a fun mobile experience \n\n\n\n\nDeliverable\n - Create a UWP and Android mobile app\n\n\n3.1.1\n [Committed] - Create a Xamarin.Forms app with shared UI\n\n\n3.1.2\n [Committed] - Integrate native camera to capture image for each platform (d. 3.1.1)\n\n\n3.1.3\n [Committed] - Add InkCanvas support for UWP (d. 3.1.2)\n\n\n\n\n\n\nDeliverable\n - Create a fun social experience\n\n\n3.2.1\n [Proposed] - Support sharing images to Social Networks (d. 3.1.2)\n\n\n3.2.2\n [Proposed] - Support cross device scenarios (Project Rome) (d. 3.1.2)\n\n\n\n\n\n\nDeliverable\n - Add automatic image analysis\n\n\n3.3.1\n [Proposed] - Set up Cognitive Services for image face analysis in Azure (d. 312)\n\n\n3.3.2\n [Proposed] - Create an Azure Function to analyze an image and return nose location to automatically position in app (d. 3.3.1)\n\n\n\n\n\n\nDeliverable\n - Set up Continuous Integration and Deployment\n\n\n3.4.1\n [Proposed] - Set up Continuous Integration and Deployment for the Windows App using Visual Studio Mobile Center\n\n\n3.4.2\n [Proposed] - Set up Continuous Integration and Deployment for the Android App using Visual Studio Mobile Center\n\n\n3.4.3\n [Proposed] - Add Custom Event Logging using Visual Studio Mobile Center\n\n\n\n\n\n\nDeliverable\n - Create a chat bot for support and for order status management \n\n\n3.5.1\n [Proposed] - Create a bot using the Microsoft Bot Framework\n\n\n\n\n\n\n\n\n\n\n\n\nUser Story\n - All platform services are integrated in one platform\n\n\n\n\nDeliverable\n - Unify and Publish all services\n\n\n4.1.1\n - [Committed] Create a shared CosmosDB to store all data\n\n\n4.1.2\n - [Committed] Create API endpoint for shipping services (d. 4.1.1)\n\n\n4.1.3\n - [Committed] Create API endpoint for product services (d. 4.1.1)\n\n\n4.1.4\n - [Committed] Create Docker images (d. 4.1.2, 4.1.3)\n\n\n4.1.5\n - [Committed] Configure Kubernetes and publish to Azure (d. 4.1.4)\n\n\n4.1.6\n - [Proposed] Integrate Website and APIs (d. 4.1.5)\n\n\n\n\n\n\nDeliverable\n - Set up Continuous Delivery\n\n\n4.2.1\n - [Proposed] Set up Visual Studio Team Services\n\n\n4.2.2\n - [Proposed] Continuous Delivery to Kubernetes using VSTS (d. 4.1.5, 4.2.0)\n\n\n\n\n\n\nDeliverable\n - Set up Telemetry\n\n\n4.3.1\n - [Proposed] Set up telemetry for the web app and APIs\n\n\n\n\n\n\n\n\n\n\n\n\nBonus tasks that will be removed from the home page",
            "title": "Home"
        },
        {
            "location": "/#adventure-works-knowzy-backlog",
            "text": "There are four User Stories that we are focusing on for this iteration. Each User Story is split into multiple deliverables that each contains several tasks. Tasks marked as committed have been committed to our leadership, and task marked as proposed have been requested or proposed.  User stories are mostly self contained, they do not have dependencies to other stories. However, as you get farther along in a specific user story, you might run into tasks that depend on other User Stories. Therefore, the recommendation is to assign the user stories to members of your team and to tackle them in parallel.   If you are blocked, a representative from the leadership team is always there to help, don't be afraid to reach out.  The source code for our applications is all open source and can be found on  our github account .    User Story  - The shipping department has a fast, responsive, and powerful application for managing day to day duties   Deliverable  - Make app more responsive  1.1.1  [Committed] - Build a responsive Web App  1.1.2  [Committed] - Generate Progressive Web App (d. 1.1.1)  1.1.3  [Committed] - Update Web App to PWA (d. 1.1.1)   1.1.4  [Committed] - Test Your App (d. 1.1.1)     Deliverable  - Add Native functionality  1.2.1  [Committed] - Add Live Tile (d. 1.1.1)   1.2.2  [Proposed] - Add Share and Secondary Pinning (d. 1.1.2)  1.2.3  [Proposed] - Make PWA Linkable (d. 1.1.2)  1.2.4  [Proposed] - Add In-Memory Caching       User Story  - The product department has a modern, secure and forward-looking platform for managing product development life cycle   Deliverable  - Enable integration of UWP APIs  2.1.1  [Committed] - Add Desktop Bridge support in Visual Studio  2.1.2  [Committed] - Debugging a Windows Desktop Bridge App (d. 2.1.1)  2.1.3  [Committed] - Adding UWP APIs to a Desktop Bridge App (d. 2.1.2)          2.1.4  [Committed] - Integrate Windows Hello authentication (d. 2.1.3)    Deliverable  - Add UWP XAML support  2.2.1  [Proposed] - Create a new XAML view as part of app package (d. 2.1.1)  2.2.2  [Proposed] - Add support for other apps to share images and create new items (d. 2.1.1)  2.2.3  [Proposed] - Create a new UWP app that integrates with App Services (d. 2.1.1)    Deliverable  - Build enhanced UWP experience (d. 2.2.*)  2.3.1  [Proposed] - Add support for ink (d. 2.2.*)  2.3.2  [Proposed] - Add complete support for Windows Hello Authentication (d. 2.1.3)  2.3.3  [Proposed] - Add support for more UWP features (d. 2.2.*)       User Story  - Consumers have a fun mobile experience    Deliverable  - Create a UWP and Android mobile app  3.1.1  [Committed] - Create a Xamarin.Forms app with shared UI  3.1.2  [Committed] - Integrate native camera to capture image for each platform (d. 3.1.1)  3.1.3  [Committed] - Add InkCanvas support for UWP (d. 3.1.2)    Deliverable  - Create a fun social experience  3.2.1  [Proposed] - Support sharing images to Social Networks (d. 3.1.2)  3.2.2  [Proposed] - Support cross device scenarios (Project Rome) (d. 3.1.2)    Deliverable  - Add automatic image analysis  3.3.1  [Proposed] - Set up Cognitive Services for image face analysis in Azure (d. 312)  3.3.2  [Proposed] - Create an Azure Function to analyze an image and return nose location to automatically position in app (d. 3.3.1)    Deliverable  - Set up Continuous Integration and Deployment  3.4.1  [Proposed] - Set up Continuous Integration and Deployment for the Windows App using Visual Studio Mobile Center  3.4.2  [Proposed] - Set up Continuous Integration and Deployment for the Android App using Visual Studio Mobile Center  3.4.3  [Proposed] - Add Custom Event Logging using Visual Studio Mobile Center    Deliverable  - Create a chat bot for support and for order status management   3.5.1  [Proposed] - Create a bot using the Microsoft Bot Framework       User Story  - All platform services are integrated in one platform   Deliverable  - Unify and Publish all services  4.1.1  - [Committed] Create a shared CosmosDB to store all data  4.1.2  - [Committed] Create API endpoint for shipping services (d. 4.1.1)  4.1.3  - [Committed] Create API endpoint for product services (d. 4.1.1)  4.1.4  - [Committed] Create Docker images (d. 4.1.2, 4.1.3)  4.1.5  - [Committed] Configure Kubernetes and publish to Azure (d. 4.1.4)  4.1.6  - [Proposed] Integrate Website and APIs (d. 4.1.5)    Deliverable  - Set up Continuous Delivery  4.2.1  - [Proposed] Set up Visual Studio Team Services  4.2.2  - [Proposed] Continuous Delivery to Kubernetes using VSTS (d. 4.1.5, 4.2.0)    Deliverable  - Set up Telemetry  4.3.1  - [Proposed] Set up telemetry for the web app and APIs       Bonus tasks that will be removed from the home page",
            "title": "Adventure Works Knowzy Backlog"
        },
        {
            "location": "/references/",
            "text": "Build Tour 2017 References\n\n\nProgressive Web Apps\n\n\n\n\nhttp://www.pwabuilder.com/\n\n\nhttps://blogs.windows.com/msedgedev/2017/03/10/progressive-web-apps-education/\n\n\nhttps://channel9.msdn.com/events/Build/2017/B8075\n\n\n\n\nDesktop Bridge\n\n\n\n\nDesktop Bridge\n\n\nFeedback\n\n\nSamples\n\n\nMicrosoft Virtual Academy Tutorials\n\n\n\n\nContainers\n\n\n\n\nContainers\n\n\nMicrosoft Docker Hub\n\n\nVisual Studio Code\n\n\nVS Code Docker Extension\n\n\n\n\nWhat's New in AI\n\n\n\n\nMicrosoft AI\n\n\nCognitive Services\n\n\nCustom Vision Service\n\n\nCustom Speech Service\n\n\nAdaptive Cards\n\n\nBot Framework\n\n\n\n\nServerless in Azure\n\n\n\n\nTry Functions and Logic App\n\n\nAzure Function Community",
            "title": "References"
        },
        {
            "location": "/references/#build-tour-2017-references",
            "text": "",
            "title": "Build Tour 2017 References"
        },
        {
            "location": "/references/#progressive-web-apps",
            "text": "http://www.pwabuilder.com/  https://blogs.windows.com/msedgedev/2017/03/10/progressive-web-apps-education/  https://channel9.msdn.com/events/Build/2017/B8075",
            "title": "Progressive Web Apps"
        },
        {
            "location": "/references/#desktop-bridge",
            "text": "Desktop Bridge  Feedback  Samples  Microsoft Virtual Academy Tutorials",
            "title": "Desktop Bridge"
        },
        {
            "location": "/references/#containers",
            "text": "Containers  Microsoft Docker Hub  Visual Studio Code  VS Code Docker Extension",
            "title": "Containers"
        },
        {
            "location": "/references/#whats-new-in-ai",
            "text": "Microsoft AI  Cognitive Services  Custom Vision Service  Custom Speech Service  Adaptive Cards  Bot Framework",
            "title": "What's New in AI"
        },
        {
            "location": "/references/#serverless-in-azure",
            "text": "Try Functions and Logic App  Azure Function Community",
            "title": "Serverless in Azure"
        },
        {
            "location": "/stories/1/111_BuildWebApp/",
            "text": "Task 1.1.1 - Build a Responsive Web App\n\n\nPrerequisites\n\n\nyour developer build should include Visual Studio 2017.. \nYou'll need to start by downloading the codebase for the webapp.   \n\n\nTo do this, go to the git repo \nhttps://github.com/Knowzy/KnowzyInternalApps\n and clone or download the content onto your local computer.\n\n\nTask\n\n\nMake your website responsive.\n\n\nMost of the work has already been done to make sure that your site works well across different devices, but you'll need to make a few adjustments to the code base to ensure that it flows properly for screens of all sizes.  You'll also want to make sure that it works across platforms, since some of the Knowzy contractors carry Android tablets instead of Windows 10 devices.\n  You should have the code repo on your local device.  Open up the project in \\src\\Knowzy_Shipping_WebApp and run your web site locally to see the project you are starting with.\n\n\n\n\nOpen up your site.css file at the following path:\n\n\n\n\n\\wwwroot\\css\\site.css\n\n\n\n\nand find the following declaration toward the top of the page:\n\n\n.container-main {\n    padding-right: 15px;\n    padding-left: 15px;\n    margin: 0 auto;\n    width: 800px;\n}\n\n\n\n\n\n\nAdd a declaration for \"container-main\" inside key media queries to resize the page properly for different screen sizes. You'll want to create media queries with css declarations  for the key screen sizes of 320px, 768px, 992px, and 1200px like below:\n\n\n\n\n@media all and (min-width:320px) {\n    .container-main {\n        width: 100%;\n    }\n}\n\n@media all and (min-width:768px) {\n    .container-main {\n        width: 750px\n    }\n}\n\n@media all and (min-width:992px) {\n    .container-main {\n        width: 970px\n    }\n}\n\n@media all and (min-width:1200px) {\n    .container-main {\n        width: 1170px\n    }\n}\n\n\n\n\nBe sure to add these rules \nbelow\n the \"container-main\" rule, so the media queries will override the width of the main rule.\n\n\n\n\nView your web app in a browser (you can do this  by hitting f5 is visual studio or clicking on the start button), and adjust the width of your window to test responsiveness of the design.  If you have a tablet device, you can change the orientation of your device to make sure that the page response properly.  It should look similar to this\n [image of page layout on two different orientations]\n\n\n\n\nYour app is now ready to be viewed on devices with different screen sizes and orientations.\n\n\nDeploy your ASP.net App Changes\n\n\nNow that you have these powerful new features running locally, you can publish them to your website on Azure.\n\n\n\n\nIn Visual studio select the \"Microsoft.Knowzy.WebApp\" in the solution explorer, then choose Build > Publish... \n\nNOTE\n some configurations of visual studio may have the \"publish\" option as its own menu.\n\n\n\n\n\n\n\n\nChoose \"Microsoft Azure App Service\" from the selection screen\n\n\n\n\n\n\n\n\nChoose a name for your new site and other configurations.  This can be published as a free site.\n\n\n\n\n\n\n\n\n\n\nKeep track of the new URL you have created, you'll want to use this later.\n\n\n\n\n\n\nhit \"create\" and wait for your web app to finish deploying.\n\n\n\n\n\n\nReferences\n\n\nhttps://github.com/Knowzy/KnowzyInternalApps\n\n\ncontinue to \nnext task >>",
            "title": "111 BuildWebApp"
        },
        {
            "location": "/stories/1/111_BuildWebApp/#task-111-build-a-responsive-web-app",
            "text": "",
            "title": "Task 1.1.1 - Build a Responsive Web App"
        },
        {
            "location": "/stories/1/111_BuildWebApp/#prerequisites",
            "text": "your developer build should include Visual Studio 2017.. \nYou'll need to start by downloading the codebase for the webapp.     To do this, go to the git repo  https://github.com/Knowzy/KnowzyInternalApps  and clone or download the content onto your local computer.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/1/111_BuildWebApp/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/1/111_BuildWebApp/#make-your-website-responsive",
            "text": "Most of the work has already been done to make sure that your site works well across different devices, but you'll need to make a few adjustments to the code base to ensure that it flows properly for screens of all sizes.  You'll also want to make sure that it works across platforms, since some of the Knowzy contractors carry Android tablets instead of Windows 10 devices.\n  You should have the code repo on your local device.  Open up the project in \\src\\Knowzy_Shipping_WebApp and run your web site locally to see the project you are starting with.   Open up your site.css file at the following path:   \\wwwroot\\css\\site.css  and find the following declaration toward the top of the page:  .container-main {\n    padding-right: 15px;\n    padding-left: 15px;\n    margin: 0 auto;\n    width: 800px;\n}   Add a declaration for \"container-main\" inside key media queries to resize the page properly for different screen sizes. You'll want to create media queries with css declarations  for the key screen sizes of 320px, 768px, 992px, and 1200px like below:   @media all and (min-width:320px) {\n    .container-main {\n        width: 100%;\n    }\n}\n\n@media all and (min-width:768px) {\n    .container-main {\n        width: 750px\n    }\n}\n\n@media all and (min-width:992px) {\n    .container-main {\n        width: 970px\n    }\n}\n\n@media all and (min-width:1200px) {\n    .container-main {\n        width: 1170px\n    }\n}  Be sure to add these rules  below  the \"container-main\" rule, so the media queries will override the width of the main rule.   View your web app in a browser (you can do this  by hitting f5 is visual studio or clicking on the start button), and adjust the width of your window to test responsiveness of the design.  If you have a tablet device, you can change the orientation of your device to make sure that the page response properly.  It should look similar to this\n [image of page layout on two different orientations]   Your app is now ready to be viewed on devices with different screen sizes and orientations.",
            "title": "Make your website responsive."
        },
        {
            "location": "/stories/1/111_BuildWebApp/#deploy-your-aspnet-app-changes",
            "text": "Now that you have these powerful new features running locally, you can publish them to your website on Azure.   In Visual studio select the \"Microsoft.Knowzy.WebApp\" in the solution explorer, then choose Build > Publish...  NOTE  some configurations of visual studio may have the \"publish\" option as its own menu.     Choose \"Microsoft Azure App Service\" from the selection screen     Choose a name for your new site and other configurations.  This can be published as a free site.      Keep track of the new URL you have created, you'll want to use this later.    hit \"create\" and wait for your web app to finish deploying.",
            "title": "Deploy your ASP.net App Changes"
        },
        {
            "location": "/stories/1/111_BuildWebApp/#references",
            "text": "https://github.com/Knowzy/KnowzyInternalApps",
            "title": "References"
        },
        {
            "location": "/stories/1/111_BuildWebApp/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/1/112_GeneratePWA/",
            "text": "Task 1.1.2 - Generate Progressive Web App\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.1.1\n and all of it's prerequisites\n\n\nTask\n\n\nThe first step is to build the Manifest for your application using the \npwabuilder.com\n web site. The builder will search in the home page of your site looking for information about the app in specific meta tags. For more information, read \nWhat is a Manifest\n.\n\n\nProvide a URL\n\n\n\n\nOpen a browser and navigate to \nhttps://preview.pwabuilder.com\n\n\nClick on the \nGet Started\n button \n\n\nIn the URL textbox, enter the https version of your URL of your site and click on \nGet Started\n again \n\nNote\n your website URL will likely default to the http version in the browser but all azure websites also have a valid https certificate so https can be used on any azure website.\n\n\n\n\n \n\n\nGenerate Manifest\n\n\nThe builder will search in the home page of your site looking for an existing manifest. If not, it will gather information about the app in specific meta tags or propose default values for the manifest properties. It will also show any warnings or suggestions to address potential issues in the collected metadata. Make sure you address any warnings before you move on. \n\n\n \n\n\nAdd Images\n\n\nThe builder site also checks whether the manifest has defined the expected icon sizes for the different platforms (Windows, Android, iOS) and helps to generate the missing sizes. You can also generate missing image sizes for other platforms using the \nPWA Image Generator\n. \n\n\n\n\n\n\nFor our side, we don't have any image defined in the manifest so we'll proceed uploading an image with our app logo. To do this, click on the \nUpload an image\u2026\n link at the left pane. \n\n\n\n\n\n\nSave the below Knowzy logo to your PC by right clicking and \"save image as\".\n\n\n\n\n\n\n \n\n\n\n\nBrowse to the location of the image you downloaded and if you want to generate the missing sizes, make sure the \nGenerate missing images from this image\n checkbox is marked. \n\n\n\n\nNote:\n The \nUpload image\n option will generate the required image sizes for Windows 10, and suggested images for other platforms.\n\n\n \n\n\n\n\nClick \nSubmit\n. In our example, the missing image sizes are automatically generated and added to the manifest.\n\n\n\n\n \n\n\n\n\nClick \"download manifest\" to get a copy of this manifest to add to your web site.\n\n\n\n\nChoose a Service Worker\n\n\nDuring this step you will choose functionalities you want to add to your app. The builder will include code to use sample service workers implementing those features from a repository. Learn more about service workers \nhere\n. There are a number of service workers to choose from on this page, but Knowzy is looking for a way to make sure it's field agents can access the app data when they have poor or no network connection.  For this functionality we'll choose the \"Offline copy of pages\" service worker.\n\n\n\n\n\n\nSelect the service worker you want to include in your application \n \n\n\n\n\n\n\nDownload the service worker package including the code for your website and the service worker code (you can also just copy and past the code right from the site).  You'll be downloading two different js files.  The first is the registration code in which you'll be instructed how to add that to your site in the next section, and the service worker itself.  \n\n\n\n\n\n\nReferences\n\n\nhttp://docs.pwabuilder.com/whatPWA/what-is-a-service-worker/\n\n\nhttps://www.pwabuilder.com\n\n\ncontinue to \nnext task >>",
            "title": "112 GeneratePWA"
        },
        {
            "location": "/stories/1/112_GeneratePWA/#task-112-generate-progressive-web-app",
            "text": "",
            "title": "Task 1.1.2 - Generate Progressive Web App"
        },
        {
            "location": "/stories/1/112_GeneratePWA/#prerequisites",
            "text": "This task has a dependency on  Task 1.1.1  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/1/112_GeneratePWA/#task",
            "text": "The first step is to build the Manifest for your application using the  pwabuilder.com  web site. The builder will search in the home page of your site looking for information about the app in specific meta tags. For more information, read  What is a Manifest .",
            "title": "Task"
        },
        {
            "location": "/stories/1/112_GeneratePWA/#provide-a-url",
            "text": "Open a browser and navigate to  https://preview.pwabuilder.com  Click on the  Get Started  button   In the URL textbox, enter the https version of your URL of your site and click on  Get Started  again  Note  your website URL will likely default to the http version in the browser but all azure websites also have a valid https certificate so https can be used on any azure website.",
            "title": "Provide a URL"
        },
        {
            "location": "/stories/1/112_GeneratePWA/#generate-manifest",
            "text": "The builder will search in the home page of your site looking for an existing manifest. If not, it will gather information about the app in specific meta tags or propose default values for the manifest properties. It will also show any warnings or suggestions to address potential issues in the collected metadata. Make sure you address any warnings before you move on.",
            "title": "Generate Manifest"
        },
        {
            "location": "/stories/1/112_GeneratePWA/#add-images",
            "text": "The builder site also checks whether the manifest has defined the expected icon sizes for the different platforms (Windows, Android, iOS) and helps to generate the missing sizes. You can also generate missing image sizes for other platforms using the  PWA Image Generator .     For our side, we don't have any image defined in the manifest so we'll proceed uploading an image with our app logo. To do this, click on the  Upload an image\u2026  link at the left pane.     Save the below Knowzy logo to your PC by right clicking and \"save image as\".        Browse to the location of the image you downloaded and if you want to generate the missing sizes, make sure the  Generate missing images from this image  checkbox is marked.    Note:  The  Upload image  option will generate the required image sizes for Windows 10, and suggested images for other platforms.      Click  Submit . In our example, the missing image sizes are automatically generated and added to the manifest.       Click \"download manifest\" to get a copy of this manifest to add to your web site.",
            "title": "Add Images"
        },
        {
            "location": "/stories/1/112_GeneratePWA/#choose-a-service-worker",
            "text": "During this step you will choose functionalities you want to add to your app. The builder will include code to use sample service workers implementing those features from a repository. Learn more about service workers  here . There are a number of service workers to choose from on this page, but Knowzy is looking for a way to make sure it's field agents can access the app data when they have poor or no network connection.  For this functionality we'll choose the \"Offline copy of pages\" service worker.    Select the service worker you want to include in your application       Download the service worker package including the code for your website and the service worker code (you can also just copy and past the code right from the site).  You'll be downloading two different js files.  The first is the registration code in which you'll be instructed how to add that to your site in the next section, and the service worker itself.",
            "title": "Choose a Service Worker"
        },
        {
            "location": "/stories/1/112_GeneratePWA/#references",
            "text": "http://docs.pwabuilder.com/whatPWA/what-is-a-service-worker/  https://www.pwabuilder.com",
            "title": "References"
        },
        {
            "location": "/stories/1/112_GeneratePWA/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/1/113_ConfigureSW/",
            "text": "Task 1.1.3 - Update your Web App with PWA features\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.1.2\n and all of it's prerequisites\n\n\nTask\n\n\nAdd Web App Manifest to your site\n\n\nThe first thing you'll need to do is pull the \"manifest.json\" file and the \"images\" folder that you obtained from the zip file. in the previous step.\n\n\n\n\nAdd the manifest.json and the \"images\" folder to the root path of your site (wwwroot).  Remember if you change the path of your \"images\" folder, you need to update the json in your manifest file to reflect your changes. The easiest way to add new content to a project is to drag and drop the contents from the file explorer into the solutions explorer of your project.\n\n\n\n\n![add image of manifest and paths ]\n\n\n\n\n\n\nReference the manifest in your page with a link tag:\n\n\n<link rel=\"manifest\" href=\"manifest.json\"></link>\n\nThis can be done by opening the Views \\ Shippings \\ index.cshtml page in your site, and adding the following to the top of the document:\n\n\n\n\n\n\n\n@section HeadExtension{ \n<link rel=\"manifest\" href=\"manifest.json\" />\n}\n\n\n\n\n\nAdd SW code to your site\n\n\nYour Service Worker needs likewise needs to be added to your site to take effect.  \n\n\n\n\nCopy the \"pwabuilder-sw.js\" file from the zip you downloaded from the service worker page of PWA Builder and add it to your js folder in wwwroot  (not in a folder) like so:\n\n\n\n\n\n\n\n\n\n\n\nOpen up the landing page of your app (index.cshtml) and create a new script tag in the head from within the same HeadExtension section like so:\n\n\n\n\n@section HeadExtension{ \n<link rel=\"manifest\" href=\"manifest.json\" />\n<script></script>\n}\n\n\n\n\n\n\nYou will want to place this at the top of your document.\n\n\n\n\nAdd the following registration code inside the new script tag:\n\n\n\n\n//This is the service worker with the combined offline experience (Offline page + Offline copy of pages)\n\n//Add this below content to your HTML page, or add the js file to your page at the very top to register service worker\nif (navigator.serviceWorker.controller) {\n  console.log('[PWA Builder] active service worker found, no need to register')\n} else {\n\n//Register the ServiceWorker\n  navigator.serviceWorker.register('pwabuilder-sw.js', {\n    scope: './'\n  }).then(function(reg) {\n    console.log('Service worker has been registered for scope:'+ reg.scope);\n  });\n}\n\n\n\n\n\n\n\n\n\n\n\nRe-Publish Changes\n\n\nNow that you have these powerful new features running locally, you can publish them to your website to be consumed as a PWA.\n\n\n\n\n\n\nIn Visual studio choose Project > Publish...\n\n\n\n\n\n\nChoose \"Microsoft Azure App Service\" from the selection screen\n\n\n\n\n\n\nNOTE\n if your Visual Studio project is still debugging your azure server or your local server, you may need to halt the server before re-publishing.\n\n\n\n\n\n\nChoose \"deploy\"\n\n\n\n\nReferences\n\n\nhttps://www.pwabuilder.com\n\n\ncontinue to \nnext task >>",
            "title": "113 ConfigureSW"
        },
        {
            "location": "/stories/1/113_ConfigureSW/#task-113-update-your-web-app-with-pwa-features",
            "text": "",
            "title": "Task 1.1.3 - Update your Web App with PWA features"
        },
        {
            "location": "/stories/1/113_ConfigureSW/#prerequisites",
            "text": "This task has a dependency on  Task 1.1.2  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/1/113_ConfigureSW/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/1/113_ConfigureSW/#add-web-app-manifest-to-your-site",
            "text": "The first thing you'll need to do is pull the \"manifest.json\" file and the \"images\" folder that you obtained from the zip file. in the previous step.   Add the manifest.json and the \"images\" folder to the root path of your site (wwwroot).  Remember if you change the path of your \"images\" folder, you need to update the json in your manifest file to reflect your changes. The easiest way to add new content to a project is to drag and drop the contents from the file explorer into the solutions explorer of your project.   ![add image of manifest and paths ]    Reference the manifest in your page with a link tag:  <link rel=\"manifest\" href=\"manifest.json\"></link> \nThis can be done by opening the Views \\ Shippings \\ index.cshtml page in your site, and adding the following to the top of the document:    \n@section HeadExtension{ \n<link rel=\"manifest\" href=\"manifest.json\" />\n}",
            "title": "Add Web App Manifest to your site"
        },
        {
            "location": "/stories/1/113_ConfigureSW/#add-sw-code-to-your-site",
            "text": "Your Service Worker needs likewise needs to be added to your site to take effect.     Copy the \"pwabuilder-sw.js\" file from the zip you downloaded from the service worker page of PWA Builder and add it to your js folder in wwwroot  (not in a folder) like so:      Open up the landing page of your app (index.cshtml) and create a new script tag in the head from within the same HeadExtension section like so:   @section HeadExtension{ \n<link rel=\"manifest\" href=\"manifest.json\" />\n<script></script>\n}  You will want to place this at the top of your document.   Add the following registration code inside the new script tag:   //This is the service worker with the combined offline experience (Offline page + Offline copy of pages)\n\n//Add this below content to your HTML page, or add the js file to your page at the very top to register service worker\nif (navigator.serviceWorker.controller) {\n  console.log('[PWA Builder] active service worker found, no need to register')\n} else {\n\n//Register the ServiceWorker\n  navigator.serviceWorker.register('pwabuilder-sw.js', {\n    scope: './'\n  }).then(function(reg) {\n    console.log('Service worker has been registered for scope:'+ reg.scope);\n  });\n}",
            "title": "Add SW code to your site"
        },
        {
            "location": "/stories/1/113_ConfigureSW/#re-publish-changes",
            "text": "Now that you have these powerful new features running locally, you can publish them to your website to be consumed as a PWA.    In Visual studio choose Project > Publish...    Choose \"Microsoft Azure App Service\" from the selection screen    NOTE  if your Visual Studio project is still debugging your azure server or your local server, you may need to halt the server before re-publishing.    Choose \"deploy\"",
            "title": "Re-Publish Changes"
        },
        {
            "location": "/stories/1/113_ConfigureSW/#references",
            "text": "https://www.pwabuilder.com",
            "title": "References"
        },
        {
            "location": "/stories/1/113_ConfigureSW/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/1/114_Test_App/",
            "text": "Task 1.1.4 - Install App Locally for Testing\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.1.3\n and all of it's prerequisites\n\n\nTask\n\n\nTest the App in Browsers\n\n\nThe first thing you want to do is make sure your PWA works well in the browser.  One of the main principles of PWAs is that the app must be \"Progressive\".  This means the app should work in any environment, then start taking advantage of advanced features (such as service workers and app manifest) when they are available.  In normal circumstances, you would want to test your app in the array of browsers used by your user.   To get you started, we have the newest version of Edge (with service worker support) available to you for free on browser stack  \n\n\nNOTE\n for Dry Run Users, Edge 16 may not yet be available in browser stack.  You can test the service worker code in chrome \nEND NOTE\n\n\n\n\n\n\nIn your browser, visit https://www.browserstack.com/test-on-microsoft-edge-browser\n\n\n\n\n\n\nCreate an account if you don't already have one.\n\n\n\n\n\n\nChoose Windows > 10 > Edge 16 > new session to get started testing in Edge\n!(image of browser stack select)\n\n\n\n\n\n\nYou can also use browser stack to test in other browsers you don't have installed on your device (trial limitations apply)\n\n\n\n\n\n\nto test the service worker, simply visit a number of pages with the service worker attached to your app, and each page will be added to the cache (don't worry the service worker will always keep itself up to date).  You can then go offline and see each of those pages still work fine without a connection.  If you are using BrowserStack and can't go offline, simply open up the f12 tooling in the browser, and you can validate that the service worker is caching it's content by the logs in the console.\n\n\n\n\n\n\nInstall Windows Store PWA locally\n\n\nThe next environment you'll want to test in, is the local PWA.  To do this we'll use more tools from PWABuilder.com\n\n\n\n\n\n\nIn the browser, open www.pwabuilder.com/generator.\n\n\n\n\n\n\nEnter your site URL and press \"get started\".  If you have your manifest properly linked to your page, you should see the data from your manifest (including images) show up in the builder.\n\n\n\n\n\n\nClick on the 3rd tab called \"Publish PWA\".  This time you'll click on the \"Download\" button under \"Windows\" to get the source code\n\n\n\n\n\n\nInside the zip, decompress it and navigate to \\PWA\\Store packages\\windows10 and right click on the \"test_install\" script and choose \"run powershell script\"\n\n\n\n\n\n\nFollow the prompts to \"side load the application\".\n\n\n\n\n\n\nopen the app from your start screen / start menu.  Your now experiencing your PWA on Windows 10!\n\n\n\n\n\n\nF12 with Windows Store PWA\n\n\nYour app is sideloaded on your machine, which means it's in debug mode.  While PWAs are in debug mode on Windows 10, you have access to the same f12 tools you do while in the Edge browser.  While the app in forefront on your screen, hit the \"f12\" button on your keyboard and the tools should open.\n\n\nReferences\n\n\nhttps://www.pwabuilder.com/generator\n\n\nhttps://www.browserstack.com/test-on-microsoft-edge-browser\n\n\ncontinue to \nnext task >>",
            "title": "114 Test App"
        },
        {
            "location": "/stories/1/114_Test_App/#task-114-install-app-locally-for-testing",
            "text": "",
            "title": "Task 1.1.4 - Install App Locally for Testing"
        },
        {
            "location": "/stories/1/114_Test_App/#prerequisites",
            "text": "This task has a dependency on  Task 1.1.3  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/1/114_Test_App/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/1/114_Test_App/#test-the-app-in-browsers",
            "text": "The first thing you want to do is make sure your PWA works well in the browser.  One of the main principles of PWAs is that the app must be \"Progressive\".  This means the app should work in any environment, then start taking advantage of advanced features (such as service workers and app manifest) when they are available.  In normal circumstances, you would want to test your app in the array of browsers used by your user.   To get you started, we have the newest version of Edge (with service worker support) available to you for free on browser stack    NOTE  for Dry Run Users, Edge 16 may not yet be available in browser stack.  You can test the service worker code in chrome  END NOTE    In your browser, visit https://www.browserstack.com/test-on-microsoft-edge-browser    Create an account if you don't already have one.    Choose Windows > 10 > Edge 16 > new session to get started testing in Edge\n!(image of browser stack select)    You can also use browser stack to test in other browsers you don't have installed on your device (trial limitations apply)    to test the service worker, simply visit a number of pages with the service worker attached to your app, and each page will be added to the cache (don't worry the service worker will always keep itself up to date).  You can then go offline and see each of those pages still work fine without a connection.  If you are using BrowserStack and can't go offline, simply open up the f12 tooling in the browser, and you can validate that the service worker is caching it's content by the logs in the console.",
            "title": "Test the App in Browsers"
        },
        {
            "location": "/stories/1/114_Test_App/#install-windows-store-pwa-locally",
            "text": "The next environment you'll want to test in, is the local PWA.  To do this we'll use more tools from PWABuilder.com    In the browser, open www.pwabuilder.com/generator.    Enter your site URL and press \"get started\".  If you have your manifest properly linked to your page, you should see the data from your manifest (including images) show up in the builder.    Click on the 3rd tab called \"Publish PWA\".  This time you'll click on the \"Download\" button under \"Windows\" to get the source code    Inside the zip, decompress it and navigate to \\PWA\\Store packages\\windows10 and right click on the \"test_install\" script and choose \"run powershell script\"    Follow the prompts to \"side load the application\".    open the app from your start screen / start menu.  Your now experiencing your PWA on Windows 10!",
            "title": "Install Windows Store PWA locally"
        },
        {
            "location": "/stories/1/114_Test_App/#f12-with-windows-store-pwa",
            "text": "Your app is sideloaded on your machine, which means it's in debug mode.  While PWAs are in debug mode on Windows 10, you have access to the same f12 tools you do while in the Edge browser.  While the app in forefront on your screen, hit the \"f12\" button on your keyboard and the tools should open.",
            "title": "F12 with Windows Store PWA"
        },
        {
            "location": "/stories/1/114_Test_App/#references",
            "text": "https://www.pwabuilder.com/generator  https://www.browserstack.com/test-on-microsoft-edge-browser",
            "title": "References"
        },
        {
            "location": "/stories/1/114_Test_App/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/1/121_Add_WIndows_Feature/",
            "text": "Task 1.2.1 - Add Windows 10 feature\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.1.4\n and all of it's prerequisites\n\n\nTask\n\n\nAdd a Windows feature to your web content.\n\n\nOne of the coolest things about PWAs on Windows 10 is the technical advantages you get over just running in the browser:\n\n\n\n\nStandalone Window\n\n\nIndependent from browser process (Less overhead / Isolated cache)\n\n\nNearly unlimited storage (indexed DB, localStorage, etc.)\n\n\nOffline & background processes\n\n\nAccess to Windows Runtime (WinRT) APIs via JavaScript (Calendar / Cortana / Address Book / etc)\n\n\n\n\nFeature detect for Windows Store APIs\n\n\nIn order to utilize a Windows UWP API, you'll want to implement a pattern called \"feature detection\".  This allows you to write JavaScript on your page that will only be executed in the context where the APIs are available.  In this case, it will only execute while inside a Windows PWA.\n\n\nFeature detection can be as simple as looking for the Windows object as below:\n\n\n\nif(window.Windows){\n/*execute code that calls WIndows APIs */\n}\n\n\n\n\n\nKeep in mind that not all Windows APIs are available on all Windows 10 devices.  Think about the fact that a Windows Phone has a \"dialer\" for making phone calls, so it has unique APIs that are not available on other device types.  Another example is the \"surface dial\" that can be paired to Many Windows devices, but not the Xbox, so the \"radial dial\" APIs are not present on the Xbox.  For more specific feature detection, you'll also want to feature detect the API family as well like below:\n\n\n\nif(window.Windows && Windows.UI.Core.SystemNavigationManager){\n/*execute code that calls WIndows APIs */\n}\n\n\n\n\n\nAdd Code to Customize your PWA App Container\n\n\nStart out by adding some code that adds a message to the tile in the start menu.  This code can be ran from any page, but you'll likely want to put it on index.cshtml so that it is ran as soon as the app is opened. \n\n\n\n\nOpen shipping \\index.cshtml in Visual Studio and add a script tag at the bottom of the page\n\n\nadd the following feature detection inside the script tag\n\n\n\n\nif(window.Windows && Windows.UI.Notifications){\n/*execute code that calls WIndows APIs */\n}\n\n\n\n\n\n\n\nInside the feature detection, add the following code to load the live tile\n\n\n\n\nvar tileContent = new Windows.Data.Xml.Dom.XmlDocument();\n\u00a0\nvar tile = tileContent.createElement(\"tile\");\ntileContent.appendChild(tile);\n\u00a0\nvar visual = tileContent.createElement(\"visual\");\ntile.appendChild(visual);\n\u00a0\nvar bindingMedium = tileContent.createElement(\"binding\");\nbindingMedium.setAttribute(\"template\", \"TileMedium\");\nvisual.appendChild(bindingMedium);\n\u00a0\nvar peekImage = tileContent.createElement(\"image\");\npeekImage.setAttribute(\"placement\", \"peek\");\npeekImage.setAttribute(\"src\", \"https://unsplash.it/150/150/?random\");\npeekImage.setAttribute(\"alt\", \"Welcome to Knowsie!\");\nbindingMedium.appendChild(peekImage);\n\u00a0\nvar text = tileContent.createElement(\"text\");\ntext.setAttribute(\"hint-wrap\", \"true\");\ntext.innerText = \"Demo Message\";\nbindingMedium.appendChild(text);\n\n//fire the notification\n\nvar notifications = Windows.UI.Notifications;\nvar tileNotification = new notifications.TileNotification(tileContent);\nnotifications.TileUpdateManager.createTileUpdaterForApplication().update(tileNotification);\n\n\n\n\n\n\nTest your changes\n\n\nNow you want to test the changes you've just made.  Follow the instructions in section 1.1.3 for deploying your web app, and repdeploy your changes.  One of the great things about a PWA is that you don't need to redeploy your app to see the changes, you just need to deploy to the web server.  You should be able to run your app again, and see your live tile code take effect (pin tile to start menu to see).  If you don't see it imediately, it may because of the gerat caching you have in your app.  if this happens, you can force a cache clear by uninstalling your PWA, and then installing it again from the script you downloaded from PWABuilder.com\n\n\n\n\nNOTE\n if your Visual Studio session is still debugging your azure instance, you may need to halt your debugger before you test locally again.\n\n\nReferences\n\n\ncontinue to \nBonus task >>",
            "title": "121 Add WIndows Feature"
        },
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#task-121-add-windows-10-feature",
            "text": "",
            "title": "Task 1.2.1 - Add Windows 10 feature"
        },
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#prerequisites",
            "text": "This task has a dependency on  Task 1.1.4  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#add-a-windows-feature-to-your-web-content",
            "text": "One of the coolest things about PWAs on Windows 10 is the technical advantages you get over just running in the browser:   Standalone Window  Independent from browser process (Less overhead / Isolated cache)  Nearly unlimited storage (indexed DB, localStorage, etc.)  Offline & background processes  Access to Windows Runtime (WinRT) APIs via JavaScript (Calendar / Cortana / Address Book / etc)",
            "title": "Add a Windows feature to your web content."
        },
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#feature-detect-for-windows-store-apis",
            "text": "In order to utilize a Windows UWP API, you'll want to implement a pattern called \"feature detection\".  This allows you to write JavaScript on your page that will only be executed in the context where the APIs are available.  In this case, it will only execute while inside a Windows PWA.  Feature detection can be as simple as looking for the Windows object as below:  \nif(window.Windows){\n/*execute code that calls WIndows APIs */\n}  Keep in mind that not all Windows APIs are available on all Windows 10 devices.  Think about the fact that a Windows Phone has a \"dialer\" for making phone calls, so it has unique APIs that are not available on other device types.  Another example is the \"surface dial\" that can be paired to Many Windows devices, but not the Xbox, so the \"radial dial\" APIs are not present on the Xbox.  For more specific feature detection, you'll also want to feature detect the API family as well like below:  \nif(window.Windows && Windows.UI.Core.SystemNavigationManager){\n/*execute code that calls WIndows APIs */\n}",
            "title": "Feature detect for Windows Store APIs"
        },
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#add-code-to-customize-your-pwa-app-container",
            "text": "Start out by adding some code that adds a message to the tile in the start menu.  This code can be ran from any page, but you'll likely want to put it on index.cshtml so that it is ran as soon as the app is opened.    Open shipping \\index.cshtml in Visual Studio and add a script tag at the bottom of the page  add the following feature detection inside the script tag   if(window.Windows && Windows.UI.Notifications){\n/*execute code that calls WIndows APIs */\n}   Inside the feature detection, add the following code to load the live tile   var tileContent = new Windows.Data.Xml.Dom.XmlDocument();\n\u00a0\nvar tile = tileContent.createElement(\"tile\");\ntileContent.appendChild(tile);\n\u00a0\nvar visual = tileContent.createElement(\"visual\");\ntile.appendChild(visual);\n\u00a0\nvar bindingMedium = tileContent.createElement(\"binding\");\nbindingMedium.setAttribute(\"template\", \"TileMedium\");\nvisual.appendChild(bindingMedium);\n\u00a0\nvar peekImage = tileContent.createElement(\"image\");\npeekImage.setAttribute(\"placement\", \"peek\");\npeekImage.setAttribute(\"src\", \"https://unsplash.it/150/150/?random\");\npeekImage.setAttribute(\"alt\", \"Welcome to Knowsie!\");\nbindingMedium.appendChild(peekImage);\n\u00a0\nvar text = tileContent.createElement(\"text\");\ntext.setAttribute(\"hint-wrap\", \"true\");\ntext.innerText = \"Demo Message\";\nbindingMedium.appendChild(text);\n\n//fire the notification\n\nvar notifications = Windows.UI.Notifications;\nvar tileNotification = new notifications.TileNotification(tileContent);\nnotifications.TileUpdateManager.createTileUpdaterForApplication().update(tileNotification);",
            "title": "Add Code to Customize your PWA App Container"
        },
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#test-your-changes",
            "text": "Now you want to test the changes you've just made.  Follow the instructions in section 1.1.3 for deploying your web app, and repdeploy your changes.  One of the great things about a PWA is that you don't need to redeploy your app to see the changes, you just need to deploy to the web server.  You should be able to run your app again, and see your live tile code take effect (pin tile to start menu to see).  If you don't see it imediately, it may because of the gerat caching you have in your app.  if this happens, you can force a cache clear by uninstalling your PWA, and then installing it again from the script you downloaded from PWABuilder.com   NOTE  if your Visual Studio session is still debugging your azure instance, you may need to halt your debugger before you test locally again.",
            "title": "Test your changes"
        },
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#references",
            "text": "",
            "title": "References"
        },
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#continue-to-bonus-task",
            "text": "",
            "title": "continue to Bonus task &gt;&gt;"
        },
        {
            "location": "/stories/1/122_BONUS-RenoFeatures/",
            "text": "Add Secondary Pinning and Native Share to App (1.2.2)\n\n\nThis task has a dependency on \nTask 1.1.5\n and all of it's prerequisites\n\n\nTask\n\n\n\n\n\n\nnavigate to \nReno.js library documentation\n\n\n\n\n\n\nAdd js file to site\n\n\n\n\n\n\nconfigure the features if necessary \n\n\n\n\n\n\nRedeploy site\n\n\n\n\n\n\nreinstall your local app (right click PowerShell script included in pwabuilder.com download)\n\n\n\n\n\n\nReferences\n\n\nhttps://github.com/JimGaleForce/Reno/tree/dev\n\n\ncontinue to \nNext Bonus task >>",
            "title": "122 BONUS RenoFeatures"
        },
        {
            "location": "/stories/1/122_BONUS-RenoFeatures/#add-secondary-pinning-and-native-share-to-app-122",
            "text": "This task has a dependency on  Task 1.1.5  and all of it's prerequisites",
            "title": "Add Secondary Pinning and Native Share to App (1.2.2)"
        },
        {
            "location": "/stories/1/122_BONUS-RenoFeatures/#task",
            "text": "navigate to  Reno.js library documentation    Add js file to site    configure the features if necessary     Redeploy site    reinstall your local app (right click PowerShell script included in pwabuilder.com download)",
            "title": "Task"
        },
        {
            "location": "/stories/1/122_BONUS-RenoFeatures/#references",
            "text": "https://github.com/JimGaleForce/Reno/tree/dev",
            "title": "References"
        },
        {
            "location": "/stories/1/122_BONUS-RenoFeatures/#continue-to-next-bonus-task",
            "text": "",
            "title": "continue to Next Bonus task &gt;&gt;"
        },
        {
            "location": "/stories/1/123_BONUS-APP-Links/",
            "text": "# Add App linking to PWA (1.2.3)\n\n\nThis task has a dependency on \nTask 1.1.5\n and all of it's prerequisites\n\n\nTask\n\n\nIn this BONUS task, you want to configure your PWA to handle all requests that are send to your domain URL.  For example you should be able to create a link in a file or email that navigates to https://YOURSITENAME.azruewebsites.net/receiving and have that open the receiving section of your PWA instead of your website.   This is a stretch goal, and it takes a bit of manual configuration to work.\n\n\n\n\n\n\nUpdate your local manifest.xml (what you downloaded from pwabuilder.com)\n\n\n\n\n\n\nAdd JSON object to web site\n\n\n\n\n\n\nadd activation object to website\n\n\n\n\n\n\nRedeploy site\n\n\n\n\n\n\nreinstall your local app\n\n\n\n\n\n\nReferences\n\n\nhttps://docs.microsoft.com/en-us/windows/uwp/launch-resume/web-to-app-linking\n \n Note code samples in c#, but manifest changes are the same \n\n\nhttps://blogs.windows.com/buildingapps/2016/03/07/hosted-web-apps-go-beyond-the-app/#JoWUjrHvp5wDFPt1.97\n \n Note this shows you how to do a javascript activation object to navigate your app to the URL that launched it \n\n\ncontinue to \nNext Bonus task >>",
            "title": "123 BONUS APP Links"
        },
        {
            "location": "/stories/1/123_BONUS-APP-Links/#task",
            "text": "In this BONUS task, you want to configure your PWA to handle all requests that are send to your domain URL.  For example you should be able to create a link in a file or email that navigates to https://YOURSITENAME.azruewebsites.net/receiving and have that open the receiving section of your PWA instead of your website.   This is a stretch goal, and it takes a bit of manual configuration to work.    Update your local manifest.xml (what you downloaded from pwabuilder.com)    Add JSON object to web site    add activation object to website    Redeploy site    reinstall your local app",
            "title": "Task"
        },
        {
            "location": "/stories/1/123_BONUS-APP-Links/#references",
            "text": "https://docs.microsoft.com/en-us/windows/uwp/launch-resume/web-to-app-linking    Note code samples in c#, but manifest changes are the same   https://blogs.windows.com/buildingapps/2016/03/07/hosted-web-apps-go-beyond-the-app/#JoWUjrHvp5wDFPt1.97    Note this shows you how to do a javascript activation object to navigate your app to the URL that launched it",
            "title": "References"
        },
        {
            "location": "/stories/1/123_BONUS-APP-Links/#continue-to-next-bonus-task",
            "text": "",
            "title": "continue to Next Bonus task &gt;&gt;"
        },
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/",
            "text": "Task 1.2.4 - Add In-Memory Caching\n\n\nNow that you have a running PWA, we'd like you to improve the speed and performance of the Web App.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.2.2\n and all of it's prerequisites.\n\n\nTask\n\n\n\n\nThe website currently loads its data from static JSON files in its \nwwwroot\\Data\n folder. Speed up the performance of your website by caching values that are being used by controllers on your website. For example, after enabling caching, update the \nGenerateDropdowns\n method in \nReceivingsController.cs\n to cache the results.\n\n\nUpdate the local JSON files while you are running and notice the data does not update when you refresh.\n\n\nExperiment with different cache sliding expirations to see what happens when you use a more or less frequent expiration and change the local data.\n\n\nOnce the tasks in Section 4 are done, the site will have been updated by your team to get the data from the Shipping and Orders APIs. You can use the caching features to cache the data from the API, and include code to invalidate your cached data from the API after expiration.\n\n\n\n\nComments\n\n\n@ 3:37am\n\n\nI found \nthis guide\n that explains how in-memory caching works with ASP.NET Core.",
            "title": "124 BONUS InMemoryCaching"
        },
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/#task-124-add-in-memory-caching",
            "text": "Now that you have a running PWA, we'd like you to improve the speed and performance of the Web App.",
            "title": "Task 1.2.4 - Add In-Memory Caching"
        },
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/#prerequisites",
            "text": "This task has a dependency on  Task 1.2.2  and all of it's prerequisites.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/#task",
            "text": "The website currently loads its data from static JSON files in its  wwwroot\\Data  folder. Speed up the performance of your website by caching values that are being used by controllers on your website. For example, after enabling caching, update the  GenerateDropdowns  method in  ReceivingsController.cs  to cache the results.  Update the local JSON files while you are running and notice the data does not update when you refresh.  Experiment with different cache sliding expirations to see what happens when you use a more or less frequent expiration and change the local data.  Once the tasks in Section 4 are done, the site will have been updated by your team to get the data from the Shipping and Orders APIs. You can use the caching features to cache the data from the API, and include code to invalidate your cached data from the API after expiration.",
            "title": "Task"
        },
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/#337am",
            "text": "I found  this guide  that explains how in-memory caching works with ASP.NET Core.",
            "title": "@ 3:37am"
        },
        {
            "location": "/stories/1/NII126_cortana-Links/",
            "text": "Task 1.2.3 - Add Cortana Voice Commands\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.1.5\n and all of it's prerequisites\n\n\nTask\n\n\n\n\nCreate VCD file to listen for app commands\n\n\nAdd VCD to web site\n\n\nCreate activation object to handle cortana commands\n\n\nreinstall your local app (rerun script downloaded from pwabuilder.com)\n\n\n\n\nReferences\n\n\nhttps://blogs.windows.com/buildingapps/2016/03/01/building-a-media-centric-hosted-web-app/",
            "title": "NII126 cortana Links"
        },
        {
            "location": "/stories/1/NII126_cortana-Links/#task-123-add-cortana-voice-commands",
            "text": "",
            "title": "Task 1.2.3 - Add Cortana Voice Commands"
        },
        {
            "location": "/stories/1/NII126_cortana-Links/#prerequisites",
            "text": "This task has a dependency on  Task 1.1.5  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/1/NII126_cortana-Links/#task",
            "text": "Create VCD file to listen for app commands  Add VCD to web site  Create activation object to handle cortana commands  reinstall your local app (rerun script downloaded from pwabuilder.com)",
            "title": "Task"
        },
        {
            "location": "/stories/1/NII126_cortana-Links/#references",
            "text": "https://blogs.windows.com/buildingapps/2016/03/01/building-a-media-centric-hosted-web-app/",
            "title": "References"
        },
        {
            "location": "/stories/2/211_Centennial/",
            "text": "Task 2.1.1 - Add Desktop Bridge Support using Visual Studio 2017\n\n\nThis task will guide you through the process of converting an existing Win32 Desktop app to a Desktop Bridge UWP App using Visual Studio 2017. \nThere are a lot of steps to correctly setup Visual Studio 2017 to build and package your Win32 App as a UWP app. Each update of Visual Studio 2017 had made this process easier. \nFuture updates to Visual Studio 2017 will most likely add Desktop Bridge project templates that will automate this process. Until then, please follow this steps carefully.\n\n\nPrerequisites\n\n\n\n\n\n\nBasic knowledge of C# development\n\n\n\n\n\n\nBasic knowledge of client development with the .NET framework\n\n\n\n\n\n\nBasic knowledge of Windows 10 and the Universal Windows Platform\n\n\n\n\n\n\nA computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.\n\n\n\n\n\n\nVisual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free \nVisual Studio 2017 Community\n\n\n\n\n\n\nGo to the git repo at \nhttps://github.com/Knowzy/KnowzyInternalApps\n and clone or download the content onto your local computer.\n\n\n\n\n\n\nTask: Add Desktop Bridge support in Visual Studio\n\n\nStep 1: Open the existing Knowzy Win32 Solution with Visual Studio 2017\n\n\nWe will be converting an exiting WPF application from Win32 to UWP. To get started, please open the \nMicrosoft.Knowzy.WPF.sln\n in the \nsrc\\Knowzy_Engineering_Win32App\n folder with Visual Studio 2017.\n\n\nSet the Microsoft.Knowzy.WPF project as the startup project. Press F5 to build and run the project. Feel free to try out the application and then quit the application and return to Visual Studio.\n\n\nStep 2: Add a UWP Project\n\n\nWe will be using an empty UWP Visual Studio Project to package our WPF app into a UWP app.\n\n\nTo create a Desktop Bridge package, first add a C# Windows Universal Blank App project to the your solution.\n\n\n\n\nRight-click on the \nsrc\n folder in the Solution and select \nAdd | New Project...\n\n\n\n\n\n\n\n\n\n\nSelect the \nVisual C# | Windows Universal | Blank App (Universal Windows)\n project template. \n\n\n\n\n\n\nName the project \nMicrosoft.Knowzy.UWP\n. \n\n\n\n\n\n\nMake sure you save the project to the \nKnowzy_Engineering_Win32App\\src\n directory.\n\n\n\n\n\n\n\n\nMake sure the minimum Windows SDK version is 14393 or higher. Windows SDK 14393 or higher is required for Desktop Bridge apps. If you only have the 15063 SDK installed \nuse 15063 for the minimum SDK. You do not need to install the 14393 SDK to complete these tasks.\n\n\n\n\nYou solution should now contain the following projects.\n\n\n\n\n\n\n\n\nAdd a Project Dependency to Microsoft.Knowzy.WPF. Right click on the Microsoft.Knowzy.UWP project\n\n\n\n\n\n\nSelect \nBuild Dependencies | Project Dependencies...\"\n\n\n\n\n\n\n\n\n\n\nSelect the Microsoft.Knowzy.WPF project and click \nOK\n\n\n\n\n\n\nPress F7 (or whatever your Build Solution shortcut key is) to build the Solution. To see what an empty C# UWP app looks like:\n\n\n\n\n\n\nRight click on the Microsoft.Knowzy.UWP project and select \nDebug | Start new instance \n to run the UWP app.\n\n\n\n\n\n\nAn empty UWP app window will appear. Close the window to return to Visual Studio 2017.\n\n\n\n\n\n\nStep 3: Add the  Microsoft.Knowzy.WPF binaries to the UWP Project\n\n\nIn order to convert the Microsoft.Knowzy.WPF app to a Desktop Bridge UWP app, you will need to add the binaries created by the Microsoft.Knowzy.WPF app to the Microsoft.Knowzy.UWP app. \nWe are going to use the Microsoft.Knowzy.UWP project to create the AppX package that will eventually be submitted to the Windows Store. In later tasks, we will also use the Microsoft.Knowzy.UWP\nproject to add UWP features to our converted Microsoft.Knowzy.WPF app.\n\n\nAll the Win32 binaries created by the Win32 Microsoft.Knowzy.WPF project need to be copied to your UWP project to a folder called desktop (this exact name is not required; you can use any name you like).\nYou can automate the Microsoft.Knowzy.WPF project to copy these files after each build, improving the development workflow. We are going to edit the project file Microsoft.Knowzy.WPF.csproj\nto include an AfterBuild target that will copy all the Win32 output files to the desktop folder in the Microsoft.Knowzy.UWP project as follows:\n\n\n<Target Name=\"AfterBuild\">\n  <PropertyGroup>\n    <TargetUWP>..\\Microsoft.Knowzy.UWP\\desktop\\</TargetUWP>\n  </PropertyGroup>\n  <ItemGroup>\n    <DesktopBinaries Include=\"$(TargetDir)\\**\\*.*\" />\n    <ExcludeFilters Include=\"$(TargetDir)\\**\\*.winmd\" />\n  </ItemGroup>\n  <ItemGroup>\n    <DesktopBinaries Include=\"$(TargetDir)\\**\\*.*\" />\n  </ItemGroup>\n  <ItemGroup>\n    <DesktopBinaries Remove=\"@(ExcludeFilters)\" />\n  </ItemGroup>\n  <Copy SourceFiles=\"@(DesktopBinaries)\" DestinationFiles=\"@(DesktopBinaries->'$(TargetUWP)\\%(RecursiveDir)%(Filename)%(Extension)')\" />\n</Target>\n\n\n\nThis rather complicated bit of XML completes several important tasks:\n\n\n\n\n\n\nTargetUWP specifies where to copy the Win32 binaries. In this example, the binaries will be copied to the desktop folder in the Microsoft.Knowzy.UWP project folder.\n\n\n\n\n\n\nThe files will be copied preserving their directory structure by specifying %(RecursiveDir)%(Filename)%(Extension) in the Copy tag\n\n\n\n\n\n\nAny .winmd files in the Microsoft.Knowzy.WPF output folder will not be copied to the output directory. This is specified with the ExcludeFilters tag.\n\n\n\n\n\n\nall of the DLL dependcies of the Microsoft.Knowzy.WPF exe (including the ones from the NuGet packages) will be copied to the output directory.\n\n\n\n\n\n\nYou can edit the XML of the Microsoft.Knowzy.WPF.csproj in Visual Studio by right-clicking on the project and selecting \nUnload project\n\n\n\n\nRight-click again on Microsoft.Knowzy.WPF.csproj and select \nEdit MyDesktopApp.csproj\n\n\n\n\nScroll to the end of the xml file and paste the above xml code to the end of the file \nbefore the final project tag\n.\nSave your changes and then reload Microsoft.Knowzy.WPF\n\n\n\n\nRebuild the solution so the Microsoft.Knowzy.UWP project binaries will be copied to the Microsoft.Knowzy.UWP/desktop folder.\n\n\nNow that the Win32 binaries are copied to the desktop folder in the Microsoft.Knowzy.UWP project after the build, we need to add the binaries to the UWP project so they will be packaged with the UWP app.\nWe can automate this process by editing the Microsoft.Knowzy.UWP.csproj project. Following the same procedure you just completed when editing the Microsoft.Knowzy.WPF.csproj file, \nyou will unload, edit and reload the Microsoft.Knowzy.UWP.csproj project file. Add the following XML to the end of the Microsoft.Knowzy.UWP.csproj project file.\n\n\n<ItemGroup>\n  <Content Include=\"desktop\\**\\*.*\">\n    <Link>desktop\\%(RecursiveDir)%(FileName)%(Extension)</Link>\n    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n  </Content>\n</ItemGroup>\n\n\n\nThis segment of XML completes several important tasks:\n\n\n\n\n\n\nAll of the files in the desktop folder will be packaged with the UWP app\n\n\n\n\n\n\nThe files will be copied to the AppX preserving their directory structure by specifying %(RecursiveDir)%(Filename)%(Extension) in the Link tag\n\n\n\n\n\n\nThis process will be automated with every build of the solution.\n\n\n\n\n\n\nReload the Microsoft.Knowzy.UWP.csproj and build the solution. \n\n\n\n\n\n\nVerify that the src\\Microsoft.Knowzy.UWP folder contains a desktop folder. If the folder is missing, close and reopen the Microsoft.Knowzy.WPF.sln.\n\n\n\n\n\n\nYou should be able to run the src\\Microsoft.Knowzy.UWP\\desktop\\Microsoft.Knowzy.WPF.exe app by navigating to the folder and double-clicking on Microsoft.Knowzy.WPF.exe. This will test that all of the dependencies for Microsoft.Knowzy.WPF.exe were copied correctly to the desktop folder.\n\n\n\n\n\n\n\n\nStep 4: Edit the Microsoft.Knowzy.UWP Package Manifest to enable the Desktop Bridge Extensions\n\n\nThe Microsoft.Knowzy.UWP project contains a file called Package.appxmanifest that describes how to package your UWP app and its dependencies for the Windows Store. \nThe package manifest is an XML document that contains the info the system needs to deploy, display, or update a Windows app. This info includes package identity, \npackage dependencies, required capabilities, visual elements, and extensibility points. Every UWP app package must include one package manifest.\n\n\nWe need to edit this file so it includes the infomation needed to run our Win32 WPF app as a UWP app. \n\n\nYou edit the Package.appxmanifest xml file by right-clicking on the file in the Microsoft.Knowzy.UWP project and selecting \nView Code\n\n\n\n\nWe will now edit the XML to add the DeskTop Bridge extensions. This will enable your Win32 app to run as a UWP app.\n\n\n\n\n\n\nReplace the line (near line 7):\n\n\nIgnorableNamespaces=\"uap mp\">\n\n\n\nwith\n\n\nxmlns:rescap=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities\" \nxmlns:desktop=\"http://schemas.microsoft.com/appx/manifest/desktop/windows10\" \nxmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"\nIgnorableNamespaces=\"uap mp rescap desktop\">\n\n\n\nAdding these namespaces will allow us to add the Desktop Bridge extensions to our app.\n\n\n\n\n\n\nWe need to describe to Windows 10 that our app is a Desktop Bridge App. We also ned to specify a minimum version of 13493.\nReplace the line (near line 25):\n\n\n<TargetDeviceFamily Name=\"Windows.Universal\" MinVersion=\"10.0.0.0\" MaxVersionTested=\"10.0.0.0\" />\n\n\n\nwith\n\n\n<TargetDeviceFamily Name=\"Windows.Desktop\" MinVersion=\"10.0.14393.0\" MaxVersionTested=\"10.0.14393.0\" />\n\n\n\n\n\n\n\nWe need to tell Windows 10 that our app is a Desktop Bridge App and needs to run as a Full Trust application. This\ncapability grants Desktop app capabilities to our UWP app. Add the following capability to the Capabilities section (near line 49)\n\n\n<rescap:Capability Name=\"runFullTrust\" />\n\n\n\n\n\n\n\nWe also need to specify that we are a Full Trust application in the Application tag. This tag also points to our WPF exe as executable for out app.\nModify the Application tag to the following (near line 34):\n\n\n<Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\">\n\n\n\n\n\n\n\nYour package.appxmanifest should now look something like:\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<Package\n  xmlns=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\"\n  xmlns:mp=\"http://schemas.microsoft.com/appx/2014/phone/manifest\"\n  xmlns:uap=\"http://schemas.microsoft.com/appx/manifest/uap/windows10\"\n  xmlns:rescap=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities\"\n  xmlns:desktop=\"http://schemas.microsoft.com/appx/manifest/desktop/windows10\"\n  xmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"\n  IgnorableNamespaces=\"uap mp rescap desktop\">\n\n  <Identity\n    Name=\"9aed127a-4cd4-4b87-a6a6-4b63499a73cb\"\n    Publisher=\"CN=stammen\"\n    Version=\"1.0.0.0\" />\n\n  <mp:PhoneIdentity PhoneProductId=\"9aed127a-4cd4-4b87-a6a6-4b63499a73cb\" PhonePublisherId=\"00000000-0000-0000-0000-000000000000\"/>\n\n  <Properties>\n    <DisplayName>Microsoft.Knowzy.UWP</DisplayName>\n    <PublisherDisplayName>stammen</PublisherDisplayName>\n    <Logo>Assets\\StoreLogo.png</Logo>\n  </Properties>\n\n  <Dependencies>\n    <TargetDeviceFamily Name=\"Windows.Desktop\" MinVersion=\"10.0.14393.0\" MaxVersionTested=\"10.0.14393.0\" />\n  </Dependencies>\n\n  <Resources>\n    <Resource Language=\"x-generate\"/>\n  </Resources>\n\n  <Applications>\n    <Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\">\n      <uap:VisualElements\n        DisplayName=\"Microsoft.Knowzy.UWP\"\n        Square150x150Logo=\"Assets\\Square150x150Logo.png\"\n        Square44x44Logo=\"Assets\\Square44x44Logo.png\"\n        Description=\"Microsoft.Knowzy.UWP\"\n        BackgroundColor=\"transparent\">\n        <uap:DefaultTile Wide310x150Logo=\"Assets\\Wide310x150Logo.png\"/>\n        <uap:SplashScreen Image=\"Assets\\SplashScreen.png\" />\n      </uap:VisualElements>\n    </Application>\n  </Applications>\n\n  <Capabilities>\n    <Capability Name=\"internetClient\" />\n    <rescap:Capability Name=\"runFullTrust\" />\n  </Capabilities>\n</Package>\n\n\n\nNote: Your Publisher, PublisherDisplayName and other app id properties will be different.\n\n\nStep 5: Deploy and run your converted Win32 App\n\n\nYour converted Win32 app is now ready to be deployed and run as a UWP app on your computer.\n\n\nNote: If your Solution configuration is \nDebug | Any CPU\n you will need to enable both the Build and Deploy setting of the Microsoft.Knowzy.UWP app using the Configuration Manager.\n\n\n\n\nMake sure that both \nBuild\n and \nDeploy\n are selected for the  Microsoft.Knowzy.UWP project.\n\n\n\n\n\n\n\n\nBuild the solution to make sure there are no errors.\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.UWP project and select \nDeploy\n from the menu. \n\n\n\n\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.UWP project and select \nDeploy\n from the menu. You will most likely get the following error:\n1>------ Build started: Project: Microsoft.Knowzy.UWP, Configuration: Debug x86 ------\n1>  Microsoft.Knowzy.UWP -> C:\\Users\\stammen\\github\\BuildTourHack\\src\\Microsoft.Knowzy.UWP\\bin\\x86\\Debug\\Microsoft.Knowzy.UWP.exe\n1>C:\\Program Files (x86)\\MSBuild\\15.0\\.Net\\CoreRuntime\\Microsoft.Net.CoreRuntime.targets(236,5): error : Applications with custom entry point executables are not supported. Check Executable attribute of the Application element in the package manifest\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\n========== Deploy: 0 succeeded, 0 failed, 0 skipped ==========\n\n\n\n\n\n\n\nUnfortunately there is a bug in the current version of Visual Studio 2017 that prevents \nDebug\n builds of C# Desktop Bridge apps from being deployed. This bug will be fixed in a future update to Visual Studio 2017.\nUntil the bug is fixed, we will need to use the \nRelease\n configuration for our C# Desktop Bridge app. We will use the \n*Build | Configuration Manager\n to set this up.\n\n\n\n\nSelect \nConfiguration Manager\n from the \nBuild\n menu.\n\n\nFor the Microsoft.Knowzy.UWP project, set the Configuration to \nRelease\n. \nYou should also do this for the x86 and x64 Platform builds\n.\n\n\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.UWP project and select \nDeploy\n from the menu.\n2>------ Deploy started: Project: Microsoft.Knowzy.UWP, Configuration: Release x86 ------\n2>Creating a new clean layout...\n2>Copying files: Total 11 mb to layout...\n2>Checking whether required frameworks are installed...\n2>Registering the application to run from layout...\n2>Deployment complete (0:00:01.818). Full package name: \"9aed127a-4cd4-4b87-a6a6-4b63499a73cb_1.0.0.0_x86__71pt5m19pd38p\"\n========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========\n========== Deploy: 1 succeeded, 0 failed, 0 skipped ==========\n\n\n\n\n\n\n\nYour Win32 WPF app has now been packaged as a UWP App using Visual Studio.\n\n\nSearch for your Microsoft.Knowzy.UWP in the Windows Start menu. Click on Microsoft.Knowzy.UWP to launch your app. \n\n\n\n\nUnfortunately the Microsoft.Knowzy.UWP app did not run. Actually it did run but exited immediately due to an error.\nThe actual error is the app cannot load the project.json file it needs to generate the Products list. The app then \nthrows an exception and exits.\n\n\nJust so you aren't disappointed in not seeing the new UWP app run after completing all of these steps, let's quickly fix the issue with a hack.\n\n\n\n\nOpen the file MainViewModel.cs in the ViewModels folder of the Microsoft.Knowzy.WPF project\n\n\n\n\n\n\n\n\n\n\nGo to the OnViewAttached() method at line 70 and comment out lines 72-75 statement after base.OnActivate();\n\n\nprotected override void OnViewAttached(object view, object context)\n{\n    /*\n    foreach (var item in _dataProvider.GetData())\n    {\n  DevelopmentItems.Add(new ItemViewModel(item, _eventAggregator));\n    }\n    */\n\n    base.OnViewAttached(view, context);\n}\n\n\n\n\n\n\n\nSelect \nRebuild Solution\n from the \nBuild\n menu.\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.UWP project and select \nDeploy\n from the menu.\n\n\n\n\n\n\nSearch for your Microsoft.Knowzy.UWP in the Windows Start menu. Click on Microsoft.Knowzy.UWP to launch your app. \n\n\n\n\n\n\nThe Microsoft.Knowzy.UWP app should now run with the hacked code.\n\n\n\n\nStep 6: Debugging your Desktop Bridge app\n\n\nIn order to fix the crashing bug in the UWP app, you need to be able to debug the various Knowzy projects. Let's try to debug the Microsoft.Knowzy.UWP project. \n\n\n\n\nRight-click on the Microsoft.Knowzy.UWP project and select \nSet as StartUp Project\n\n\n\n\n\n\n\n\nPress F5 to start a debugging session for your UWP app. You will probably encounter the following error:\n\n\n\n\n\n\nWe will fix this error and enable the debugging of our app in the \nnext task\n.\n\n\nReferences\n\n\n\n\n\n\nPackage a .NET app using Visual Studio \n\n\n\n\n\n\nBridgeTour Workshop\n\n\n\n\n\n\nDevelopers Guide to the Desktop Bridge\n\n\n\n\n\n\ncontinue to \nnext task >>",
            "title": "211 Centennial"
        },
        {
            "location": "/stories/2/211_Centennial/#task-211-add-desktop-bridge-support-using-visual-studio-2017",
            "text": "This task will guide you through the process of converting an existing Win32 Desktop app to a Desktop Bridge UWP App using Visual Studio 2017. \nThere are a lot of steps to correctly setup Visual Studio 2017 to build and package your Win32 App as a UWP app. Each update of Visual Studio 2017 had made this process easier. \nFuture updates to Visual Studio 2017 will most likely add Desktop Bridge project templates that will automate this process. Until then, please follow this steps carefully.",
            "title": "Task 2.1.1 - Add Desktop Bridge Support using Visual Studio 2017"
        },
        {
            "location": "/stories/2/211_Centennial/#prerequisites",
            "text": "Basic knowledge of C# development    Basic knowledge of client development with the .NET framework    Basic knowledge of Windows 10 and the Universal Windows Platform    A computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.    Visual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free  Visual Studio 2017 Community    Go to the git repo at  https://github.com/Knowzy/KnowzyInternalApps  and clone or download the content onto your local computer.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/2/211_Centennial/#task-add-desktop-bridge-support-in-visual-studio",
            "text": "",
            "title": "Task: Add Desktop Bridge support in Visual Studio"
        },
        {
            "location": "/stories/2/211_Centennial/#step-1-open-the-existing-knowzy-win32-solution-with-visual-studio-2017",
            "text": "We will be converting an exiting WPF application from Win32 to UWP. To get started, please open the  Microsoft.Knowzy.WPF.sln  in the  src\\Knowzy_Engineering_Win32App  folder with Visual Studio 2017.  Set the Microsoft.Knowzy.WPF project as the startup project. Press F5 to build and run the project. Feel free to try out the application and then quit the application and return to Visual Studio.",
            "title": "Step 1: Open the existing Knowzy Win32 Solution with Visual Studio 2017"
        },
        {
            "location": "/stories/2/211_Centennial/#step-2-add-a-uwp-project",
            "text": "We will be using an empty UWP Visual Studio Project to package our WPF app into a UWP app.  To create a Desktop Bridge package, first add a C# Windows Universal Blank App project to the your solution.   Right-click on the  src  folder in the Solution and select  Add | New Project...      Select the  Visual C# | Windows Universal | Blank App (Universal Windows)  project template.     Name the project  Microsoft.Knowzy.UWP .     Make sure you save the project to the  Knowzy_Engineering_Win32App\\src  directory.     Make sure the minimum Windows SDK version is 14393 or higher. Windows SDK 14393 or higher is required for Desktop Bridge apps. If you only have the 15063 SDK installed \nuse 15063 for the minimum SDK. You do not need to install the 14393 SDK to complete these tasks.   You solution should now contain the following projects.     Add a Project Dependency to Microsoft.Knowzy.WPF. Right click on the Microsoft.Knowzy.UWP project    Select  Build Dependencies | Project Dependencies...\"      Select the Microsoft.Knowzy.WPF project and click  OK    Press F7 (or whatever your Build Solution shortcut key is) to build the Solution. To see what an empty C# UWP app looks like:    Right click on the Microsoft.Knowzy.UWP project and select  Debug | Start new instance   to run the UWP app.    An empty UWP app window will appear. Close the window to return to Visual Studio 2017.",
            "title": "Step 2: Add a UWP Project"
        },
        {
            "location": "/stories/2/211_Centennial/#step-3-add-the-microsoftknowzywpf-binaries-to-the-uwp-project",
            "text": "In order to convert the Microsoft.Knowzy.WPF app to a Desktop Bridge UWP app, you will need to add the binaries created by the Microsoft.Knowzy.WPF app to the Microsoft.Knowzy.UWP app. \nWe are going to use the Microsoft.Knowzy.UWP project to create the AppX package that will eventually be submitted to the Windows Store. In later tasks, we will also use the Microsoft.Knowzy.UWP\nproject to add UWP features to our converted Microsoft.Knowzy.WPF app.  All the Win32 binaries created by the Win32 Microsoft.Knowzy.WPF project need to be copied to your UWP project to a folder called desktop (this exact name is not required; you can use any name you like).\nYou can automate the Microsoft.Knowzy.WPF project to copy these files after each build, improving the development workflow. We are going to edit the project file Microsoft.Knowzy.WPF.csproj\nto include an AfterBuild target that will copy all the Win32 output files to the desktop folder in the Microsoft.Knowzy.UWP project as follows:  <Target Name=\"AfterBuild\">\n  <PropertyGroup>\n    <TargetUWP>..\\Microsoft.Knowzy.UWP\\desktop\\</TargetUWP>\n  </PropertyGroup>\n  <ItemGroup>\n    <DesktopBinaries Include=\"$(TargetDir)\\**\\*.*\" />\n    <ExcludeFilters Include=\"$(TargetDir)\\**\\*.winmd\" />\n  </ItemGroup>\n  <ItemGroup>\n    <DesktopBinaries Include=\"$(TargetDir)\\**\\*.*\" />\n  </ItemGroup>\n  <ItemGroup>\n    <DesktopBinaries Remove=\"@(ExcludeFilters)\" />\n  </ItemGroup>\n  <Copy SourceFiles=\"@(DesktopBinaries)\" DestinationFiles=\"@(DesktopBinaries->'$(TargetUWP)\\%(RecursiveDir)%(Filename)%(Extension)')\" />\n</Target>  This rather complicated bit of XML completes several important tasks:    TargetUWP specifies where to copy the Win32 binaries. In this example, the binaries will be copied to the desktop folder in the Microsoft.Knowzy.UWP project folder.    The files will be copied preserving their directory structure by specifying %(RecursiveDir)%(Filename)%(Extension) in the Copy tag    Any .winmd files in the Microsoft.Knowzy.WPF output folder will not be copied to the output directory. This is specified with the ExcludeFilters tag.    all of the DLL dependcies of the Microsoft.Knowzy.WPF exe (including the ones from the NuGet packages) will be copied to the output directory.    You can edit the XML of the Microsoft.Knowzy.WPF.csproj in Visual Studio by right-clicking on the project and selecting  Unload project   Right-click again on Microsoft.Knowzy.WPF.csproj and select  Edit MyDesktopApp.csproj   Scroll to the end of the xml file and paste the above xml code to the end of the file  before the final project tag .\nSave your changes and then reload Microsoft.Knowzy.WPF   Rebuild the solution so the Microsoft.Knowzy.UWP project binaries will be copied to the Microsoft.Knowzy.UWP/desktop folder.  Now that the Win32 binaries are copied to the desktop folder in the Microsoft.Knowzy.UWP project after the build, we need to add the binaries to the UWP project so they will be packaged with the UWP app.\nWe can automate this process by editing the Microsoft.Knowzy.UWP.csproj project. Following the same procedure you just completed when editing the Microsoft.Knowzy.WPF.csproj file, \nyou will unload, edit and reload the Microsoft.Knowzy.UWP.csproj project file. Add the following XML to the end of the Microsoft.Knowzy.UWP.csproj project file.  <ItemGroup>\n  <Content Include=\"desktop\\**\\*.*\">\n    <Link>desktop\\%(RecursiveDir)%(FileName)%(Extension)</Link>\n    <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>\n  </Content>\n</ItemGroup>  This segment of XML completes several important tasks:    All of the files in the desktop folder will be packaged with the UWP app    The files will be copied to the AppX preserving their directory structure by specifying %(RecursiveDir)%(Filename)%(Extension) in the Link tag    This process will be automated with every build of the solution.    Reload the Microsoft.Knowzy.UWP.csproj and build the solution.     Verify that the src\\Microsoft.Knowzy.UWP folder contains a desktop folder. If the folder is missing, close and reopen the Microsoft.Knowzy.WPF.sln.    You should be able to run the src\\Microsoft.Knowzy.UWP\\desktop\\Microsoft.Knowzy.WPF.exe app by navigating to the folder and double-clicking on Microsoft.Knowzy.WPF.exe. This will test that all of the dependencies for Microsoft.Knowzy.WPF.exe were copied correctly to the desktop folder.",
            "title": "Step 3: Add the  Microsoft.Knowzy.WPF binaries to the UWP Project"
        },
        {
            "location": "/stories/2/211_Centennial/#step-4-edit-the-microsoftknowzyuwp-package-manifest-to-enable-the-desktop-bridge-extensions",
            "text": "The Microsoft.Knowzy.UWP project contains a file called Package.appxmanifest that describes how to package your UWP app and its dependencies for the Windows Store. \nThe package manifest is an XML document that contains the info the system needs to deploy, display, or update a Windows app. This info includes package identity, \npackage dependencies, required capabilities, visual elements, and extensibility points. Every UWP app package must include one package manifest.  We need to edit this file so it includes the infomation needed to run our Win32 WPF app as a UWP app.   You edit the Package.appxmanifest xml file by right-clicking on the file in the Microsoft.Knowzy.UWP project and selecting  View Code   We will now edit the XML to add the DeskTop Bridge extensions. This will enable your Win32 app to run as a UWP app.    Replace the line (near line 7):  IgnorableNamespaces=\"uap mp\">  with  xmlns:rescap=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities\" \nxmlns:desktop=\"http://schemas.microsoft.com/appx/manifest/desktop/windows10\" \nxmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"\nIgnorableNamespaces=\"uap mp rescap desktop\">  Adding these namespaces will allow us to add the Desktop Bridge extensions to our app.    We need to describe to Windows 10 that our app is a Desktop Bridge App. We also ned to specify a minimum version of 13493.\nReplace the line (near line 25):  <TargetDeviceFamily Name=\"Windows.Universal\" MinVersion=\"10.0.0.0\" MaxVersionTested=\"10.0.0.0\" />  with  <TargetDeviceFamily Name=\"Windows.Desktop\" MinVersion=\"10.0.14393.0\" MaxVersionTested=\"10.0.14393.0\" />    We need to tell Windows 10 that our app is a Desktop Bridge App and needs to run as a Full Trust application. This\ncapability grants Desktop app capabilities to our UWP app. Add the following capability to the Capabilities section (near line 49)  <rescap:Capability Name=\"runFullTrust\" />    We also need to specify that we are a Full Trust application in the Application tag. This tag also points to our WPF exe as executable for out app.\nModify the Application tag to the following (near line 34):  <Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\">    Your package.appxmanifest should now look something like:  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n\n<Package\n  xmlns=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\"\n  xmlns:mp=\"http://schemas.microsoft.com/appx/2014/phone/manifest\"\n  xmlns:uap=\"http://schemas.microsoft.com/appx/manifest/uap/windows10\"\n  xmlns:rescap=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities\"\n  xmlns:desktop=\"http://schemas.microsoft.com/appx/manifest/desktop/windows10\"\n  xmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"\n  IgnorableNamespaces=\"uap mp rescap desktop\">\n\n  <Identity\n    Name=\"9aed127a-4cd4-4b87-a6a6-4b63499a73cb\"\n    Publisher=\"CN=stammen\"\n    Version=\"1.0.0.0\" />\n\n  <mp:PhoneIdentity PhoneProductId=\"9aed127a-4cd4-4b87-a6a6-4b63499a73cb\" PhonePublisherId=\"00000000-0000-0000-0000-000000000000\"/>\n\n  <Properties>\n    <DisplayName>Microsoft.Knowzy.UWP</DisplayName>\n    <PublisherDisplayName>stammen</PublisherDisplayName>\n    <Logo>Assets\\StoreLogo.png</Logo>\n  </Properties>\n\n  <Dependencies>\n    <TargetDeviceFamily Name=\"Windows.Desktop\" MinVersion=\"10.0.14393.0\" MaxVersionTested=\"10.0.14393.0\" />\n  </Dependencies>\n\n  <Resources>\n    <Resource Language=\"x-generate\"/>\n  </Resources>\n\n  <Applications>\n    <Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\">\n      <uap:VisualElements\n        DisplayName=\"Microsoft.Knowzy.UWP\"\n        Square150x150Logo=\"Assets\\Square150x150Logo.png\"\n        Square44x44Logo=\"Assets\\Square44x44Logo.png\"\n        Description=\"Microsoft.Knowzy.UWP\"\n        BackgroundColor=\"transparent\">\n        <uap:DefaultTile Wide310x150Logo=\"Assets\\Wide310x150Logo.png\"/>\n        <uap:SplashScreen Image=\"Assets\\SplashScreen.png\" />\n      </uap:VisualElements>\n    </Application>\n  </Applications>\n\n  <Capabilities>\n    <Capability Name=\"internetClient\" />\n    <rescap:Capability Name=\"runFullTrust\" />\n  </Capabilities>\n</Package>  Note: Your Publisher, PublisherDisplayName and other app id properties will be different.",
            "title": "Step 4: Edit the Microsoft.Knowzy.UWP Package Manifest to enable the Desktop Bridge Extensions"
        },
        {
            "location": "/stories/2/211_Centennial/#step-5-deploy-and-run-your-converted-win32-app",
            "text": "Your converted Win32 app is now ready to be deployed and run as a UWP app on your computer.  Note: If your Solution configuration is  Debug | Any CPU  you will need to enable both the Build and Deploy setting of the Microsoft.Knowzy.UWP app using the Configuration Manager.   Make sure that both  Build  and  Deploy  are selected for the  Microsoft.Knowzy.UWP project.     Build the solution to make sure there are no errors.    Right-click on the Microsoft.Knowzy.UWP project and select  Deploy  from the menu.       Right-click on the Microsoft.Knowzy.UWP project and select  Deploy  from the menu. You will most likely get the following error: 1>------ Build started: Project: Microsoft.Knowzy.UWP, Configuration: Debug x86 ------\n1>  Microsoft.Knowzy.UWP -> C:\\Users\\stammen\\github\\BuildTourHack\\src\\Microsoft.Knowzy.UWP\\bin\\x86\\Debug\\Microsoft.Knowzy.UWP.exe\n1>C:\\Program Files (x86)\\MSBuild\\15.0\\.Net\\CoreRuntime\\Microsoft.Net.CoreRuntime.targets(236,5): error : Applications with custom entry point executables are not supported. Check Executable attribute of the Application element in the package manifest\n========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\n========== Deploy: 0 succeeded, 0 failed, 0 skipped ==========    Unfortunately there is a bug in the current version of Visual Studio 2017 that prevents  Debug  builds of C# Desktop Bridge apps from being deployed. This bug will be fixed in a future update to Visual Studio 2017.\nUntil the bug is fixed, we will need to use the  Release  configuration for our C# Desktop Bridge app. We will use the  *Build | Configuration Manager  to set this up.   Select  Configuration Manager  from the  Build  menu.  For the Microsoft.Knowzy.UWP project, set the Configuration to  Release .  You should also do this for the x86 and x64 Platform builds .     Right-click on the Microsoft.Knowzy.UWP project and select  Deploy  from the menu. 2>------ Deploy started: Project: Microsoft.Knowzy.UWP, Configuration: Release x86 ------\n2>Creating a new clean layout...\n2>Copying files: Total 11 mb to layout...\n2>Checking whether required frameworks are installed...\n2>Registering the application to run from layout...\n2>Deployment complete (0:00:01.818). Full package name: \"9aed127a-4cd4-4b87-a6a6-4b63499a73cb_1.0.0.0_x86__71pt5m19pd38p\"\n========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========\n========== Deploy: 1 succeeded, 0 failed, 0 skipped ==========    Your Win32 WPF app has now been packaged as a UWP App using Visual Studio.  Search for your Microsoft.Knowzy.UWP in the Windows Start menu. Click on Microsoft.Knowzy.UWP to launch your app.    Unfortunately the Microsoft.Knowzy.UWP app did not run. Actually it did run but exited immediately due to an error.\nThe actual error is the app cannot load the project.json file it needs to generate the Products list. The app then \nthrows an exception and exits.  Just so you aren't disappointed in not seeing the new UWP app run after completing all of these steps, let's quickly fix the issue with a hack.   Open the file MainViewModel.cs in the ViewModels folder of the Microsoft.Knowzy.WPF project      Go to the OnViewAttached() method at line 70 and comment out lines 72-75 statement after base.OnActivate();  protected override void OnViewAttached(object view, object context)\n{\n    /*\n    foreach (var item in _dataProvider.GetData())\n    {\n  DevelopmentItems.Add(new ItemViewModel(item, _eventAggregator));\n    }\n    */\n\n    base.OnViewAttached(view, context);\n}    Select  Rebuild Solution  from the  Build  menu.    Right-click on the Microsoft.Knowzy.UWP project and select  Deploy  from the menu.    Search for your Microsoft.Knowzy.UWP in the Windows Start menu. Click on Microsoft.Knowzy.UWP to launch your app.     The Microsoft.Knowzy.UWP app should now run with the hacked code.",
            "title": "Step 5: Deploy and run your converted Win32 App"
        },
        {
            "location": "/stories/2/211_Centennial/#step-6-debugging-your-desktop-bridge-app",
            "text": "In order to fix the crashing bug in the UWP app, you need to be able to debug the various Knowzy projects. Let's try to debug the Microsoft.Knowzy.UWP project.    Right-click on the Microsoft.Knowzy.UWP project and select  Set as StartUp Project     Press F5 to start a debugging session for your UWP app. You will probably encounter the following error:    We will fix this error and enable the debugging of our app in the  next task .",
            "title": "Step 6: Debugging your Desktop Bridge app"
        },
        {
            "location": "/stories/2/211_Centennial/#references",
            "text": "Package a .NET app using Visual Studio     BridgeTour Workshop    Developers Guide to the Desktop Bridge",
            "title": "References"
        },
        {
            "location": "/stories/2/211_Centennial/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/2/212_Debugging/",
            "text": "Task 2.1.2 - Debugging a Windows Desktop Bridge App\n\n\nThis task will guide you through the process of debugging a Windows Desktop Bridge App using Visual Studio 2017. \n\n\nPrerequisites\n\n\n\n\n\n\nBasic knowledge of C# development\n\n\n\n\n\n\nBasic knowledge of client development with the .NET framework\n\n\n\n\n\n\nBasic knowledge of Windows 10 and the Universal Windows Platform\n\n\n\n\n\n\nA computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.\n\n\n\n\n\n\nVisual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free \nVisual Studio 2017 Community\n\n\n\n\n\n\nThe \nDesktop Bridge Debugging Project template\n installed into Visual Studio 2017\n\n\n\n\n\n\nComplete the section on \nAdd Desktop Bridge Support using Visual Studio 2017\n\n\n\n\n\n\nTo get started, please open the \nMicrosoft.Knowzy.WPF.sln\n in the \nsrc\\Knowzy_Engineering_Win32App\n folder with Visual Studio 2017.\n\n\nStep 1: Install the Desktop Bridge Debugging Project Extension\n\n\nIf you do not have the Desktop Bridge Debugging Project extension installed into Visual Studio 2017, please complete the following steps:\n\n\n\n\nClick on the \nTools\n menu and select \nExtensions and Updates...\n\n\n\n\n\n\n\n\nSelect \nOnline\n and enter \nDesktop Bridge Debugging Project\n in the search field. Click \nDownload\n.\n\n\n\n\n\n\n\n\n\n\nClose Visual Studio 2017 and the Desktop Bridge Debugging Project Extension will be installed.\n\n\n\n\n\n\nReopen your Desktop Bridge solution from the \nAdd Centennial Support using Visual Studio 2017\n task.\n\n\n\n\n\n\nStep 2: Add the Desktop Bridge Debugging Project to the Solution\n\n\n\n\nRight-click on the src folder in the Solution and select \nAdd | New Project...\n\n\n\n\n\n\n\n\nSelect the \nOther Project Types | Desktop Bridge Debugging Project\n project template. \n\n\n\n\n\n\n\n\n\n\nName the project Microsoft.Knowzy.Debug.\n\n\n\n\n\n\nMake sure you save the project to the \nKnowzy_Engineering_Win32App\\src\n folder.\n\n\n\n\n\n\nYou solution should now contain the following projects.\n\n\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.Debug project and select \nBuild Dependencies | Project Dependencies...\"\n\n\n\n\n\n\nSelect the Microsoft.Knowzy.WPF and Microsoft.Knowzy.UWP projects and click \nOK\n.\n\n\n\n\n\n\nStep 3: Configure the Desktop Bridge Debugging Project\n\n\nSince we will be working a lot with the Microsoft.Knowzy.UWP project, set the Build Configuration and Platform to \nDebug | x86\n\n\n\n\nClean\n the solution by selecting \nClean Solution\n from the \nBuild\n menu.\n\n\nBuild\n the x86 configuration of the solution. (Select \nBuild Solution\n from the \nBuild\n menu).\n\n\nAfter the build completes, deploy the Microsoft.Knowzy.UWP project so its AppX folder is created. The next step needs the AppX folder.\n(Select \nDeploy Solution\n from the \nBuild\n menu).\n\n\nRight-click on the Microsoft.Knowzy.Debug project and select \nSet as Startup Project\n. \n\n\n\n\nRight-click on the Microsoft.Knowzy.Debug project and select \nProperties\n. \n\n\nFor Debug builds use the following settings:\n\n\n\n\n\n\nPackage Layout: ..\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\n\n\n\n\n\n\nSelect Uninstall and then re-install my package.\n\n\n\n\n\n\nFrom the \nPackage Layout\n field tab to the \nStart Up Tile\n field and select Microsoft.Knowzy.WPF.\n\n\n\n\n\n\nNotice that we are specifying the path to the \nRelease\n build of the Microsoft.Knowzy.UWP project. This is a fix for the\nVisual 2017 C# UWP Desktop Bridge deployment bug we experienced in the previous task.\n\n\n\n\n\n\n\n\nSave and Close the Properties windows. \n\n\n\n\n\n\nNote:\n The Properties window can be a little buggy in saving your settings so make sure they were saved. Most issues with debugging are caused by\nincorrect Debugging Project settings.\n\n\n\n\n\n\nNote:\n You will need to add the correct Debugging Project Properties for x86 Release and x64 Debug and Release configurations if you want to build them.\n\n\n\n\n\n\n\n\n\n\nOpen the AppXPackageFileList.xml file in the Microsoft.Knowzy.Debug project\n\n\n\n\n\n\n\n\n\n\nModify the xml to the following:\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"14.0\"\n        xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <MyProjectOutputPath>..\\..\\bin\\Debug</MyProjectOutputPath>\n  </PropertyGroup>\n  <ItemGroup>\n    <LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.WPF.exe\">\n      <PackagePath>$(PackageLayout)\\desktop\\Microsoft.Knowzy.WPF.exe</PackagePath>\n    </LayoutFile>\n  </ItemGroup>\n</Project>\n\n\n\n\n\n\n\nThis XML describes to the DesktopBridge Debugging project the location of the Microsoft.Knowzy.WPF.exe after it is built. It will use it when the project is launched and copy it to the correct location in the AppX package.\nThis will allow for any changes to the Microsoft.Knowzy.WPF project code to be included in the debugging session. The need for the Desktop Bridge Debugging project will most likely change in future updates to Visual Studio 2017.\n\n\n\n\n\n\nSave your changes. \n\n\n\n\n\n\nNow it is time to \nClean\n the solution and then \nBuild\n the Solution.\n\n\n\n\n\n\nIf you get a Build error stating the layout file could not be found you may need to manually deploy the Microsoft.Knowzy.UWP project by right-clicking on the Microsoft.Knowzy.UWP project and selecting \nDeploy\n. \nThen build the solution again.\n\n\n\n\n\n\nPress F5 and your UWP app will now be deployed and launch successfully. You should now be able to set breakpoints in the Microsoft.Knowzy.WPF source code.\n\n\n\n\n\n\nNote:\n There is a intermitent bug in the Desktop Bridge Debugging Project ** where it may hang when deploying a build. If this happens, use the Task Manager to kill Visual Studio and then reopen then solution. \nYou should then be able to build and run the app.\n\n\n\n\n\n\n\n\nSet a breakpoint at line 79 in the file ViewModels\\MainViewModel.cs in the Microsoft.Knowzy.WPF project. Restart the debugging session and it should break into the debugger at line 79. If you do not hit the breakpoint, \n\nClean\n and \nBuild\n your solution again.\n\n\n\n\n\n\nStop debugging and remove the comments we added in the previous task. Press F5 to start the app. You should get the following exception:\n\n\n\n\n\n\n\n\nFor some reason, our UWP app is unable to load the Project.json file and it appears that our app is looking for the file in the wrong directory. This is a common problem with newly converted Desktop Bridge apps.\nDepending on how the code is written, the app may be trying to load files from the wrong location. We will fix this in the next task.\n\n\nStep 4: Additional Debugging Settings\n\n\nIn order to be able to easily debug both both the WPF and UWP portions of our app, we need to specify a few more debugging settings.\n\n\n\n\nSelect \nOptions...\n from the \nDebug\n menu.\n\n\n\n\n\n\n\n\nClick on \nDebugging | General\n and turn off the \nEnable Just My Code\n options\n\n\n\n\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.UWP project and select \nProperties\n.\n\n\n\n\n\n\nSelect the \nBuild\n tab and turn off \nOptimize Code\n\n\n\n\n\n\n\n\n\n\nSelect the \nDebug\n tab and turn on \nDo not launch, but debug my code when it starts\n\n\n\n\n\n\nWe will now fix the products.json issue in the \nnext task\n.\n\n\nReferences\n\n\n\n\n\n\nRun, debug, and test a packaged desktop app (Desktop Bridge)\n\n\n\n\n\n\nDesktopBridge To UWP Samples\n\n\n\n\n\n\nPackage a .NET app using Visual Studio \n\n\n\n\n\n\nBridgeTour Workshop\n\n\n\n\n\n\nDevelopers Guide to the Desktop Bridge\n\n\n\n\n\n\ncontinue to \nnext task >>",
            "title": "212 Debugging"
        },
        {
            "location": "/stories/2/212_Debugging/#task-212-debugging-a-windows-desktop-bridge-app",
            "text": "This task will guide you through the process of debugging a Windows Desktop Bridge App using Visual Studio 2017.",
            "title": "Task 2.1.2 - Debugging a Windows Desktop Bridge App"
        },
        {
            "location": "/stories/2/212_Debugging/#prerequisites",
            "text": "Basic knowledge of C# development    Basic knowledge of client development with the .NET framework    Basic knowledge of Windows 10 and the Universal Windows Platform    A computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.    Visual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free  Visual Studio 2017 Community    The  Desktop Bridge Debugging Project template  installed into Visual Studio 2017    Complete the section on  Add Desktop Bridge Support using Visual Studio 2017    To get started, please open the  Microsoft.Knowzy.WPF.sln  in the  src\\Knowzy_Engineering_Win32App  folder with Visual Studio 2017.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/2/212_Debugging/#step-1-install-the-desktop-bridge-debugging-project-extension",
            "text": "If you do not have the Desktop Bridge Debugging Project extension installed into Visual Studio 2017, please complete the following steps:   Click on the  Tools  menu and select  Extensions and Updates...     Select  Online  and enter  Desktop Bridge Debugging Project  in the search field. Click  Download .      Close Visual Studio 2017 and the Desktop Bridge Debugging Project Extension will be installed.    Reopen your Desktop Bridge solution from the  Add Centennial Support using Visual Studio 2017  task.",
            "title": "Step 1: Install the Desktop Bridge Debugging Project Extension"
        },
        {
            "location": "/stories/2/212_Debugging/#step-2-add-the-desktop-bridge-debugging-project-to-the-solution",
            "text": "Right-click on the src folder in the Solution and select  Add | New Project...     Select the  Other Project Types | Desktop Bridge Debugging Project  project template.       Name the project Microsoft.Knowzy.Debug.    Make sure you save the project to the  Knowzy_Engineering_Win32App\\src  folder.    You solution should now contain the following projects.     Right-click on the Microsoft.Knowzy.Debug project and select  Build Dependencies | Project Dependencies...\"    Select the Microsoft.Knowzy.WPF and Microsoft.Knowzy.UWP projects and click  OK .",
            "title": "Step 2: Add the Desktop Bridge Debugging Project to the Solution"
        },
        {
            "location": "/stories/2/212_Debugging/#step-3-configure-the-desktop-bridge-debugging-project",
            "text": "Since we will be working a lot with the Microsoft.Knowzy.UWP project, set the Build Configuration and Platform to  Debug | x86   Clean  the solution by selecting  Clean Solution  from the  Build  menu.  Build  the x86 configuration of the solution. (Select  Build Solution  from the  Build  menu).  After the build completes, deploy the Microsoft.Knowzy.UWP project so its AppX folder is created. The next step needs the AppX folder.\n(Select  Deploy Solution  from the  Build  menu).  Right-click on the Microsoft.Knowzy.Debug project and select  Set as Startup Project .    Right-click on the Microsoft.Knowzy.Debug project and select  Properties .   For Debug builds use the following settings:    Package Layout: ..\\Microsoft.Knowzy.UWP\\bin\\x86\\Release    Select Uninstall and then re-install my package.    From the  Package Layout  field tab to the  Start Up Tile  field and select Microsoft.Knowzy.WPF.    Notice that we are specifying the path to the  Release  build of the Microsoft.Knowzy.UWP project. This is a fix for the\nVisual 2017 C# UWP Desktop Bridge deployment bug we experienced in the previous task.     Save and Close the Properties windows.     Note:  The Properties window can be a little buggy in saving your settings so make sure they were saved. Most issues with debugging are caused by\nincorrect Debugging Project settings.    Note:  You will need to add the correct Debugging Project Properties for x86 Release and x64 Debug and Release configurations if you want to build them.      Open the AppXPackageFileList.xml file in the Microsoft.Knowzy.Debug project      Modify the xml to the following: <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"14.0\"\n        xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n  <PropertyGroup>\n    <MyProjectOutputPath>..\\..\\bin\\Debug</MyProjectOutputPath>\n  </PropertyGroup>\n  <ItemGroup>\n    <LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.WPF.exe\">\n      <PackagePath>$(PackageLayout)\\desktop\\Microsoft.Knowzy.WPF.exe</PackagePath>\n    </LayoutFile>\n  </ItemGroup>\n</Project>    This XML describes to the DesktopBridge Debugging project the location of the Microsoft.Knowzy.WPF.exe after it is built. It will use it when the project is launched and copy it to the correct location in the AppX package.\nThis will allow for any changes to the Microsoft.Knowzy.WPF project code to be included in the debugging session. The need for the Desktop Bridge Debugging project will most likely change in future updates to Visual Studio 2017.    Save your changes.     Now it is time to  Clean  the solution and then  Build  the Solution.    If you get a Build error stating the layout file could not be found you may need to manually deploy the Microsoft.Knowzy.UWP project by right-clicking on the Microsoft.Knowzy.UWP project and selecting  Deploy . \nThen build the solution again.    Press F5 and your UWP app will now be deployed and launch successfully. You should now be able to set breakpoints in the Microsoft.Knowzy.WPF source code.    Note:  There is a intermitent bug in the Desktop Bridge Debugging Project ** where it may hang when deploying a build. If this happens, use the Task Manager to kill Visual Studio and then reopen then solution. \nYou should then be able to build and run the app.     Set a breakpoint at line 79 in the file ViewModels\\MainViewModel.cs in the Microsoft.Knowzy.WPF project. Restart the debugging session and it should break into the debugger at line 79. If you do not hit the breakpoint,  Clean  and  Build  your solution again.    Stop debugging and remove the comments we added in the previous task. Press F5 to start the app. You should get the following exception:     For some reason, our UWP app is unable to load the Project.json file and it appears that our app is looking for the file in the wrong directory. This is a common problem with newly converted Desktop Bridge apps.\nDepending on how the code is written, the app may be trying to load files from the wrong location. We will fix this in the next task.  Step 4: Additional Debugging Settings  In order to be able to easily debug both both the WPF and UWP portions of our app, we need to specify a few more debugging settings.   Select  Options...  from the  Debug  menu.     Click on  Debugging | General  and turn off the  Enable Just My Code  options      Right-click on the Microsoft.Knowzy.UWP project and select  Properties .    Select the  Build  tab and turn off  Optimize Code      Select the  Debug  tab and turn on  Do not launch, but debug my code when it starts    We will now fix the products.json issue in the  next task .",
            "title": "Step 3: Configure the Desktop Bridge Debugging Project"
        },
        {
            "location": "/stories/2/212_Debugging/#references",
            "text": "Run, debug, and test a packaged desktop app (Desktop Bridge)    DesktopBridge To UWP Samples    Package a .NET app using Visual Studio     BridgeTour Workshop    Developers Guide to the Desktop Bridge",
            "title": "References"
        },
        {
            "location": "/stories/2/212_Debugging/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/2/213_AddUwp/",
            "text": "Task 2.1.3 - Adding Windows 10 UWP APIs to your Desktop Bridge App\n\n\nThis task will guide you through the process of adding Windows 10 UWP APIs to your Desktop Bridge app. \n\n\nPrerequisites\n\n\n\n\n\n\nBasic knowledge of C# development\n\n\n\n\n\n\nBasic knowledge of client development with the .NET framework\n\n\n\n\n\n\nBasic knowledge of Windows 10 and the Universal Windows Platform\n\n\n\n\n\n\nA computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.\n\n\n\n\n\n\nVisual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free \nVisual Studio 2017 Community\n\n\n\n\n\n\nComplete the section on \nDebugging a Windows Desktop Bridge App\n\n\n\n\n\n\nTo get started, please open the \nMicrosoft.Knowzy.WPF.sln\n in the \nsrc\\Knowzy_Engineering_Win32App\n folder with Visual Studio 2017.\n\n\nTask\n\n\nIn this task we will do the following:\n\n\n\n\n\n\nConfigure our Desktop Bridge projects to be able to use Windows 10 UWP APIs.\n\n\n\n\n\n\nAdd NuGet packages to our project that will make it easier to use the Windows 10 UWP APIs\n\n\n\n\n\n\nFix the issue from the previous tasks where the Desktop Bridge app was not able to load the Product.json file when running as a UWP app.\n\n\n\n\n\n\nIn the previous tasks we discovered that our Desktop Bridge version of the Knowzy app cannot find the required file Products.json. The UWP version is looking for Products.json in the location expected by the \nWPF version. We need to correct this code so that when the UWP version of Knowzy is running it will look for the file in the correct location.\n\n\n\n\n\n\nSearching the code for Products.json we find it in a file called Config.json. \n\n\n{\n\"JsonFilePath\": \"Products.json\",\n\"DataSourceUrl\": \"http://\"\n}\n\n\n\n\n\n\n\nSearching for JsonFilePath, we find it in src\\Microsoft.KnowzyJsonDataProvider\\JsonDataProvider.cs\n\n\npublic Product[] GetData()\n{\n    var jsonFilePath = _configuration.Configuration.JsonFilePath;\n    return _jsonHelper.Deserialize<Product[]>(_fileHelper.ReadTextFile(jsonFilePath));\n}\n\n\n\n\n\n\n\nSetting a breakpoint around line 40 of JsonDataProvider.cs and stepping through the code we eventually find that ReadTextFile is looking for the Products.json file in the installed directory of the app.\n\n\n\n\n\n\nWhen we created the Desktop Bridge version of Knowzy we copied all of the WPF Knowzy binaries to the desktop folder of the Desktop Bridge app. \nAfter a build and deployment of the Knowzy app, we will find the Products.json file in the directory\n\n\nsrc\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX\\desktop\n\n\n\n\nSo an easy fix would be to try something like:\n\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if(IsRunningAsUwp())\n    {\n        jsonFilePath = \"desktop\\\\\" + _configuration.Configuration.JsonFilePath;\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize<Product[]>(_fileHelper.ReadTextFile(jsonFilePath));\n}\n\n\n\nI'll save you some time and tell you that this won't work either. \n\n\n\n\nWe actually need to do something like this:\n\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if(IsRunningAsUwp())\n    {\n        jsonFilePath = Path.Combine(GetUWPAppDir(),\"desktop\", _configuration.Configuration.JsonFilePath);\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize<Product[]>(_fileHelper.ReadTextFile(jsonFilePath));\n}\n\n\n\nWe are going to need to add at least 2 UWP methods to our DeskTop Bridge version of Knowzy in order to be able to load the Products.json file.\n\n\n\n\n\n\nA method to detect if we are running the UWP version\n\n\n\n\n\n\nA method that returns the directory of the UWP application\n\n\n\n\n\n\nStep 1: Adding UWP support to the Knowzy App\n\n\nWe can add UWP APIs to our Knowzy app at any location we need the UWP code. However, it will be easier if we create a set of UWP helper classes and place then all in a single C# library. \n\n\nSince all of the other dependencies in the Knowzy WPF solution are Windows Classic Desktop C# Class Libraries, we will add a new C# Class library called Microsoft.Knowzy.UwpHelpers.\n\n\n\n\n\n\nRight-click on the src folder in the solution and select \nAdd | New Project...\n\n\n\n\n\n\nSelect the \nVisual C# | Windows Classic Desktop | Class Library\n project template.\n\n\n\n\n\n\nName the library Microsoft.Knowzy.UwpHelpers. Make sure you are saving the project to the \nsrc\n directory.\n\n\n\n\n\n\n\n\nThere exists a convenient NuGet package called \nUwpDesktop\n that makes it easy for you call into UWP APIs \nfrom Desktop and Centennial apps (WPF, WinForms, etc.) Let's add this NuGet package to our Microsoft.Knowzy.UwpHelpers project.\n\n\n\n\nRight-click on the Microsoft.Knowzy.UwpHelpers project and select \nManage NuGet Packages...\n\n\n\n\n\n\n\n\nClick on \nBrowse\n, enter UwpDesktop in the search field and then click on  \nInstall\n\n\n\n\n\n\n\n\n\n\nNote:\n Every time you add a NuGet package to a Desktop Bridge project you should probably rebuild the solution so the newly added NuGet package DLLs are correctly added to the UWP project.\nIf you get a DLL not found exception when running your app, it may be because the AppX is missing the newly added DLL.\n\n\n\n\n\n\nAdd a new C# class to the Microsoft.Knowzy.UwpHelpers . Name the file ExecutionMode.cs.\n\n\n\n\n\n\nAdd the following code to ExecutionMode.cs. This code detects if the app is running as a UWP app.\n\n\nusing System;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing Windows.System.Profile;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class ExecutionMode\n    {\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        static extern int GetCurrentPackageFullName(ref int packageFullNameLength, ref StringBuilder packageFullName);\n\n        public static bool IsRunningAsUwp()\n        {\n            if (isWindows7OrLower())\n            {\n                return false;\n            }\n            else\n            {\n                StringBuilder sb = new StringBuilder(1024);\n                int length = 0;\n                int result = GetCurrentPackageFullName(ref length, ref sb);\n\n                return result != 15700;\n            }\n        }\n\n        internal static bool isWindows7OrLower()\n        {\n            int versionMajor = Environment.OSVersion.Version.Major;\n            int versionMinor = Environment.OSVersion.Version.Minor;\n            double version = versionMajor + (double)versionMinor / 10;\n            return version <= 6.1;\n        }\n    }\n}\n\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.JsonDataProvider project, select \nAdd | Reference...\n and a reference to the Microsoft.Knowzy.UwpHelpers project.\n\n\n\n\n\n\nWe can now modify src\\Microsoft.KnowzyJsonDataProvider\\JsonDataProvider.cs as follows:\n\n\nusing Microsoft.Knowzy.UwpHelpers;\nusing System;\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        jsonFilePath = \"desktop\\\\\" + _configuration.Configuration.JsonFilePath;\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize<Product[]>(_fileHelper.ReadTextFile(jsonFilePath));\n}\n\n\n\n\n\n\n\nBuild your solution and then set a break point at the following line of JsonDataProvider.cs (around line 40). \n\n\nif (ExecutionMode.IsRunningAsUwp())\n\n\n\n\n\n\n\nPress F5 to launch your app and...\n\n\nexecution does not stop at the breakpoint!\n\n\n\n\n\n\nThe build did not pick up our changes to Microsoft.Knowzy.JsonDataProvider. (Or if you rebuilt the entire solution, the changes did make it into the build).\nIn order to prevent having to do complete rebuild of our solution every time we change some code, we need to tell the DesktopBridge Debugging Project (Microsoft.Knowzy.Debug) which DLL's to copy to the AppX.\nUnfortunately, the current version of Visual Studio 2017 is not able to correctly handle code changes Desktop Bridge dependencies.\n\n\nSince we will be modifying the Microsoft.Knowzy.JsonDataProvider and Microsoft.Knowzy.UwpHelpers projects, let's add them to AppXPackageFileList.xml in the Microsoft.Knowzy.Debug project.\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"14.0\"\n        xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n<PropertyGroup>\n    <MyProjectOutputPath>..\\..\\bin\\Debug</MyProjectOutputPath>\n</PropertyGroup>\n<ItemGroup>\n    <LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.WPF.exe\">\n    <PackagePath>$(PackageLayout)\\desktop\\Microsoft.Knowzy.WPF.exe</PackagePath>\n    </LayoutFile>\n    <LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.JsonDataProvider.dll\">\n    <PackagePath>$(PackageLayout)\\desktop\\Microsoft.Knowzy.JsonDataProvider.dll</PackagePath>\n    </LayoutFile>\n    <LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.UwpHelpers.dll\">\n    <PackagePath>$(PackageLayout)\\desktop\\Microsoft.Knowzy.UwpHelpers.dll</PackagePath>\n    </LayoutFile>\n</ItemGroup>\n</Project>\n\n\n\nNow every time you make a code change to Microsoft.Knowzy.JsonDataProvider or Microsoft.Knowzy.UwpHelpers, the changes will be part of the build.\n\n\nPress F5 again and now you should be able to hit the breakpoint in JsonDataProvider.cs.\n\n\nStep 2: Adding UWP support to detect the AppX Installation Folder\n\n\nWe are now going to start adding Windows 10 UWP APIs to our app in order to find the AppX folder's install location and in later tasks to add new Windows 10 features to our app. \n\n\n\n\n\n\nAdd a new C# class to theMicrosoft.Knowzy.UwpHelpers project. Name the file AppFolders.cs.\n\n\n\n\n\n\nAdd the following code to AppFolders.cs. This code uses methods from the Windows 10 UWP API\n\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class AppFolders\n    {\n        public static string Current\n        {\n            get\n            {\n                string path = null;\n                if (ExecutionMode.IsRunningAsUwp())\n                {\n                    path = GetSafeAppxFolder();\n                }\n                return path;\n            }\n        }\n\n        internal static string GetSafeAppxFolder()\n        {\n            try\n            {\n                return Windows.ApplicationModel.Package.Current.InstalledLocation.Path;\n            }\n            catch (Exception ex)\n            {\n\n                System.Diagnostics.Debug.WriteLine(ex.Message);\n            }\n            return null;\n        }\n    }\n}\n\n\n\n\n\n\n\nThis code uses the Package class in Windows.ApplicationModel.Package to determine the installed location of the UWP AppX folder.\n\n\n\n\nWe can now modify JsonDataProvider.cs as follows:\nusing System.IO;\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        jsonFilePath = Path.Combine(AppFolders.Current, \"desktop\", _configuration.Configuration.JsonFilePath);\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize<Product[]>(_fileHelper.ReadTextFile(jsonFilePath));\n}\n\n\n\n\n\n\n\nPress F5 to run the Microsoft.Knowzy.Debug project. Finally our Knowzy UWP app can load the Products.json file from the correct location and display the information correctly.\n\n\n\n\nWe can also still run our original WPF version. The UWP additions are ignored by the WPF version. To try this out right-click on the Microsoft.Knowzy.WPF project and select \nDebug | Start new instance\n\n\n\n\nThe WPF app still continues to work as it was originally coded.\n\n\n\n\nWe will continue to add more Windows 10 UWP features to our app in the \nnext task\n.\n\n\nReferences\n\n\n\n\n\n\nPackage Class\n\n\n\n\n\n\nDesktop Bridge \u2013 Identify the application\u2019s context\n\n\n\n\n\n\nAnnouncing \u201cUWPDesktop\u201d NuGet Package Version 14393\n\n\n\n\n\n\nUWP for Desktop NuGet Package\n\n\n\n\n\n\nUWP for Desktop\n\n\n\n\n\n\nRun, debug, and test a packaged desktop app (Desktop Bridge)\n\n\n\n\n\n\nDesktopBridge To UWP Samples\n\n\n\n\n\n\nPackage a .NET app using Visual Studio \n\n\n\n\n\n\nBridgeTour Workshop\n\n\n\n\n\n\nDevelopers Guide to the Desktop Bridge\n\n\n\n\n\n\ncontinue to \nnext task >>",
            "title": "213 AddUwp"
        },
        {
            "location": "/stories/2/213_AddUwp/#task-213-adding-windows-10-uwp-apis-to-your-desktop-bridge-app",
            "text": "This task will guide you through the process of adding Windows 10 UWP APIs to your Desktop Bridge app.",
            "title": "Task 2.1.3 - Adding Windows 10 UWP APIs to your Desktop Bridge App"
        },
        {
            "location": "/stories/2/213_AddUwp/#prerequisites",
            "text": "Basic knowledge of C# development    Basic knowledge of client development with the .NET framework    Basic knowledge of Windows 10 and the Universal Windows Platform    A computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.    Visual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free  Visual Studio 2017 Community    Complete the section on  Debugging a Windows Desktop Bridge App    To get started, please open the  Microsoft.Knowzy.WPF.sln  in the  src\\Knowzy_Engineering_Win32App  folder with Visual Studio 2017.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/2/213_AddUwp/#task",
            "text": "In this task we will do the following:    Configure our Desktop Bridge projects to be able to use Windows 10 UWP APIs.    Add NuGet packages to our project that will make it easier to use the Windows 10 UWP APIs    Fix the issue from the previous tasks where the Desktop Bridge app was not able to load the Product.json file when running as a UWP app.    In the previous tasks we discovered that our Desktop Bridge version of the Knowzy app cannot find the required file Products.json. The UWP version is looking for Products.json in the location expected by the \nWPF version. We need to correct this code so that when the UWP version of Knowzy is running it will look for the file in the correct location.    Searching the code for Products.json we find it in a file called Config.json.   {\n\"JsonFilePath\": \"Products.json\",\n\"DataSourceUrl\": \"http://\"\n}    Searching for JsonFilePath, we find it in src\\Microsoft.KnowzyJsonDataProvider\\JsonDataProvider.cs  public Product[] GetData()\n{\n    var jsonFilePath = _configuration.Configuration.JsonFilePath;\n    return _jsonHelper.Deserialize<Product[]>(_fileHelper.ReadTextFile(jsonFilePath));\n}    Setting a breakpoint around line 40 of JsonDataProvider.cs and stepping through the code we eventually find that ReadTextFile is looking for the Products.json file in the installed directory of the app.    When we created the Desktop Bridge version of Knowzy we copied all of the WPF Knowzy binaries to the desktop folder of the Desktop Bridge app. \nAfter a build and deployment of the Knowzy app, we will find the Products.json file in the directory  src\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX\\desktop   So an easy fix would be to try something like:  public Product[] GetData()\n{\n    String jsonFilePath;\n\n    if(IsRunningAsUwp())\n    {\n        jsonFilePath = \"desktop\\\\\" + _configuration.Configuration.JsonFilePath;\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize<Product[]>(_fileHelper.ReadTextFile(jsonFilePath));\n}  I'll save you some time and tell you that this won't work either.    We actually need to do something like this:  public Product[] GetData()\n{\n    String jsonFilePath;\n\n    if(IsRunningAsUwp())\n    {\n        jsonFilePath = Path.Combine(GetUWPAppDir(),\"desktop\", _configuration.Configuration.JsonFilePath);\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize<Product[]>(_fileHelper.ReadTextFile(jsonFilePath));\n}  We are going to need to add at least 2 UWP methods to our DeskTop Bridge version of Knowzy in order to be able to load the Products.json file.    A method to detect if we are running the UWP version    A method that returns the directory of the UWP application",
            "title": "Task"
        },
        {
            "location": "/stories/2/213_AddUwp/#step-1-adding-uwp-support-to-the-knowzy-app",
            "text": "We can add UWP APIs to our Knowzy app at any location we need the UWP code. However, it will be easier if we create a set of UWP helper classes and place then all in a single C# library.   Since all of the other dependencies in the Knowzy WPF solution are Windows Classic Desktop C# Class Libraries, we will add a new C# Class library called Microsoft.Knowzy.UwpHelpers.    Right-click on the src folder in the solution and select  Add | New Project...    Select the  Visual C# | Windows Classic Desktop | Class Library  project template.    Name the library Microsoft.Knowzy.UwpHelpers. Make sure you are saving the project to the  src  directory.     There exists a convenient NuGet package called  UwpDesktop  that makes it easy for you call into UWP APIs \nfrom Desktop and Centennial apps (WPF, WinForms, etc.) Let's add this NuGet package to our Microsoft.Knowzy.UwpHelpers project.   Right-click on the Microsoft.Knowzy.UwpHelpers project and select  Manage NuGet Packages...     Click on  Browse , enter UwpDesktop in the search field and then click on   Install      Note:  Every time you add a NuGet package to a Desktop Bridge project you should probably rebuild the solution so the newly added NuGet package DLLs are correctly added to the UWP project.\nIf you get a DLL not found exception when running your app, it may be because the AppX is missing the newly added DLL.    Add a new C# class to the Microsoft.Knowzy.UwpHelpers . Name the file ExecutionMode.cs.    Add the following code to ExecutionMode.cs. This code detects if the app is running as a UWP app.  using System;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing Windows.System.Profile;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class ExecutionMode\n    {\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        static extern int GetCurrentPackageFullName(ref int packageFullNameLength, ref StringBuilder packageFullName);\n\n        public static bool IsRunningAsUwp()\n        {\n            if (isWindows7OrLower())\n            {\n                return false;\n            }\n            else\n            {\n                StringBuilder sb = new StringBuilder(1024);\n                int length = 0;\n                int result = GetCurrentPackageFullName(ref length, ref sb);\n\n                return result != 15700;\n            }\n        }\n\n        internal static bool isWindows7OrLower()\n        {\n            int versionMajor = Environment.OSVersion.Version.Major;\n            int versionMinor = Environment.OSVersion.Version.Minor;\n            double version = versionMajor + (double)versionMinor / 10;\n            return version <= 6.1;\n        }\n    }\n}    Right-click on the Microsoft.Knowzy.JsonDataProvider project, select  Add | Reference...  and a reference to the Microsoft.Knowzy.UwpHelpers project.    We can now modify src\\Microsoft.KnowzyJsonDataProvider\\JsonDataProvider.cs as follows:  using Microsoft.Knowzy.UwpHelpers;\nusing System;\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        jsonFilePath = \"desktop\\\\\" + _configuration.Configuration.JsonFilePath;\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize<Product[]>(_fileHelper.ReadTextFile(jsonFilePath));\n}    Build your solution and then set a break point at the following line of JsonDataProvider.cs (around line 40).   if (ExecutionMode.IsRunningAsUwp())    Press F5 to launch your app and...  execution does not stop at the breakpoint!    The build did not pick up our changes to Microsoft.Knowzy.JsonDataProvider. (Or if you rebuilt the entire solution, the changes did make it into the build).\nIn order to prevent having to do complete rebuild of our solution every time we change some code, we need to tell the DesktopBridge Debugging Project (Microsoft.Knowzy.Debug) which DLL's to copy to the AppX.\nUnfortunately, the current version of Visual Studio 2017 is not able to correctly handle code changes Desktop Bridge dependencies.  Since we will be modifying the Microsoft.Knowzy.JsonDataProvider and Microsoft.Knowzy.UwpHelpers projects, let's add them to AppXPackageFileList.xml in the Microsoft.Knowzy.Debug project.  <?xml version=\"1.0\" encoding=\"utf-8\"?>\n<Project ToolsVersion=\"14.0\"\n        xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n<PropertyGroup>\n    <MyProjectOutputPath>..\\..\\bin\\Debug</MyProjectOutputPath>\n</PropertyGroup>\n<ItemGroup>\n    <LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.WPF.exe\">\n    <PackagePath>$(PackageLayout)\\desktop\\Microsoft.Knowzy.WPF.exe</PackagePath>\n    </LayoutFile>\n    <LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.JsonDataProvider.dll\">\n    <PackagePath>$(PackageLayout)\\desktop\\Microsoft.Knowzy.JsonDataProvider.dll</PackagePath>\n    </LayoutFile>\n    <LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.UwpHelpers.dll\">\n    <PackagePath>$(PackageLayout)\\desktop\\Microsoft.Knowzy.UwpHelpers.dll</PackagePath>\n    </LayoutFile>\n</ItemGroup>\n</Project>  Now every time you make a code change to Microsoft.Knowzy.JsonDataProvider or Microsoft.Knowzy.UwpHelpers, the changes will be part of the build.  Press F5 again and now you should be able to hit the breakpoint in JsonDataProvider.cs.",
            "title": "Step 1: Adding UWP support to the Knowzy App"
        },
        {
            "location": "/stories/2/213_AddUwp/#step-2-adding-uwp-support-to-detect-the-appx-installation-folder",
            "text": "We are now going to start adding Windows 10 UWP APIs to our app in order to find the AppX folder's install location and in later tasks to add new Windows 10 features to our app.     Add a new C# class to theMicrosoft.Knowzy.UwpHelpers project. Name the file AppFolders.cs.    Add the following code to AppFolders.cs. This code uses methods from the Windows 10 UWP API  namespace Microsoft.Knowzy.UwpHelpers\n{\n    public class AppFolders\n    {\n        public static string Current\n        {\n            get\n            {\n                string path = null;\n                if (ExecutionMode.IsRunningAsUwp())\n                {\n                    path = GetSafeAppxFolder();\n                }\n                return path;\n            }\n        }\n\n        internal static string GetSafeAppxFolder()\n        {\n            try\n            {\n                return Windows.ApplicationModel.Package.Current.InstalledLocation.Path;\n            }\n            catch (Exception ex)\n            {\n\n                System.Diagnostics.Debug.WriteLine(ex.Message);\n            }\n            return null;\n        }\n    }\n}    This code uses the Package class in Windows.ApplicationModel.Package to determine the installed location of the UWP AppX folder.   We can now modify JsonDataProvider.cs as follows: using System.IO;\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        jsonFilePath = Path.Combine(AppFolders.Current, \"desktop\", _configuration.Configuration.JsonFilePath);\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize<Product[]>(_fileHelper.ReadTextFile(jsonFilePath));\n}    Press F5 to run the Microsoft.Knowzy.Debug project. Finally our Knowzy UWP app can load the Products.json file from the correct location and display the information correctly.   We can also still run our original WPF version. The UWP additions are ignored by the WPF version. To try this out right-click on the Microsoft.Knowzy.WPF project and select  Debug | Start new instance   The WPF app still continues to work as it was originally coded.   We will continue to add more Windows 10 UWP features to our app in the  next task .",
            "title": "Step 2: Adding UWP support to detect the AppX Installation Folder"
        },
        {
            "location": "/stories/2/213_AddUwp/#references",
            "text": "Package Class    Desktop Bridge \u2013 Identify the application\u2019s context    Announcing \u201cUWPDesktop\u201d NuGet Package Version 14393    UWP for Desktop NuGet Package    UWP for Desktop    Run, debug, and test a packaged desktop app (Desktop Bridge)    DesktopBridge To UWP Samples    Package a .NET app using Visual Studio     BridgeTour Workshop    Developers Guide to the Desktop Bridge",
            "title": "References"
        },
        {
            "location": "/stories/2/213_AddUwp/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/2/214_WindowsHello/",
            "text": "Task 2.1.4 - Integrate Windows Hello Authentication\n\n\nThis task will guide you through the process of adding the Windows Hello UWP API to your Win32 Desktop app using Visual Studio 2017. \nWe will also add support for presenting Windows 10 UWP Toast notifications to the user. \n\n\nWhat is Windows Hello?\n\n\nWindows Hello\n is the name Microsoft has given to the new biometric sign-in system built into Windows 10. Because it is built directly into the operating system, Windows Hello allows face or fingerprint identification to unlock users\u2019 devices. Authentication happens when the user supplies his or her unique biometric identifier to access the device-specific credentials, which means that an attacker who steals the device can\u2019t log on to it unless that attacker has the PIN. The Windows secure credential store protects biometric data on the device. By using Windows Hello to unlock a device, the authorized user gains access to all of his or her Windows experience, apps, data, websites, and services.\nThe Windows Hello authenticator is known as a Hello. A Hello is unique to the combination of an individual device and a specific user. It does not roam across devices, is not shared with a server or calling app, and cannot easily be extracted from a device. If multiple users share a device, each user needs to set up his or her own account. Every account gets a unique Hello for that device. You can think of a Hello as a token you can use to unlock (or release) a stored credential. The Hello itself does not authenticate you to an app or service, but it releases credentials that can. In other words, the Hello is not a user credential but it is a second factor for the authenticating process.\n\n\nWindows Hello is shipping as part of the Windows 10 operating system and developers can implement this technology to protect their Universal Windows Platform (UWP) apps and backend services. \n\n\nPrerequisites\n\n\n\n\n\n\nBasic knowledge of C# development\n\n\n\n\n\n\nBasic knowledge of client development with the .NET framework\n\n\n\n\n\n\nBasic knowledge of Windows 10 and the Universal Windows Platform\n\n\n\n\n\n\nA computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.\n\n\n\n\n\n\nVisual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free \nVisual Studio 2017 Community\n\n\n\n\n\n\nComplete the section on \nAdding Windows 10 UWP APIs to your Desktop Bridge App\n\n\n\n\n\n\nTask\n\n\nWe will use the Desktop Bridge Knowzy application which was created in the previous tasks as a starting point.\nTo get started, please open the \nMicrosoft.Knowzy.WPF.sln\n in the \nsrc\\Knowzy_Engineering_Win32App\n folder with Visual Studio 2017.\n\n\n\n\nNote: If you are starting with this from the \n2.1.4\n branch, you will need to do the following:\n\n\n\n\n\n\nSet the Build configuration to \nDebug | x86\n\n\n\n\n\n\n\n\nSelect \nOptions\n from the \nDebug\n menu, From the \nDebugging | General\n Tab,  disable the \nEnable Just My Code\n option.\n\n\n\n\n\n\nVerify these settings before you continue with this task.\n\n\nStep 1: Add a New UWP Helper Class for Windows Hello\n\n\nFollowing the techniques presented in the previous task, we are going to add the Windows 10 UWP code for the Windows Hello API and Toast notifications as helper classes.\nThese helper classes can be accessed by the Knowzy app when it is running as a Desktop Bridge UWP app.\n\n\n\n\n\n\nAdd a new C# class to the Microsoft.Knowzy.UwpHelpers project. Name the file WindowsHello.cs.\n\n\n\n\n\n\nAdd the following code to WindowsHello.cs. This code uses methods from the Windows 10 UWP API\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Windows.Security.Credentials;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class WindowsHello\n    {\n        public static async Task<bool> Login()\n        {\n            var result = await KeyCredentialManager.IsSupportedAsync();\n            String message;\n\n            if (result)\n            {\n                var authenticationResult = await KeyCredentialManager.RequestCreateAsync(\"login\", KeyCredentialCreationOption.ReplaceExisting);\n                if (authenticationResult.Status == KeyCredentialStatus.Success)\n                {\n                    message = \"User is logged in\";\n                }\n                else\n                {\n                    message = \"Login error: \" + authenticationResult.Status;\n                }\n            }\n            else\n            {\n                message = \"Windows Hello is not enabled for this device.\";\n            }\n\n            String imagePath = Windows.ApplicationModel.Package.Current.InstalledLocation.Path;\n            String xml = \"<toast><visual><binding template='ToastGeneric'><text hint-maxLines='1'>\" + message + \"</text></binding></visual></toast>\";\n\n            Toast.CreateToast(xml);\n\n            return result;\n        }\n    }\n}\n\n\n\n\n\n\n\nThis is only a starting point for Windows Hello support but it is sufficient to demonstrate how to add Windows 10 UWP APIs to your Desktop Bridge App. You will have the opportunity to complete coding\na Windows Hello login in a later task.\n\n\nStep 2: Add a New UWP Helper Class for Toast Notifications\n\n\nThe previous code example for Windows Hello uses a \nToast\n notification to indicated to the user\nif they are logged in. We need to add a UWP Helper class for Toasts.\n\n\n\n\n\n\nAdd a new C# class to the Microsoft.Knowzy.UwpHelpers project. Name the file Toast.cs.\n\n\n\n\n\n\nAdd the following code to Toast.cs. This code uses methods from the Windows 10 UWP API\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Windows.Data.Xml.Dom;\nusing Windows.UI.Notifications;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class Toast\n    {\n        static ToastNotification toast = null;\n        static ToastNotifier notifier = null;\n\n        public static void CreateToast(String xml)\n        {\n            if (!ExecutionMode.IsRunningAsUwp())\n            {\n                return;\n            }\n\n            try\n            {\n                if (notifier == null)\n                {\n                    notifier = ToastNotificationManager.CreateToastNotifier();\n                }\n                else\n                {\n                    notifier.Hide(toast);\n                }\n                XmlDocument toastXml = new XmlDocument();\n                toastXml.LoadXml(xml);\n\n                toast = new ToastNotification(toastXml);\n                notifier.Show(toast);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine(\"CreateToast Error:\" + ex.Message);\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\nStep 3: Add a Reference to Microsoft.Knowzy.UwpHelpers\n\n\n\n\nRight-click on the Microsoft.Knowzy.WPF project and select \nAdd | Reference...\n and select the Microsoft.Knowzy.UwpHelpers project. Click \nOK\n.\n\n\n\n\nStep 4: Add Login Code to the WPF App\n\n\nWhen the Login menu item in clicked in the UI of the Knowzy app, a message to open the Login dialog is sent to the  Handle(OpenLoginMessage message) method in\nMicrosoft.Knowzy.WPF\\ViewModels\\ShellViewModel.cs.\n\n\n\n\n\n\n\n\nOpen the file Microsoft.Knowzy.WPF\\ViewModels\\ShellViewModel.cs and find the Handle(OpenLoginMessage message) method near line 78.\n\n\n\n\n\n\nModify the Handle(OpenLoginMessage message) as follows:\n\n\nusing Microsoft.Knowzy.UwpHelpers;\n\npublic async void Handle(OpenLoginMessage message)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        await WindowsHello.Login();\n    }\n    else\n    {\n        _windowManager.ShowDialog(_loginViewModel);\n    }\n}\n\n\n\n\n\n\n\nBuild and run the solution (with Windows.Knowzy.Debug as the startup application)\n\n\n\n\n\n\nClick on the Login Menu item. \n\n\n\n\n\n\nIf your computer is capable of running the Windows Hello Login you will be presented with the Windows Hello Login interface.\n\n\n\n\n\n\nIf your computer is not capable of running the Windows Hello Login, a Toast will appear in the lower left corner of your screen.\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRun just the WPF version (right-click on the Microsoft.Knowzy.WPF project and select Debug | Start new instance). Clicking on the Login button will show:\n\n\n\n\n\n\nPlease note that this is not a complete implementation of Windows Hello login. For more information, please go \nhere\n.\n\n\nWe will continue to add more Windows 10 UWP features to our app in the \nnext task\n.\n\n\nReferences\n\n\n\n\n\n\nWindows Hello\n\n\n\n\n\n\nTiles, badges, and notifications for UWP apps\n\n\n\n\n\n\nAdaptive and interactive toast notifications\n\n\n\n\n\n\ncontinue to \nnext task >>",
            "title": "214 WindowsHello"
        },
        {
            "location": "/stories/2/214_WindowsHello/#task-214-integrate-windows-hello-authentication",
            "text": "This task will guide you through the process of adding the Windows Hello UWP API to your Win32 Desktop app using Visual Studio 2017. \nWe will also add support for presenting Windows 10 UWP Toast notifications to the user.",
            "title": "Task 2.1.4 - Integrate Windows Hello Authentication"
        },
        {
            "location": "/stories/2/214_WindowsHello/#what-is-windows-hello",
            "text": "Windows Hello  is the name Microsoft has given to the new biometric sign-in system built into Windows 10. Because it is built directly into the operating system, Windows Hello allows face or fingerprint identification to unlock users\u2019 devices. Authentication happens when the user supplies his or her unique biometric identifier to access the device-specific credentials, which means that an attacker who steals the device can\u2019t log on to it unless that attacker has the PIN. The Windows secure credential store protects biometric data on the device. By using Windows Hello to unlock a device, the authorized user gains access to all of his or her Windows experience, apps, data, websites, and services.\nThe Windows Hello authenticator is known as a Hello. A Hello is unique to the combination of an individual device and a specific user. It does not roam across devices, is not shared with a server or calling app, and cannot easily be extracted from a device. If multiple users share a device, each user needs to set up his or her own account. Every account gets a unique Hello for that device. You can think of a Hello as a token you can use to unlock (or release) a stored credential. The Hello itself does not authenticate you to an app or service, but it releases credentials that can. In other words, the Hello is not a user credential but it is a second factor for the authenticating process.  Windows Hello is shipping as part of the Windows 10 operating system and developers can implement this technology to protect their Universal Windows Platform (UWP) apps and backend services.",
            "title": "What is Windows Hello?"
        },
        {
            "location": "/stories/2/214_WindowsHello/#prerequisites",
            "text": "Basic knowledge of C# development    Basic knowledge of client development with the .NET framework    Basic knowledge of Windows 10 and the Universal Windows Platform    A computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.    Visual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free  Visual Studio 2017 Community    Complete the section on  Adding Windows 10 UWP APIs to your Desktop Bridge App",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/2/214_WindowsHello/#task",
            "text": "We will use the Desktop Bridge Knowzy application which was created in the previous tasks as a starting point.\nTo get started, please open the  Microsoft.Knowzy.WPF.sln  in the  src\\Knowzy_Engineering_Win32App  folder with Visual Studio 2017.   Note: If you are starting with this from the  2.1.4  branch, you will need to do the following:    Set the Build configuration to  Debug | x86     Select  Options  from the  Debug  menu, From the  Debugging | General  Tab,  disable the  Enable Just My Code  option.    Verify these settings before you continue with this task.",
            "title": "Task"
        },
        {
            "location": "/stories/2/214_WindowsHello/#step-1-add-a-new-uwp-helper-class-for-windows-hello",
            "text": "Following the techniques presented in the previous task, we are going to add the Windows 10 UWP code for the Windows Hello API and Toast notifications as helper classes.\nThese helper classes can be accessed by the Knowzy app when it is running as a Desktop Bridge UWP app.    Add a new C# class to the Microsoft.Knowzy.UwpHelpers project. Name the file WindowsHello.cs.    Add the following code to WindowsHello.cs. This code uses methods from the Windows 10 UWP API  using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Windows.Security.Credentials;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class WindowsHello\n    {\n        public static async Task<bool> Login()\n        {\n            var result = await KeyCredentialManager.IsSupportedAsync();\n            String message;\n\n            if (result)\n            {\n                var authenticationResult = await KeyCredentialManager.RequestCreateAsync(\"login\", KeyCredentialCreationOption.ReplaceExisting);\n                if (authenticationResult.Status == KeyCredentialStatus.Success)\n                {\n                    message = \"User is logged in\";\n                }\n                else\n                {\n                    message = \"Login error: \" + authenticationResult.Status;\n                }\n            }\n            else\n            {\n                message = \"Windows Hello is not enabled for this device.\";\n            }\n\n            String imagePath = Windows.ApplicationModel.Package.Current.InstalledLocation.Path;\n            String xml = \"<toast><visual><binding template='ToastGeneric'><text hint-maxLines='1'>\" + message + \"</text></binding></visual></toast>\";\n\n            Toast.CreateToast(xml);\n\n            return result;\n        }\n    }\n}    This is only a starting point for Windows Hello support but it is sufficient to demonstrate how to add Windows 10 UWP APIs to your Desktop Bridge App. You will have the opportunity to complete coding\na Windows Hello login in a later task.",
            "title": "Step 1: Add a New UWP Helper Class for Windows Hello"
        },
        {
            "location": "/stories/2/214_WindowsHello/#step-2-add-a-new-uwp-helper-class-for-toast-notifications",
            "text": "The previous code example for Windows Hello uses a  Toast  notification to indicated to the user\nif they are logged in. We need to add a UWP Helper class for Toasts.    Add a new C# class to the Microsoft.Knowzy.UwpHelpers project. Name the file Toast.cs.    Add the following code to Toast.cs. This code uses methods from the Windows 10 UWP API  using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Windows.Data.Xml.Dom;\nusing Windows.UI.Notifications;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class Toast\n    {\n        static ToastNotification toast = null;\n        static ToastNotifier notifier = null;\n\n        public static void CreateToast(String xml)\n        {\n            if (!ExecutionMode.IsRunningAsUwp())\n            {\n                return;\n            }\n\n            try\n            {\n                if (notifier == null)\n                {\n                    notifier = ToastNotificationManager.CreateToastNotifier();\n                }\n                else\n                {\n                    notifier.Hide(toast);\n                }\n                XmlDocument toastXml = new XmlDocument();\n                toastXml.LoadXml(xml);\n\n                toast = new ToastNotification(toastXml);\n                notifier.Show(toast);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine(\"CreateToast Error:\" + ex.Message);\n            }\n        }\n    }\n}",
            "title": "Step 2: Add a New UWP Helper Class for Toast Notifications"
        },
        {
            "location": "/stories/2/214_WindowsHello/#step-3-add-a-reference-to-microsoftknowzyuwphelpers",
            "text": "Right-click on the Microsoft.Knowzy.WPF project and select  Add | Reference...  and select the Microsoft.Knowzy.UwpHelpers project. Click  OK .",
            "title": "Step 3: Add a Reference to Microsoft.Knowzy.UwpHelpers"
        },
        {
            "location": "/stories/2/214_WindowsHello/#step-4-add-login-code-to-the-wpf-app",
            "text": "When the Login menu item in clicked in the UI of the Knowzy app, a message to open the Login dialog is sent to the  Handle(OpenLoginMessage message) method in\nMicrosoft.Knowzy.WPF\\ViewModels\\ShellViewModel.cs.     Open the file Microsoft.Knowzy.WPF\\ViewModels\\ShellViewModel.cs and find the Handle(OpenLoginMessage message) method near line 78.    Modify the Handle(OpenLoginMessage message) as follows:  using Microsoft.Knowzy.UwpHelpers;\n\npublic async void Handle(OpenLoginMessage message)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        await WindowsHello.Login();\n    }\n    else\n    {\n        _windowManager.ShowDialog(_loginViewModel);\n    }\n}    Build and run the solution (with Windows.Knowzy.Debug as the startup application)    Click on the Login Menu item.     If your computer is capable of running the Windows Hello Login you will be presented with the Windows Hello Login interface.    If your computer is not capable of running the Windows Hello Login, a Toast will appear in the lower left corner of your screen.        Run just the WPF version (right-click on the Microsoft.Knowzy.WPF project and select Debug | Start new instance). Clicking on the Login button will show:    Please note that this is not a complete implementation of Windows Hello login. For more information, please go  here .  We will continue to add more Windows 10 UWP features to our app in the  next task .",
            "title": "Step 4: Add Login Code to the WPF App"
        },
        {
            "location": "/stories/2/214_WindowsHello/#references",
            "text": "Windows Hello    Tiles, badges, and notifications for UWP apps    Adaptive and interactive toast notifications",
            "title": "References"
        },
        {
            "location": "/stories/2/214_WindowsHello/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/2/221_XAMLView/",
            "text": "Task 2.2.1 -  Create a new XAML view as part of app package\n\n\nThis task will guide you through the process of adding a Windows 10 UWP XAML UI to your Win32 Desktop Bridge app using Visual Studio 2017. \nWe will also add support for using Windows 10 UWP Protocols to communicate between the WPF exe and and UWP exe. \n\n\nPrerequisites\n\n\n\n\n\n\nBasic knowledge of C# development\n\n\n\n\n\n\nBasic knowledge of client development with the .NET framework\n\n\n\n\n\n\nBasic knowledge of Windows 10 and the Universal Windows Platform\n\n\n\n\n\n\nA computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.\n\n\n\n\n\n\nVisual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free \nVisual Studio 2017 Community\n\n\n\n\n\n\nCompleted the section on \nIntegrate Windows Hello Authentication\n\n\n\n\n\n\nMake sure the Microsoft.Knowzy.WPF.sln Build configuration to \nDebug | x86\n\n\n\n\n\n\n\n\nTask\n\n\nOur Desktop Bridge version of the Knowzy app actually consists of two different executables. The original WPF version (Microsoft.Knowzy.WPF.exe) and the UWP version (Microsoft.Knowzy.UWP.exe). \nMicrosoft.Knowzy.UWP.exe is located in src\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX.\n\n\n\n\nMicrosoft.Knowzy.WPF.exe is located in src\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX\\desktop\n\n\n\n\nThe Application element in the Package.appxmanifest in the Microsoft.Knowzy.UWP project specifies that Microsoft.Knowzy.WPF.exe is the app to be launched when the user starts the Desktop Bridge UWP version of Knowzy. \nThere is actually no mention of Microsoft.Knowzy.UWP.exe in the Package.appxmanifest and it currently will not run.\n\n\n<Applications>\n    <Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\">\n    </Application>\n</Applications>\n\n\n\nWe are now going to use the Microsoft.Knowzy.UWP.exe to display a UWP XAML UI page. We will launch Microsoft.Knowzy.UWP.exe by using \nURI activation\n.\n\n\nStep 1: Specify an Application Extension in the package manifest\n\n\nAs mentioned above, the Package.appxmanifest currently does not know anything about Microsoft.Knowzy.UWP.exe. We are going to add an Extension to the Application tag of the Package.appxmanifest.\n\n\n\n\n\n\nRight-click on the Package.appxmanifest file in the Microsoft.Knowzy.UWP project and select \nView Code\n*\n\n\n\n\n\n\nModify the Application section of the XML to add the following Extensions tag\n\n\n<Extensions>\n<uap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\">\n    <uap:Protocol Name=\"com.microsoft.knowzy.protocol.3d\" />\n</uap:Extension>\n</Extensions>\n\n\n\n\n\n\n\nYour Application section should now look something like this:\n\n\n<Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\">\n<uap:VisualElements\n    DisplayName=\"Microsoft.Knowzy.UWP\"\n    Square150x150Logo=\"Assets\\Square150x150Logo.png\"\n    Square44x44Logo=\"Assets\\Square44x44Logo.png\"\n    Description=\"Microsoft.Knowzy.UWP\"\n    BackgroundColor=\"transparent\">\n    <uap:DefaultTile Wide310x150Logo=\"Assets\\Wide310x150Logo.png\"/>\n    <uap:SplashScreen Image=\"Assets\\SplashScreen.png\" />\n</uap:VisualElements>\n<Extensions>\n    <uap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\">\n    <uap:Protocol Name=\"com.microsoft.knowzy.protocol.3d\" />\n    </uap:Extension>\n</Extensions>\n</Application>\n\n\n\n\n\n\n\nThe Microsoft.Knowzy.UWP app will now be registered as a handler for the com.microsoft.knowzy.protocol.3d Uniform Resource Identifier (URI) name.\n\n\n\n\nBuild and Deploy the Microsoft.Knowzy.UWP project to make sure your Package.appxmanifest file is valid. \n\n\n\n\nStep 2: Handle the activated event in Microsoft.Knowzy.UWP\n\n\nWhen another app sends the Knowzy app a protocol message using the com.microsoft.knowzy.protocol.3d URI, Microsoft.Knowzy.UWP.exe will be activated by the operationg system. \nWe need to add some code to Microsoft.Knowzy.UWP to handle the URI activation.\n\n\n\n\n\n\nOpen the file App.xaml.cs in the Microsoft.Knowzy.UWP project.\n\n\n\n\n\n\nAdd the following activation code at the bottom of the App class:\n\n\nprotected override void OnActivated(IActivatedEventArgs args)\n{\n    if (args.Kind == ActivationKind.Protocol)\n    {\n        ProtocolActivatedEventArgs eventArgs = args as ProtocolActivatedEventArgs;\n        // TODO: Handle URI activation\n        // The received URI is eventArgs.Uri.AbsoluteUri\n\n        Uri uri = eventArgs.Uri;\n        if (uri.Scheme == \"com.microsoft.knowzy.protocol.3d\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(MainPage), uri.Query);\n            Window.Current.Activate();\n        }\n    }\n}\n\n\n\n\n\n\n\nThis code will present the MainPage of the app if it receives the URI com.microsoft.knowzy.protocol.3d.\n\n\n\n\n\n\nOpen the file MainPage.xaml in the Microsoft.Knowzy.UWP project. Modify the XAML to add a WebView\n\n\n<Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n    <WebView Name=\"webView\" />\n</Grid>\n\n\n\n\n\n\n\nOpen the file MainPage.xaml.cs in the Microsoft.Knowzy.UWP project. Add the following method to the MainPage class:\n\n\nprotected override void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        WwwFormUrlDecoder decoder = new WwwFormUrlDecoder(args.Parameter.ToString());\n        try\n        {\n            var message = decoder.GetFirstValueByName(\"nose\");\n            webView.Source = new Uri(message);\n        }\n        catch(Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine(\"MainPage OnNavigatedTo Error: \"  + ex.Message);\n        }\n    }\n}\n\n\n\n\n\n\n\nStep 3: Add the Windows 10 UWP URI sending code to the WPF app\n\n\nNow that the Microsoft.Knowzy.UWP app knows how to handle a URI request, we are going to add code to the Microsoft.Knowzy.WPF project to make the URI request.\n\n\n\n\n\n\nAdd a new C# class to the Helpers folder of the Microsoft.Knowzy.UwpHelpers project. Name the file UriProtocol.cs.\n\n\n\n\n\n\nAdd the following method to the UriProtocol class. Make sure the class is public,\n\n\npublic class UriProtocol\n{\n    public static async Task<bool> SendUri(Uri uri)\n    {\n        // Note: DesktopBridge.Helpers NuGet package incorrectly warns that LaunchUriAsync is not supported in a Centennial App\n        bool result = await Windows.System.Launcher.LaunchUriAsync(uri);\n        return result;\n    }\n}\n\n\n\n\n\n\n\nIntellisense may complain that LaunchUriAsync is only available to UWP apps. You can ignore this warning.\n\n\nStep 4: Add the URI Code to the WPF App\n\n\nOur Knowzy app has an unused View menu item. We will use this to call the code to launch the UWP XAML UI using the Windows 10 UWP uri code we added to the Helpers.\n\n\n\n\n\n\n\n\nModify the XAML Microsoft.Knowzy.WPF\\Views\\MainView.xaml to add a Click event to the View MenuItem (around line 43)\n\n\n<MenuItem Header=\"{x:Static localization:Resources.View_Menu}\" Template=\"{DynamicResource MenuItemControlTemplate}\">\n    <MenuItem Header=\"{x:Static localization:Resources.ListView_Tab}\" Template=\"{StaticResource MenuItemBarControlTemplate}\" \n            cal:Message.Attach=\"ShowListView()\"/>\n    <MenuItem Header=\"Grid view\" Template=\"{StaticResource MenuItemBarControlTemplate}\"\n            cal:Message.Attach=\"ShowGridView()\"/>\n    <MenuItem Header=\"View 3D\" Template=\"{StaticResource MenuItemBarControlTemplate}\"\n            cal:Message.Attach=\"Show3DView()\"/>\n</MenuItem>\n\n\n\n\n\n\n\nAdd a Show3DView() method to Microsoft.Knowzy.WPF\\Models\\MainViewModel.cs\n\n\nusing Microsoft.Knowzy.UwpHelpers;\nusing System;\n\npublic async void Show3DView()\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        Uri uri = new Uri(\"com.microsoft.knowzy.protocol.3d://\" + \"message?nose=\" + \"https://www.remix3d.com/details/G009SXPQ5S3P\");\n        await UriProtocol.SendUri(uri);\n    }\n    else\n    {\n        MessageBox.Show(\"3D View not implemented in WPF version\", \"Microsoft.Knowzy.WPF\");\n    };\n}\n\n\n\n\n\n\n\nBuild and run the solution (with Windows.Knowzy.Debug as the startup application)\n\n\n\n\n\n\nSelect \nView 3D\n from the \nView\n menu. The Xaml ui of the Microsoft.Knowzy.UWP app will appear and display the 3D clown nose specified by the Uri parameters.\n\n\n\n\n\n\n\n\n\n\nIf you want to suggest to Windows 10 the size of the XAML UI Window, add the following code to the MainPage constructor in the file MainPage.xaml.cs in the Microsoft.Knowzy.UWP project\nusing Windows.UI.ViewManagement;\n\npublic MainPage()\n{\n    this.InitializeComponent();\n    ApplicationView.GetForCurrentView().TryResizeView(new Size(800, 800));\n}\n\n\n\n\n\n\n\nWe will continue to add more Windows 10 UWP features to our app in the \nnext task\n.\n\n\nReferences\n\n\n\n\nHandle URI activation\n\n\n\n\ncontinue to \nnext task >>",
            "title": "221 XAMLView"
        },
        {
            "location": "/stories/2/221_XAMLView/#task-221-create-a-new-xaml-view-as-part-of-app-package",
            "text": "This task will guide you through the process of adding a Windows 10 UWP XAML UI to your Win32 Desktop Bridge app using Visual Studio 2017. \nWe will also add support for using Windows 10 UWP Protocols to communicate between the WPF exe and and UWP exe.",
            "title": "Task 2.2.1 -  Create a new XAML view as part of app package"
        },
        {
            "location": "/stories/2/221_XAMLView/#prerequisites",
            "text": "Basic knowledge of C# development    Basic knowledge of client development with the .NET framework    Basic knowledge of Windows 10 and the Universal Windows Platform    A computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.    Visual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free  Visual Studio 2017 Community    Completed the section on  Integrate Windows Hello Authentication    Make sure the Microsoft.Knowzy.WPF.sln Build configuration to  Debug | x86",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/2/221_XAMLView/#task",
            "text": "Our Desktop Bridge version of the Knowzy app actually consists of two different executables. The original WPF version (Microsoft.Knowzy.WPF.exe) and the UWP version (Microsoft.Knowzy.UWP.exe). \nMicrosoft.Knowzy.UWP.exe is located in src\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX.   Microsoft.Knowzy.WPF.exe is located in src\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX\\desktop   The Application element in the Package.appxmanifest in the Microsoft.Knowzy.UWP project specifies that Microsoft.Knowzy.WPF.exe is the app to be launched when the user starts the Desktop Bridge UWP version of Knowzy. \nThere is actually no mention of Microsoft.Knowzy.UWP.exe in the Package.appxmanifest and it currently will not run.  <Applications>\n    <Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\">\n    </Application>\n</Applications>  We are now going to use the Microsoft.Knowzy.UWP.exe to display a UWP XAML UI page. We will launch Microsoft.Knowzy.UWP.exe by using  URI activation .",
            "title": "Task"
        },
        {
            "location": "/stories/2/221_XAMLView/#step-1-specify-an-application-extension-in-the-package-manifest",
            "text": "As mentioned above, the Package.appxmanifest currently does not know anything about Microsoft.Knowzy.UWP.exe. We are going to add an Extension to the Application tag of the Package.appxmanifest.    Right-click on the Package.appxmanifest file in the Microsoft.Knowzy.UWP project and select  View Code *    Modify the Application section of the XML to add the following Extensions tag  <Extensions>\n<uap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\">\n    <uap:Protocol Name=\"com.microsoft.knowzy.protocol.3d\" />\n</uap:Extension>\n</Extensions>    Your Application section should now look something like this:  <Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\">\n<uap:VisualElements\n    DisplayName=\"Microsoft.Knowzy.UWP\"\n    Square150x150Logo=\"Assets\\Square150x150Logo.png\"\n    Square44x44Logo=\"Assets\\Square44x44Logo.png\"\n    Description=\"Microsoft.Knowzy.UWP\"\n    BackgroundColor=\"transparent\">\n    <uap:DefaultTile Wide310x150Logo=\"Assets\\Wide310x150Logo.png\"/>\n    <uap:SplashScreen Image=\"Assets\\SplashScreen.png\" />\n</uap:VisualElements>\n<Extensions>\n    <uap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\">\n    <uap:Protocol Name=\"com.microsoft.knowzy.protocol.3d\" />\n    </uap:Extension>\n</Extensions>\n</Application>    The Microsoft.Knowzy.UWP app will now be registered as a handler for the com.microsoft.knowzy.protocol.3d Uniform Resource Identifier (URI) name.   Build and Deploy the Microsoft.Knowzy.UWP project to make sure your Package.appxmanifest file is valid.",
            "title": "Step 1: Specify an Application Extension in the package manifest"
        },
        {
            "location": "/stories/2/221_XAMLView/#step-2-handle-the-activated-event-in-microsoftknowzyuwp",
            "text": "When another app sends the Knowzy app a protocol message using the com.microsoft.knowzy.protocol.3d URI, Microsoft.Knowzy.UWP.exe will be activated by the operationg system. \nWe need to add some code to Microsoft.Knowzy.UWP to handle the URI activation.    Open the file App.xaml.cs in the Microsoft.Knowzy.UWP project.    Add the following activation code at the bottom of the App class:  protected override void OnActivated(IActivatedEventArgs args)\n{\n    if (args.Kind == ActivationKind.Protocol)\n    {\n        ProtocolActivatedEventArgs eventArgs = args as ProtocolActivatedEventArgs;\n        // TODO: Handle URI activation\n        // The received URI is eventArgs.Uri.AbsoluteUri\n\n        Uri uri = eventArgs.Uri;\n        if (uri.Scheme == \"com.microsoft.knowzy.protocol.3d\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(MainPage), uri.Query);\n            Window.Current.Activate();\n        }\n    }\n}    This code will present the MainPage of the app if it receives the URI com.microsoft.knowzy.protocol.3d.    Open the file MainPage.xaml in the Microsoft.Knowzy.UWP project. Modify the XAML to add a WebView  <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\">\n    <WebView Name=\"webView\" />\n</Grid>    Open the file MainPage.xaml.cs in the Microsoft.Knowzy.UWP project. Add the following method to the MainPage class:  protected override void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        WwwFormUrlDecoder decoder = new WwwFormUrlDecoder(args.Parameter.ToString());\n        try\n        {\n            var message = decoder.GetFirstValueByName(\"nose\");\n            webView.Source = new Uri(message);\n        }\n        catch(Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine(\"MainPage OnNavigatedTo Error: \"  + ex.Message);\n        }\n    }\n}",
            "title": "Step 2: Handle the activated event in Microsoft.Knowzy.UWP"
        },
        {
            "location": "/stories/2/221_XAMLView/#step-3-add-the-windows-10-uwp-uri-sending-code-to-the-wpf-app",
            "text": "Now that the Microsoft.Knowzy.UWP app knows how to handle a URI request, we are going to add code to the Microsoft.Knowzy.WPF project to make the URI request.    Add a new C# class to the Helpers folder of the Microsoft.Knowzy.UwpHelpers project. Name the file UriProtocol.cs.    Add the following method to the UriProtocol class. Make sure the class is public,  public class UriProtocol\n{\n    public static async Task<bool> SendUri(Uri uri)\n    {\n        // Note: DesktopBridge.Helpers NuGet package incorrectly warns that LaunchUriAsync is not supported in a Centennial App\n        bool result = await Windows.System.Launcher.LaunchUriAsync(uri);\n        return result;\n    }\n}    Intellisense may complain that LaunchUriAsync is only available to UWP apps. You can ignore this warning.",
            "title": "Step 3: Add the Windows 10 UWP URI sending code to the WPF app"
        },
        {
            "location": "/stories/2/221_XAMLView/#step-4-add-the-uri-code-to-the-wpf-app",
            "text": "Our Knowzy app has an unused View menu item. We will use this to call the code to launch the UWP XAML UI using the Windows 10 UWP uri code we added to the Helpers.     Modify the XAML Microsoft.Knowzy.WPF\\Views\\MainView.xaml to add a Click event to the View MenuItem (around line 43)  <MenuItem Header=\"{x:Static localization:Resources.View_Menu}\" Template=\"{DynamicResource MenuItemControlTemplate}\">\n    <MenuItem Header=\"{x:Static localization:Resources.ListView_Tab}\" Template=\"{StaticResource MenuItemBarControlTemplate}\" \n            cal:Message.Attach=\"ShowListView()\"/>\n    <MenuItem Header=\"Grid view\" Template=\"{StaticResource MenuItemBarControlTemplate}\"\n            cal:Message.Attach=\"ShowGridView()\"/>\n    <MenuItem Header=\"View 3D\" Template=\"{StaticResource MenuItemBarControlTemplate}\"\n            cal:Message.Attach=\"Show3DView()\"/>\n</MenuItem>    Add a Show3DView() method to Microsoft.Knowzy.WPF\\Models\\MainViewModel.cs  using Microsoft.Knowzy.UwpHelpers;\nusing System;\n\npublic async void Show3DView()\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        Uri uri = new Uri(\"com.microsoft.knowzy.protocol.3d://\" + \"message?nose=\" + \"https://www.remix3d.com/details/G009SXPQ5S3P\");\n        await UriProtocol.SendUri(uri);\n    }\n    else\n    {\n        MessageBox.Show(\"3D View not implemented in WPF version\", \"Microsoft.Knowzy.WPF\");\n    };\n}    Build and run the solution (with Windows.Knowzy.Debug as the startup application)    Select  View 3D  from the  View  menu. The Xaml ui of the Microsoft.Knowzy.UWP app will appear and display the 3D clown nose specified by the Uri parameters.      If you want to suggest to Windows 10 the size of the XAML UI Window, add the following code to the MainPage constructor in the file MainPage.xaml.cs in the Microsoft.Knowzy.UWP project using Windows.UI.ViewManagement;\n\npublic MainPage()\n{\n    this.InitializeComponent();\n    ApplicationView.GetForCurrentView().TryResizeView(new Size(800, 800));\n}    We will continue to add more Windows 10 UWP features to our app in the  next task .",
            "title": "Step 4: Add the URI Code to the WPF App"
        },
        {
            "location": "/stories/2/221_XAMLView/#references",
            "text": "Handle URI activation",
            "title": "References"
        },
        {
            "location": "/stories/2/221_XAMLView/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/2/222_Share/",
            "text": "Task 2.2.2 -  Add support for other apps to share images with the Knowzy App\n\n\nOur development department has the idea to allow Knowzy app users to share images from other Windows 10 applications with the Knowzy app. \nFor now, we just want you to implement the Windows 10 sharing code. To show that the image was shared with the Knowzy app, please display a toast\nwith the image.\n\n\nRequirements for this task:\n* Share an image from another Windows 10 App. The Knowzy app should appear as one of the options for Share Targets.\n\n\n\n\n\n\nDisplay a XAML UI for sharing with the Knowzy app.\n\n\n\n\n\n\nDisplay a Toast that displays the image after the sharing operation has completed.\n\n\n\n\n\n\nOur research has found a starting point for the sharing idea \nhere\n\nunder the \"Making your PC software a share target\" section.\n\n\nWe also found some \nsample code\n.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 2.2.1\n and all of it's prerequisites\n\n\n\n\nMake sure the Microsoft.Knowzy.WPF.sln Build configuration to \nDebug | x86\n\n\n\n\n\n\nTask\n\n\n\n\n\n\nYou will need to add a sharing extension to the Extension section of the Application tag in Package.appxmanifest in the Microsoft.Knowzy.UWP project to enable the app to be an image share target. \nYou also need to specify that you are a share target that supports Bitmap images.\n\n\n<uap:Extension Category=\"windows.shareTarget\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\">\n<uap:ShareTarget>\n    <uap:SupportedFileTypes>\n    <uap:SupportsAnyFileType />\n    </uap:SupportedFileTypes>\n    <uap:DataFormat>Bitmap</uap:DataFormat>\n</uap:ShareTarget>\n</uap:Extension>\n\n\n\n\n\n\n\nYou will need to add an OnShareTargetActivated event handler to App.xaml.cs in the Microsoft.Knowzy.UWP project. This handler will be called when a user attempts to share an image to the Knowzy app.\nIt should look something like:\n\n\nprotected override void OnShareTargetActivated(ShareTargetActivatedEventArgs e)\n{\n    Frame rootFrame = new Frame();\n    Window.Current.Content = rootFrame;\n    rootFrame.Navigate(typeof(SharePage), e.ShareOperation);\n    Window.Current.Activate();\n}\n\n\n\n\n\n\n\nYou will need to add a new XAML page to the Microsoft.Knowzy.UWP project. Right click on the project and select \nAdd | New Item...\n. Choose the \nBlank Page\n template and name it \nSharePage.xaml\n.\n\n\n\n\n\n\nYou will need to add the Sharing UI to the SharePage.xaml file. For now, use something like:\n\n\n<Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" Margin=\"12\">\n    <StackPanel>\n        <Button Content=\"Share to Microsoft.Knowzy.WPF\" Click=\"ShareButton_Click\"/>\n        <TextBlock x:Name=\"tbFileName\" />\n        <Image x:Name=\"img\"/>\n    </StackPanel>\n</Grid>\n\n\n\n\n\n\n\nIn the file SharePage.xaml.cs you will need to handle the OnNavigatedTo event. The NavigationEventArgs parameter will contain the shared image information. Display the shared image in the\nSharedPage UI. Pay attention to threading issues such as processing the image in a separate task. Also, you can only update the XAML UI image on the UI thread so you will need to use a dispacther to update the UI.\n\n\n// add the following using directives\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Windows.ApplicationModel.DataTransfer;\nusing Windows.ApplicationModel.DataTransfer.ShareTarget;\nusing Windows.Storage;\nusing Windows.UI.Core;\nusing Windows.UI.Xaml.Media.Imaging;\n\n// add the following private members to the SharePage class\nprivate ShareOperation operation = null;\nprivate StorageFile file = null;\n\n// Add the following method to the SharePage class\nprotected override async void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        // It is recommended to only retrieve the ShareOperation object in the activation handler, return as\n        // quickly as possible, and retrieve all data from the share target asynchronously.\n        operation = (ShareOperation)args.Parameter;\n\n        await Task.Factory.StartNew(async () =>\n        {\n            if (operation.Data.Contains(StandardDataFormats.StorageItems))\n            {\n                var storageItems = await operation.Data.GetStorageItemsAsync();\n                file = (StorageFile)(storageItems[0]);\n                var stream = await file.OpenReadAsync();\n                // Get back to the UI thread using the dispatcher.\n                await Dispatcher.RunAsync(CoreDispatcherPriority.Normal, async () =>\n                {\n                    var image = new BitmapImage();\n                    img.Source = image;\n                    await image.SetSourceAsync(stream);\n                });\n            }\n        });\n    }\n}\n\n\n\n\n\n\n\nUp to this point, the user has only shared the image with the UWP version of Knowzy. We need to share the image so it can be accessed by the WPF version of Knowzy. The SharePage UI includes a \"Share to Knowzy WPF\" \nbutton that will trigger this sharing operation. Add a \"ShareButton_Click\" event handler to SharePage.xaml.cs. Please note the location of the sharing folder. ApplicationData.Current.LocalFolder. More information on\nthis folder is available \nhere\n.\n\n\nprivate async void ShareButton_Click(object sender, RoutedEventArgs e)\n{\n    if (file != null)\n    {\n        // copy file to app's local folder. Desktop Bridge app will detect new file with its FileWatcher\n        try\n        {\n            await file.CopyAsync(ApplicationData.Current.LocalFolder, file.Name, NameCollisionOption.ReplaceExisting);\n        }\n        catch (Exception ex)\n        {\n            Debug.WriteLine(\"ShareButton_Click Error:\" + ex.Message);\n        }\n    }\n\n    if (operation != null)\n    {\n        operation.ReportCompleted();\n    }\n}\n\n\n\n\n\n\n\nNow that the image has been copied to the ApplicationData.Current.LocalFolder, the Knowzy WPF app needs to be able to detect that an image has been shared. \nWe will use a FileSystemWatcher to detect when an image has been to the ApplicationData.Current.LocalFolder. We will make this a feature that is only supported\nwhen the app is running as a Desktop Bridge app. Add the following code to MainView.xaml.cs in the Microsoft.Knowzy.WPF project:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing Microsoft.Knowzy.UwpHelpers;\n\npublic MainView()\n{\n    InitializeComponent();\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n    try\n        {\n            // get the path to the App folder (WPF or UWP).\n            var path = AppFolders.Local;\n            FileSystemWatcher watcher = new FileSystemWatcher(path);\n            watcher.EnableRaisingEvents = true;\n            watcher.Changed += Watcher_Changed;\n        }\n        catch(Exception ex)\n        {\n            Debug.WriteLine(\"FileSystemWatcher Error:\" + ex.Message);\n        }\n    }\n}\n\n\n\n\n\n\n\nAdd the FileSystemWatcher event handler to MainView.xaml.cs in the Microsoft.Knowzy.WPF project:\n\n\nprivate void Watcher_Changed(object sender, FileSystemEventArgs e)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        if (File.Exists(e.FullPath))\n        {\n            var xml = \"<toast><visual><binding template='ToastGeneric'><image src='\" + e.FullPath + \"'/><text hint-maxLines='1'>Microsoft.Knowzy.WPF received a new image</text></binding></visual></toast>\";\n            Toast.CreateToast(xml);\n        }\n    }\n}\n\n\n\n\n\n\n\nYou will need to add a getter to AppFolders.cs in Microsoft.Knowzy.UwpHelpers to return the path to Windows.Storage.ApplicationData.Current.LocalFolder. \n\n\nAdd the following code to AppFolders.cs\n\n\npublic static string Local\n{\n    get\n    {\n        string path = null;\n        if (ExecutionMode.IsRunningAsUwp())\n        {\n            path = GetSafeAppxLocalFolder();\n        }\n        return path;\n    }\n}\n\ninternal static string GetSafeAppxLocalFolder()\n{\n    try\n    {\n        return Windows.Storage.ApplicationData.Current.LocalFolder.Path;\n    }\n    catch (Exception ex)\n    {\n        System.Diagnostics.Debug.WriteLine(ex.Message);\n    }\n    return null;\n}\n\n\n\n\n\n\n\nOnce you have made all of your changes to to code, build and run the Microsoft.Knowzy.Debug project.\n\n\n\n\n\n\nOpen an Windows 10 application that is capable of sharing a picture (Microsoft Edge). Navigate to a picture you want to share.\n\n\n\n\n\n\nRight click on the image and select \nShare picture\n\n\n\n\n\n\n\n\n\n\nIn the list of apps that are iamge share targets, select Microsoft.Know.UWP\n\n\n\n\n\n\n\n\nThe Microsoft.Knowzy.UWP SharePage will appear and display the image. Click on the \nShare to Microsoft.Knowzy.WPF\n button.\n\n\n\n\n\n\n\n\nThe FileSystemWatcher in the Microsoft.Knowzy.WPF app will be notified that a new image has been shared to the app. It will then display the toast with the image.\n\n\n\n\n\n\nWe will continue to add more Windows 10 UWP features to our app in the \nnext task\n.\n\n\nReferences\n\n\n\n\n\n\nShare data\n\n\n\n\n\n\nSharing content target app sample\n \n\n\n\n\n\n\nSharing content source app sample\n\n\n\n\n\n\nAdding UWP features to your existing PC software\n\n\n\n\n\n\nWPF picture viewer as a share target\n\n\n\n\n\n\ncontinue to \nnext task >>",
            "title": "222 Share"
        },
        {
            "location": "/stories/2/222_Share/#task-222-add-support-for-other-apps-to-share-images-with-the-knowzy-app",
            "text": "Our development department has the idea to allow Knowzy app users to share images from other Windows 10 applications with the Knowzy app. \nFor now, we just want you to implement the Windows 10 sharing code. To show that the image was shared with the Knowzy app, please display a toast\nwith the image.  Requirements for this task:\n* Share an image from another Windows 10 App. The Knowzy app should appear as one of the options for Share Targets.    Display a XAML UI for sharing with the Knowzy app.    Display a Toast that displays the image after the sharing operation has completed.    Our research has found a starting point for the sharing idea  here \nunder the \"Making your PC software a share target\" section.  We also found some  sample code .",
            "title": "Task 2.2.2 -  Add support for other apps to share images with the Knowzy App"
        },
        {
            "location": "/stories/2/222_Share/#prerequisites",
            "text": "This task has a dependency on  Task 2.2.1  and all of it's prerequisites   Make sure the Microsoft.Knowzy.WPF.sln Build configuration to  Debug | x86",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/2/222_Share/#task",
            "text": "You will need to add a sharing extension to the Extension section of the Application tag in Package.appxmanifest in the Microsoft.Knowzy.UWP project to enable the app to be an image share target. \nYou also need to specify that you are a share target that supports Bitmap images.  <uap:Extension Category=\"windows.shareTarget\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\">\n<uap:ShareTarget>\n    <uap:SupportedFileTypes>\n    <uap:SupportsAnyFileType />\n    </uap:SupportedFileTypes>\n    <uap:DataFormat>Bitmap</uap:DataFormat>\n</uap:ShareTarget>\n</uap:Extension>    You will need to add an OnShareTargetActivated event handler to App.xaml.cs in the Microsoft.Knowzy.UWP project. This handler will be called when a user attempts to share an image to the Knowzy app.\nIt should look something like:  protected override void OnShareTargetActivated(ShareTargetActivatedEventArgs e)\n{\n    Frame rootFrame = new Frame();\n    Window.Current.Content = rootFrame;\n    rootFrame.Navigate(typeof(SharePage), e.ShareOperation);\n    Window.Current.Activate();\n}    You will need to add a new XAML page to the Microsoft.Knowzy.UWP project. Right click on the project and select  Add | New Item... . Choose the  Blank Page  template and name it  SharePage.xaml .    You will need to add the Sharing UI to the SharePage.xaml file. For now, use something like:  <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" Margin=\"12\">\n    <StackPanel>\n        <Button Content=\"Share to Microsoft.Knowzy.WPF\" Click=\"ShareButton_Click\"/>\n        <TextBlock x:Name=\"tbFileName\" />\n        <Image x:Name=\"img\"/>\n    </StackPanel>\n</Grid>    In the file SharePage.xaml.cs you will need to handle the OnNavigatedTo event. The NavigationEventArgs parameter will contain the shared image information. Display the shared image in the\nSharedPage UI. Pay attention to threading issues such as processing the image in a separate task. Also, you can only update the XAML UI image on the UI thread so you will need to use a dispacther to update the UI.  // add the following using directives\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Windows.ApplicationModel.DataTransfer;\nusing Windows.ApplicationModel.DataTransfer.ShareTarget;\nusing Windows.Storage;\nusing Windows.UI.Core;\nusing Windows.UI.Xaml.Media.Imaging;\n\n// add the following private members to the SharePage class\nprivate ShareOperation operation = null;\nprivate StorageFile file = null;\n\n// Add the following method to the SharePage class\nprotected override async void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        // It is recommended to only retrieve the ShareOperation object in the activation handler, return as\n        // quickly as possible, and retrieve all data from the share target asynchronously.\n        operation = (ShareOperation)args.Parameter;\n\n        await Task.Factory.StartNew(async () =>\n        {\n            if (operation.Data.Contains(StandardDataFormats.StorageItems))\n            {\n                var storageItems = await operation.Data.GetStorageItemsAsync();\n                file = (StorageFile)(storageItems[0]);\n                var stream = await file.OpenReadAsync();\n                // Get back to the UI thread using the dispatcher.\n                await Dispatcher.RunAsync(CoreDispatcherPriority.Normal, async () =>\n                {\n                    var image = new BitmapImage();\n                    img.Source = image;\n                    await image.SetSourceAsync(stream);\n                });\n            }\n        });\n    }\n}    Up to this point, the user has only shared the image with the UWP version of Knowzy. We need to share the image so it can be accessed by the WPF version of Knowzy. The SharePage UI includes a \"Share to Knowzy WPF\" \nbutton that will trigger this sharing operation. Add a \"ShareButton_Click\" event handler to SharePage.xaml.cs. Please note the location of the sharing folder. ApplicationData.Current.LocalFolder. More information on\nthis folder is available  here .  private async void ShareButton_Click(object sender, RoutedEventArgs e)\n{\n    if (file != null)\n    {\n        // copy file to app's local folder. Desktop Bridge app will detect new file with its FileWatcher\n        try\n        {\n            await file.CopyAsync(ApplicationData.Current.LocalFolder, file.Name, NameCollisionOption.ReplaceExisting);\n        }\n        catch (Exception ex)\n        {\n            Debug.WriteLine(\"ShareButton_Click Error:\" + ex.Message);\n        }\n    }\n\n    if (operation != null)\n    {\n        operation.ReportCompleted();\n    }\n}    Now that the image has been copied to the ApplicationData.Current.LocalFolder, the Knowzy WPF app needs to be able to detect that an image has been shared. \nWe will use a FileSystemWatcher to detect when an image has been to the ApplicationData.Current.LocalFolder. We will make this a feature that is only supported\nwhen the app is running as a Desktop Bridge app. Add the following code to MainView.xaml.cs in the Microsoft.Knowzy.WPF project:  using System;\nusing System.Diagnostics;\nusing System.IO;\nusing Microsoft.Knowzy.UwpHelpers;\n\npublic MainView()\n{\n    InitializeComponent();\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n    try\n        {\n            // get the path to the App folder (WPF or UWP).\n            var path = AppFolders.Local;\n            FileSystemWatcher watcher = new FileSystemWatcher(path);\n            watcher.EnableRaisingEvents = true;\n            watcher.Changed += Watcher_Changed;\n        }\n        catch(Exception ex)\n        {\n            Debug.WriteLine(\"FileSystemWatcher Error:\" + ex.Message);\n        }\n    }\n}    Add the FileSystemWatcher event handler to MainView.xaml.cs in the Microsoft.Knowzy.WPF project:  private void Watcher_Changed(object sender, FileSystemEventArgs e)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        if (File.Exists(e.FullPath))\n        {\n            var xml = \"<toast><visual><binding template='ToastGeneric'><image src='\" + e.FullPath + \"'/><text hint-maxLines='1'>Microsoft.Knowzy.WPF received a new image</text></binding></visual></toast>\";\n            Toast.CreateToast(xml);\n        }\n    }\n}    You will need to add a getter to AppFolders.cs in Microsoft.Knowzy.UwpHelpers to return the path to Windows.Storage.ApplicationData.Current.LocalFolder.   Add the following code to AppFolders.cs  public static string Local\n{\n    get\n    {\n        string path = null;\n        if (ExecutionMode.IsRunningAsUwp())\n        {\n            path = GetSafeAppxLocalFolder();\n        }\n        return path;\n    }\n}\n\ninternal static string GetSafeAppxLocalFolder()\n{\n    try\n    {\n        return Windows.Storage.ApplicationData.Current.LocalFolder.Path;\n    }\n    catch (Exception ex)\n    {\n        System.Diagnostics.Debug.WriteLine(ex.Message);\n    }\n    return null;\n}    Once you have made all of your changes to to code, build and run the Microsoft.Knowzy.Debug project.    Open an Windows 10 application that is capable of sharing a picture (Microsoft Edge). Navigate to a picture you want to share.    Right click on the image and select  Share picture      In the list of apps that are iamge share targets, select Microsoft.Know.UWP     The Microsoft.Knowzy.UWP SharePage will appear and display the image. Click on the  Share to Microsoft.Knowzy.WPF  button.     The FileSystemWatcher in the Microsoft.Knowzy.WPF app will be notified that a new image has been shared to the app. It will then display the toast with the image.    We will continue to add more Windows 10 UWP features to our app in the  next task .",
            "title": "Task"
        },
        {
            "location": "/stories/2/222_Share/#references",
            "text": "Share data    Sharing content target app sample      Sharing content source app sample    Adding UWP features to your existing PC software    WPF picture viewer as a share target",
            "title": "References"
        },
        {
            "location": "/stories/2/222_Share/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/2/223_AppServices/",
            "text": "Task 2.2.3 -  Adding App Services to the Knowzy Desktop Bridge App\n\n\nOur development department has identified a problem with the Desktop Bridge version of the Knowzy app.\n\n\n\n\n\n\nThere appears to be no way to implement bi-directional communication between the WPF code and the UWP code of the Knowzy app.\n\n\n\n\n\n\nWe can send Uri protocol messages to the UWP code using Windows.System.Launcher.LaunchUriAsync(uri) but we can't receive a response.\n\n\n\n\n\n\nWindows.System.Launcher.LaunchUriForResultsAsync\n seems to be a solution as it returns a response to the request\nbut LaunchUriForResultsAsync is not supported in DesktopBridge applications.\n\n\n\n\n\n\n\n\n\n\nIt appears that a Windows 10 UWP \nApp Service\n will allow data to be shared between a UWP app and a WPF app. There is an example of \nthis sharing scenario \nhere\n \nin the \"Exposing an App Service\" section. However, this example requires that we move some of our WPF source code into the App Service. Also there is no example of \nhow to share data between the UWP and WPF portions of our app. \n\n\nHere is the problem with the communications between the WPF and UWP parts of our DeskTop Bridge app using an App Service.\n\n\n\n\nThe WPF app starts and connects to the App Service\n\n\n\n\n\n\n\n\nThe XAML UI starts up and connects to the App Service\n\n\n\n\n\n\n\n\nThe WPF app sends a request to the App Service. It can only receive a reply from the App Service. The request is not sent to the XAML UI.\nLikewise, if the XAML UI makes a request to the App Service, that request is not forwarded to the WPF app. Each app can only receive a reply from\nthe App Service. Each connection from an app to the App Service may also be running a separate instance of the App Servce so the two connections are not\naware of each other.\n\n\n\n\n\n\nThere is a solution to this problem if we make Microsoft.Knowzy.UWP.exe the startup app for our DeskTop Bridge app. However, we are not ready to make the UWP version since we have not ported the WPF UI to the UWP app.\nWe still need the WPF app to be the UI for our desktop bridge app. So we will need to modify our App Service to bridge the communication between the WPF and UWP portions of our Desktop Bridge app.\n\n\nRequirements for this task:\n\n\n\n\n\n\nCreate an App Service that enables the sharing of the Product information.\n\n\n\n\n\n\nShare Clown nose product information between the UWP XAML UI and the WPF Knowzy application.\n\n\n\n\n\n\nShare Clown nose product information from the WPF Knowzy application and an external Windows 10 UWP application.\n\n\n\n\n\n\nWe want to implement the following App Service  scenario:\n\n\n\n\n\n\nThe WPF app launches the Windows 10 App Service and registers itself to the App Service as a listener with a unique listener id.\n\n\n\n\n\n\n\n\nThe WPF app opens the UWP XAML UI using Windows.System.Launcher.LaunchUriAsync(uri) and sends the listener id as a parameter.\n\n\n\n\n\n\n\n\nThe UWP Xaml UI connects to the App Service, does its work, and sends the response data to the App Service along with the listener id.\n\n\n\n\n\n\n\n\nThe App Service sends the response data to the listener with the specified listener id.\n\n\n\n\n\n\n\n\nOur research has found a starting point for the App Service idea \nhere\n.\nYou will need to modify this code to enable bi-directional communication between the UWP Xaml ui and the WPF application code.\n\n\nWe also found some App Service sample code \nhere\n.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 2.2.1\n and all of it's prerequisites\n\n\nSince this will be quite a complicated task, it is recommended that you work through the \nCreate and consume an app service tutorial\n.\nThis tutorial will familiarize you with the following:\n\n\n\n\n\n\nHow to create an App Service project and add it to your solution.\n\n\n\n\n\n\nHow to specify the App Service in the Package.appxmanifest.\n\n\n\n\n\n\nHow to open a connection to an App Service.\n\n\n\n\n\n\nHow to send a request to an App Service.\n\n\n\n\n\n\nHow to receive a message from an App Service.\n\n\n\n\n\n\nOnce you have completed the tutorial, you will be ready to add an App Service to the Knowzy DeskTop Bridge app.\n\n\n\n\nMake sure the Microsoft.Knowzy.WPF.sln Build configuration to \nDebug | x86\n\n\n\n\n\n\nTask\n\n\nCreate the App Service Project\n\n\n\n\n\n\nRight-click on the src folder in the Microsoft.Knowzy.WPF solution and select \nAdd | New Project...\n\n\n\n\n\n\nSelect the \nVisual C# | Windows Univeral | Windows Runtime Component (Univeral Windows)\n project template.\n\n\n\n\n\n\nMake sure you are creating the project in the \nsrc\n folder and name the project \nMicrosoft.Knowzy.AppService\n.\n\n\n\n\n\n\n\n\n\n\n\n\nRename the Class1.cs file in the Microsoft.Knowzy.AppService project to AppServiceTask.cs\n\n\n\n\n\n\nAdd the following using directives to AppServiceTask.cs:\n\n\nusing Windows.ApplicationModel.AppService;\nusing Windows.ApplicationModel.Background;\n\n\n\n\n\n\n\nAdd the following boilerplate AppService code to AppServiceTask.cs\n\n\nnamespace Microsoft.Knowzy.AppService\n{\n    public sealed class AppServiceTask : IBackgroundTask\n    {\n        private BackgroundTaskDeferral backgroundTaskDeferral;\n        private AppServiceConnection appServiceconnection;\n\n        public void Run(IBackgroundTaskInstance taskInstance)\n        {\n            this.backgroundTaskDeferral = taskInstance.GetDeferral(); // Get a deferral so that the service isn't terminated.\n            taskInstance.Canceled += OnTaskCanceled; // Associate a cancellation handler with the background task.\n\n            // Retrieve the app service connection and set up a listener for incoming app service requests.\n            var details = taskInstance.TriggerDetails as AppServiceTriggerDetails;\n            appServiceconnection = details.AppServiceConnection;\n            appServiceconnection.RequestReceived += OnRequestReceived;\n        }\n\n        private async void OnRequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n        {\n        }\n\n        private void OnTaskCanceled(IBackgroundTaskInstance sender, BackgroundTaskCancellationReason reason)\n        {\n            if (this.backgroundTaskDeferral != null)\n            {\n                // Complete the service deferral.\n                this.backgroundTaskDeferral.Complete();\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\nBuild your solution and fix any compilation errors in the App Service code.\n\n\n\n\n\n\nAdd the App Service to the Package.appxmanifest\n\n\n\n\n\n\nOpen the Package.appxmanifest file in the Microsoft.Knowzy.UWP project by right-clicking on the file and select \nView Code\n.\n\n\n\n\n\n\nAdd the following xml to the Extensions section.\n\n\n<uap:Extension Category=\"windows.appService\" EntryPoint=\"Microsoft.Knowzy.AppService.AppServiceTask\">\n<uap:AppService Name=\"com.microsoft.knowzy.appservice\" uap4:SupportsMultipleInstances=\"false\"/>\n</uap:Extension>\n\n\n\n\n\n\n\nIf necessary, add the following xmlns declaration to the Package tag\n\n\nxmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"\n\n\n\n\n\n\n\nAdd a project reference to Microsoft.Knowzy.AppService\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.UWP project and select \nAdd | Reference...\n\n\n\n\n\n\nSelect the \nMicrosoft.Knowzy.AppService\n project under the \nProjects | Solution\n section. \n\n\n\n\n\n\nThe Microsoft.Knowzy.AppService will now be part of the Knowzy UWP AppX package after a build.\n\n\n\n\n\n\nAdd a AppService helper class to Microsoft.Knowzy.UwpHelpers\n\n\n\n\n\n\nAdd a new C# class called AppService.cs to the  Microsoft.Knowzy.UwpHelpers project.\n\n\n\n\n\n\nAdd the following using directives to AppService.cs\n\n\nusing System.Threading.Tasks;\nusing Windows.ApplicationModel.AppService;\nusing Windows.Foundation.Collections;\n\n\n\n\n\n\n\nAdd the following code to AppService.cs. This code creates a connection to the App Service and registers the connection as a listener for messages with a specific id. Whenever the\nApp Service receives a message with the specified id, it will call the Connection_RequestReceived method with the message.\n\n\npublic class AppService\n{\n    private AppServiceConnection _connection = null;\n    private String _listenerId;\n\n    public AppService()\n    {\n    }\n\n    public async Task<bool> StartAppServiceConnection(String listenerId)\n    {\n        var result = false;\n        if (_connection != null)\n        {\n            _connection.Dispose();\n            _connection = null;\n        }\n\n        // Open a connection to the App Service\n        _listenerId = listenerId;\n        _connection = new AppServiceConnection();\n        _connection.AppServiceName = \"com.microsoft.knowzy.appservice\";\n        _connection.PackageFamilyName = Windows.ApplicationModel.Package.Current.Id.FamilyName;\n        _connection.RequestReceived += Connection_RequestReceived;\n        _connection.ServiceClosed += Connection_ServiceClosed;\n        AppServiceConnectionStatus status = await _connection.OpenAsync();\n        if (status == AppServiceConnectionStatus.Success)\n        {\n            // register this App Service Connection as a listener\n            ValueSet registerData = new ValueSet();\n            registerData.Add(\"Type\", \"Register\");\n            registerData.Add(\"Id\", listenerId);\n            var response = await _connection.SendMessageAsync(registerData);\n            if (response.Status == AppServiceResponseStatus.Success)\n            {\n                var message = response.Message;\n                result = message.ContainsKey(\"Status\") && message[\"Status\"].ToString() == \"OK\";\n            }\n        }\n        return result;\n    }\n\n    private async void Connection_RequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n    {\n        var messageDeferral = args.GetDeferral();\n        ValueSet returnData = new ValueSet();\n        returnData.Add(\"Status\", \"OK\");\n        returnData.Add(\"Data\", \"Knowzy WPF app received message: \" + args.Request.Message[\"Data\"]);\n        await args.Request.SendResponseAsync(returnData);\n        messageDeferral.Complete(); // Complete the deferral so that the platform knows that we're done responding to the app service call.\n    }\n\n    private void Connection_ServiceClosed(AppServiceConnection sender, AppServiceClosedEventArgs args)\n    {\n        _connection.Dispose();\n        _connection = null;\n    }\n}\n\n\n\n\n\n\n\nAdd Listener support to the App Service\n\n\nWe will now modify the Microsoft.Knowzy.AppService component to support the adding and removing of connection listeners\n\n\n\n\n\n\nIf necessary, add the following using directive to AppServiceTask.cs in the Microsoft.Knowzy.AppService project:\n\n\nusing System.Collections.Generic;\nusing System.Threading;\nusing Windows.Foundation.Collections;\n\n\n\n\n\n\n\nAdd the following private members to the AppServiceTask class.\n\n\n// Map of AppService message Listeners\nprivate static IDictionary<string, AppServiceConnection> _connectionMap = new Dictionary<string, AppServiceConnection>();\n\n// Mutex to protect access to _connectionMap\nprivate static Mutex _mutex = new Mutex();\n\n\n\n\n\n\n\nAdd methods to add and remove a listener connection. We use a mutex to protect access to the connection Dictionary\n\n\nprivate void AddListener(String id, AppServiceConnection connection)\n{\n    _mutex.WaitOne();\n    _connectionMap[id] = connection;\n    _mutex.ReleaseMutex();\n}\n\nprivate void RemoveListener(String id)\n{\n    _mutex.WaitOne();\n    if (_connectionMap.ContainsKey(id))\n    {\n        _connectionMap.Remove(id);\n    }\n    _mutex.ReleaseMutex();\n}\n\n\n\n\n\n\n\nAdd a method to handle sending a message to a listener. This method will wait for the response from the listener and return the response to the caller.\n\n\nprivate async Task<ValueSet> SendMessage(String id, ValueSet message)\n{\n    String errorMessage = \"\";\n\n    _mutex.WaitOne();\n    AppServiceConnection appServiceConnection = null;\n    if (_connectionMap.ContainsKey(id))\n    {\n        appServiceConnection = _connectionMap[id];\n    }\n    _mutex.ReleaseMutex();\n\n    if (appServiceConnection != null)\n    {\n        var response = await appServiceConnection.SendMessageAsync(message);\n        if (response.Status == AppServiceResponseStatus.Success)\n        {\n            return response.Message;\n        }\n        else\n        {\n            errorMessage = \"SendMessageAsync result: \" + response.Status;\n        }\n    }\n    else\n    {\n        errorMessage = \"No registered Listener for Id: \" + id;\n    }\n\n    // build the error response\n    ValueSet error = new ValueSet();\n    error.Add(\"Status\", \"Error\");\n    error.Add(\"ErrorMessage\", errorMessage);\n    return error;\n}\n\n\n\n\n\n\n\nUpdate the OnRequestReceived method to handle listener registration and the sending messages to listeners.\n\n\nasync void OnRequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n{\n    // Get a deferral because we use an awaitable API below to respond to the message\n    // and we don't want this call to get cancelled while we are waiting.\n    var messageDeferral = args.GetDeferral();\n\n    var message = args.Request.Message;\n    ValueSet response = new ValueSet();\n\n    if (message.ContainsKey(\"Type\") && message.ContainsKey(\"Id\"))\n    {\n        var type = message[\"Type\"];\n        var id = message[\"Id\"].ToString();\n        switch (type)\n        {\n            case \"Register\":\n                AddListener(id, sender);\n                response.Add(\"Status\", \"OK\");\n                break;\n\n            case \"Unregister\":\n                RemoveListener(id);\n                response.Add(\"Status\", \"OK\");\n                break;\n\n            case \"Message\":\n                response = await SendMessage(id, message);\n                break;\n\n            default:\n                response.Add(\"Status\", \"Error\");\n                response.Add(\"ErrorMessage\", \"Unknown KnowzyAppServiceMessage type\");\n                break;\n        }\n    }\n    else\n    {\n        response.Add(\"Status\", \"Error\");\n        response.Add(\"ErrorMessage\", \"Missing valid Type or Id parameters\");\n    }\n\n    await args.Request.SendResponseAsync(response);\n    messageDeferral.Complete(); // Complete the deferral so that the platform knows that we're done responding to the app service call.\n}\n\n\n\n\n\n\n\nEnable Microsoft.Knowzy.WPF to use the App Service\n\n\n\n\n\n\nAdd a Click event to the Menu Menu in Views\\MainView.xaml in the Microsoft.Knowzy.WPF project near line 42.\n\n\n<MenuItem Header=\"{x:Static localization:Resources.Menu_Menu}\" Template=\"{DynamicResource MenuItemControlTemplate}\" Click=\"Menu_Click\"/>\n\n\n\n\n\n\n\nAdd the Menu_Click handler in MainView.xaml.cs in the Microsoft.Knowzy.WPF project.\n\n\nAppService _appService = null;\n\nprivate async void Menu_Click(object sender, EventArgs e)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        if(_appService == null)\n        {\n            // start the app service\n            _appService = new AppService();\n            var result = await _appService.StartAppServiceConnection(\"com.microsoft.knowzy.appservice.test\");\n        }\n\n        // start the XAML UI that will communicate with the App Service\n        Uri uri = new Uri(\"com.microsoft.knowzy.protocol.test://\" + \"message?appserviceid=\" + \"com.microsoft.knowzy.appservice.test\");\n        await UriProtocol.SendUri(uri);\n    }\n}\n\n\n\n\n\n\n\nThis code will open a connection to the Knowzy App Service and will also open the Xaml AppServiceTest page in the UWP portion of Knowzy. The AppServiceTest page will connect to the AppService and send a message\nto the WPF app through the AppService when the use clicks on the Connect button. The WPF app will echo the message and send it back to the UWP app through the App Service.\n\n\nAdd the new Uri protocol to package.appxmanifest in the Microsoft.Knowzy.UWP project\n\n\n<uap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\">\n<uap:Protocol Name=\"com.microsoft.knowzy.protocol.test\" />\n</uap:Extension>\n\n\n\nAdd the XAML ui page that will communicate with the App Service\n\n\n\n\n\n\nAdd a new XAML page to Microsoft.Knowzy.UWP project. Name the page AppServiceTest.xaml.\n\n\n\n\n\n\nAdd some XAML UI elements to AppServiceTest.xaml\n\n\n<Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" Margin=\"12\">\n    <StackPanel Orientation=\"Vertical\">\n        <TextBox Name=\"textBox\" />\n        <Button Content=\"Connect\" Click=\"Button_Click\" />\n    </StackPanel>\n</Grid>\n\n\n\n\n\n\n\nModify the OnActivated() method in App.xaml.cs in the Microsoft.Knowzy.UWP project as follows:\n\n\nprotected override void OnActivated(IActivatedEventArgs args)\n{\n    if (args.Kind == ActivationKind.Protocol)\n    {\n        ProtocolActivatedEventArgs eventArgs = args as ProtocolActivatedEventArgs;\n        // TODO: Handle URI activation\n        // The received URI is eventArgs.Uri.AbsoluteUri\n\n        Uri uri = eventArgs.Uri;\n        if (uri.Scheme == \"com.microsoft.knowzy.protocol.3d\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(MainPage), uri.Query);\n            Window.Current.Activate();\n        }\n        else if (uri.Scheme == \"com.microsoft.knowzy.protocol.test\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(AppServiceTest), uri.Query);\n            Window.Current.Activate();\n        }\n    }\n}\n\n\n\n\n\n\n\nAdd the following using directive to AppServiceTest.xaml.cs\n\n\nusing Windows.ApplicationModel.AppService;\n\n\n\n\n\n\n\nAdd the following properties to the AppServiceTest class:\n\n\nprivate String _connectionId;\nprivate AppServiceConnection _connection = null;\n\n\n\n\n\n\n\nAdd the uri protocol handler to parse the appserviceid from the uri.\n\n\nprotected override void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        WwwFormUrlDecoder decoder = new WwwFormUrlDecoder(args.Parameter.ToString());\n        try\n        {\n            _connectionId = decoder.GetFirstValueByName(\"appserviceid\");\n        }\n        catch (Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine(\"AppServiceTest OnNavigatedTo Error: \" + ex.Message);\n        }\n    }\n}\n\n\n\n\n\n\n\nAdd the Button_Click handler\n\n\nprivate async void Button_Click(object sender, RoutedEventArgs e)\n{\n    if (_connection == null)\n    {\n        _connection = new AppServiceConnection();\n\n        // Here, we use the app service name defined in the app service provider's Package.appxmanifest file in the <Extension> section.\n        _connection.AppServiceName = \"com.microsoft.knowzy.appservice\"; ;\n\n        // Use Windows.ApplicationModel.Package.Current.Id.FamilyName within the app service provider to get this value.\n        _connection.PackageFamilyName = Windows.ApplicationModel.Package.Current.Id.FamilyName;\n\n        var status = await _connection.OpenAsync();\n        if (status != AppServiceConnectionStatus.Success)\n        {\n            textBox.Text = \"Failed to connect \" + status;\n            return;\n        }\n    }\n\n    ValueSet data = new ValueSet();\n    data.Add(\"Type\", \"Message\");\n    data.Add(\"Id\", _connectionId);\n    data.Add(\"Data\", \"Message from AppServiceTest XAML UI\");\n    textBox.Text = \"Sending message to App Service connection listener: \" + _connectionId;\n\n    var response = await _connection.SendMessageAsync(data);\n    if (response.Status == AppServiceResponseStatus.Success)\n    {\n        var message = response.Message;\n        bool result = message.ContainsKey(\"Status\") && message[\"Status\"].ToString() == \"OK\";\n        if (result)\n        {\n            var text = message[\"Data\"] as String;\n            textBox.Text = text;\n        }\n    }\n}\n\n\n\n\n\n\n\nBuild and run the Knowzy app by starting the Microsoft.Knowzy.Debug project.\n\n\n\n\n\n\nClick on the \nMenu\n menu item.\n\n\n\n\n\n\nWhen the AppServiceTest windows appears, click on the \nConnect\n button.\n\n\n\n\n\n\nThe following things should now happen\n\n\n\n\n\n\nThe UWP app will send a message to the AppService\n\n\n\n\n\n\nThe AppService wil forward the event to the WPF via its listener connection\n\n\n\n\n\n\nThe WPF responds to the message and send the result back to the App Service\n\n\n\n\n\n\nThe App Service returns the result from the WPF app back to the UWP app\n\n\n\n\n\n\nThe UWP app displays the result it received from the WPF app.\n\n\n\n\n\n\n\n\n\n\n\n\nYou have now successfully developed a solution for communicating between the UWP and WPF portions of your Desktop Bridge app using an App Service.\n\n\nReferences\n\n\n\n\n\n\nCreate and consume an app service\n\n\n\n\n\n\nApp services sample\n\n\n\n\n\n\nAdding UWP features to your existing PC software\n\n\n\n\n\n\ncontinue to \nnext task >>",
            "title": "223 AppServices"
        },
        {
            "location": "/stories/2/223_AppServices/#task-223-adding-app-services-to-the-knowzy-desktop-bridge-app",
            "text": "Our development department has identified a problem with the Desktop Bridge version of the Knowzy app.    There appears to be no way to implement bi-directional communication between the WPF code and the UWP code of the Knowzy app.    We can send Uri protocol messages to the UWP code using Windows.System.Launcher.LaunchUriAsync(uri) but we can't receive a response.    Windows.System.Launcher.LaunchUriForResultsAsync  seems to be a solution as it returns a response to the request\nbut LaunchUriForResultsAsync is not supported in DesktopBridge applications.      It appears that a Windows 10 UWP  App Service  will allow data to be shared between a UWP app and a WPF app. There is an example of \nthis sharing scenario  here  \nin the \"Exposing an App Service\" section. However, this example requires that we move some of our WPF source code into the App Service. Also there is no example of \nhow to share data between the UWP and WPF portions of our app.   Here is the problem with the communications between the WPF and UWP parts of our DeskTop Bridge app using an App Service.   The WPF app starts and connects to the App Service     The XAML UI starts up and connects to the App Service     The WPF app sends a request to the App Service. It can only receive a reply from the App Service. The request is not sent to the XAML UI.\nLikewise, if the XAML UI makes a request to the App Service, that request is not forwarded to the WPF app. Each app can only receive a reply from\nthe App Service. Each connection from an app to the App Service may also be running a separate instance of the App Servce so the two connections are not\naware of each other.    There is a solution to this problem if we make Microsoft.Knowzy.UWP.exe the startup app for our DeskTop Bridge app. However, we are not ready to make the UWP version since we have not ported the WPF UI to the UWP app.\nWe still need the WPF app to be the UI for our desktop bridge app. So we will need to modify our App Service to bridge the communication between the WPF and UWP portions of our Desktop Bridge app.  Requirements for this task:    Create an App Service that enables the sharing of the Product information.    Share Clown nose product information between the UWP XAML UI and the WPF Knowzy application.    Share Clown nose product information from the WPF Knowzy application and an external Windows 10 UWP application.    We want to implement the following App Service  scenario:    The WPF app launches the Windows 10 App Service and registers itself to the App Service as a listener with a unique listener id.     The WPF app opens the UWP XAML UI using Windows.System.Launcher.LaunchUriAsync(uri) and sends the listener id as a parameter.     The UWP Xaml UI connects to the App Service, does its work, and sends the response data to the App Service along with the listener id.     The App Service sends the response data to the listener with the specified listener id.     Our research has found a starting point for the App Service idea  here .\nYou will need to modify this code to enable bi-directional communication between the UWP Xaml ui and the WPF application code.  We also found some App Service sample code  here .",
            "title": "Task 2.2.3 -  Adding App Services to the Knowzy Desktop Bridge App"
        },
        {
            "location": "/stories/2/223_AppServices/#prerequisites",
            "text": "This task has a dependency on  Task 2.2.1  and all of it's prerequisites  Since this will be quite a complicated task, it is recommended that you work through the  Create and consume an app service tutorial .\nThis tutorial will familiarize you with the following:    How to create an App Service project and add it to your solution.    How to specify the App Service in the Package.appxmanifest.    How to open a connection to an App Service.    How to send a request to an App Service.    How to receive a message from an App Service.    Once you have completed the tutorial, you will be ready to add an App Service to the Knowzy DeskTop Bridge app.   Make sure the Microsoft.Knowzy.WPF.sln Build configuration to  Debug | x86",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/2/223_AppServices/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/2/223_AppServices/#create-the-app-service-project",
            "text": "Right-click on the src folder in the Microsoft.Knowzy.WPF solution and select  Add | New Project...    Select the  Visual C# | Windows Univeral | Windows Runtime Component (Univeral Windows)  project template.    Make sure you are creating the project in the  src  folder and name the project  Microsoft.Knowzy.AppService .       Rename the Class1.cs file in the Microsoft.Knowzy.AppService project to AppServiceTask.cs    Add the following using directives to AppServiceTask.cs:  using Windows.ApplicationModel.AppService;\nusing Windows.ApplicationModel.Background;    Add the following boilerplate AppService code to AppServiceTask.cs  namespace Microsoft.Knowzy.AppService\n{\n    public sealed class AppServiceTask : IBackgroundTask\n    {\n        private BackgroundTaskDeferral backgroundTaskDeferral;\n        private AppServiceConnection appServiceconnection;\n\n        public void Run(IBackgroundTaskInstance taskInstance)\n        {\n            this.backgroundTaskDeferral = taskInstance.GetDeferral(); // Get a deferral so that the service isn't terminated.\n            taskInstance.Canceled += OnTaskCanceled; // Associate a cancellation handler with the background task.\n\n            // Retrieve the app service connection and set up a listener for incoming app service requests.\n            var details = taskInstance.TriggerDetails as AppServiceTriggerDetails;\n            appServiceconnection = details.AppServiceConnection;\n            appServiceconnection.RequestReceived += OnRequestReceived;\n        }\n\n        private async void OnRequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n        {\n        }\n\n        private void OnTaskCanceled(IBackgroundTaskInstance sender, BackgroundTaskCancellationReason reason)\n        {\n            if (this.backgroundTaskDeferral != null)\n            {\n                // Complete the service deferral.\n                this.backgroundTaskDeferral.Complete();\n            }\n        }\n    }\n}    Build your solution and fix any compilation errors in the App Service code.",
            "title": "Create the App Service Project"
        },
        {
            "location": "/stories/2/223_AppServices/#add-the-app-service-to-the-packageappxmanifest",
            "text": "Open the Package.appxmanifest file in the Microsoft.Knowzy.UWP project by right-clicking on the file and select  View Code .    Add the following xml to the Extensions section.  <uap:Extension Category=\"windows.appService\" EntryPoint=\"Microsoft.Knowzy.AppService.AppServiceTask\">\n<uap:AppService Name=\"com.microsoft.knowzy.appservice\" uap4:SupportsMultipleInstances=\"false\"/>\n</uap:Extension>    If necessary, add the following xmlns declaration to the Package tag  xmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"",
            "title": "Add the App Service to the Package.appxmanifest"
        },
        {
            "location": "/stories/2/223_AppServices/#add-a-project-reference-to-microsoftknowzyappservice",
            "text": "Right-click on the Microsoft.Knowzy.UWP project and select  Add | Reference...    Select the  Microsoft.Knowzy.AppService  project under the  Projects | Solution  section.     The Microsoft.Knowzy.AppService will now be part of the Knowzy UWP AppX package after a build.",
            "title": "Add a project reference to Microsoft.Knowzy.AppService"
        },
        {
            "location": "/stories/2/223_AppServices/#add-a-appservice-helper-class-to-microsoftknowzyuwphelpers",
            "text": "Add a new C# class called AppService.cs to the  Microsoft.Knowzy.UwpHelpers project.    Add the following using directives to AppService.cs  using System.Threading.Tasks;\nusing Windows.ApplicationModel.AppService;\nusing Windows.Foundation.Collections;    Add the following code to AppService.cs. This code creates a connection to the App Service and registers the connection as a listener for messages with a specific id. Whenever the\nApp Service receives a message with the specified id, it will call the Connection_RequestReceived method with the message.  public class AppService\n{\n    private AppServiceConnection _connection = null;\n    private String _listenerId;\n\n    public AppService()\n    {\n    }\n\n    public async Task<bool> StartAppServiceConnection(String listenerId)\n    {\n        var result = false;\n        if (_connection != null)\n        {\n            _connection.Dispose();\n            _connection = null;\n        }\n\n        // Open a connection to the App Service\n        _listenerId = listenerId;\n        _connection = new AppServiceConnection();\n        _connection.AppServiceName = \"com.microsoft.knowzy.appservice\";\n        _connection.PackageFamilyName = Windows.ApplicationModel.Package.Current.Id.FamilyName;\n        _connection.RequestReceived += Connection_RequestReceived;\n        _connection.ServiceClosed += Connection_ServiceClosed;\n        AppServiceConnectionStatus status = await _connection.OpenAsync();\n        if (status == AppServiceConnectionStatus.Success)\n        {\n            // register this App Service Connection as a listener\n            ValueSet registerData = new ValueSet();\n            registerData.Add(\"Type\", \"Register\");\n            registerData.Add(\"Id\", listenerId);\n            var response = await _connection.SendMessageAsync(registerData);\n            if (response.Status == AppServiceResponseStatus.Success)\n            {\n                var message = response.Message;\n                result = message.ContainsKey(\"Status\") && message[\"Status\"].ToString() == \"OK\";\n            }\n        }\n        return result;\n    }\n\n    private async void Connection_RequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n    {\n        var messageDeferral = args.GetDeferral();\n        ValueSet returnData = new ValueSet();\n        returnData.Add(\"Status\", \"OK\");\n        returnData.Add(\"Data\", \"Knowzy WPF app received message: \" + args.Request.Message[\"Data\"]);\n        await args.Request.SendResponseAsync(returnData);\n        messageDeferral.Complete(); // Complete the deferral so that the platform knows that we're done responding to the app service call.\n    }\n\n    private void Connection_ServiceClosed(AppServiceConnection sender, AppServiceClosedEventArgs args)\n    {\n        _connection.Dispose();\n        _connection = null;\n    }\n}",
            "title": "Add a AppService helper class to Microsoft.Knowzy.UwpHelpers"
        },
        {
            "location": "/stories/2/223_AppServices/#add-listener-support-to-the-app-service",
            "text": "We will now modify the Microsoft.Knowzy.AppService component to support the adding and removing of connection listeners    If necessary, add the following using directive to AppServiceTask.cs in the Microsoft.Knowzy.AppService project:  using System.Collections.Generic;\nusing System.Threading;\nusing Windows.Foundation.Collections;    Add the following private members to the AppServiceTask class.  // Map of AppService message Listeners\nprivate static IDictionary<string, AppServiceConnection> _connectionMap = new Dictionary<string, AppServiceConnection>();\n\n// Mutex to protect access to _connectionMap\nprivate static Mutex _mutex = new Mutex();    Add methods to add and remove a listener connection. We use a mutex to protect access to the connection Dictionary  private void AddListener(String id, AppServiceConnection connection)\n{\n    _mutex.WaitOne();\n    _connectionMap[id] = connection;\n    _mutex.ReleaseMutex();\n}\n\nprivate void RemoveListener(String id)\n{\n    _mutex.WaitOne();\n    if (_connectionMap.ContainsKey(id))\n    {\n        _connectionMap.Remove(id);\n    }\n    _mutex.ReleaseMutex();\n}    Add a method to handle sending a message to a listener. This method will wait for the response from the listener and return the response to the caller.  private async Task<ValueSet> SendMessage(String id, ValueSet message)\n{\n    String errorMessage = \"\";\n\n    _mutex.WaitOne();\n    AppServiceConnection appServiceConnection = null;\n    if (_connectionMap.ContainsKey(id))\n    {\n        appServiceConnection = _connectionMap[id];\n    }\n    _mutex.ReleaseMutex();\n\n    if (appServiceConnection != null)\n    {\n        var response = await appServiceConnection.SendMessageAsync(message);\n        if (response.Status == AppServiceResponseStatus.Success)\n        {\n            return response.Message;\n        }\n        else\n        {\n            errorMessage = \"SendMessageAsync result: \" + response.Status;\n        }\n    }\n    else\n    {\n        errorMessage = \"No registered Listener for Id: \" + id;\n    }\n\n    // build the error response\n    ValueSet error = new ValueSet();\n    error.Add(\"Status\", \"Error\");\n    error.Add(\"ErrorMessage\", errorMessage);\n    return error;\n}    Update the OnRequestReceived method to handle listener registration and the sending messages to listeners.  async void OnRequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n{\n    // Get a deferral because we use an awaitable API below to respond to the message\n    // and we don't want this call to get cancelled while we are waiting.\n    var messageDeferral = args.GetDeferral();\n\n    var message = args.Request.Message;\n    ValueSet response = new ValueSet();\n\n    if (message.ContainsKey(\"Type\") && message.ContainsKey(\"Id\"))\n    {\n        var type = message[\"Type\"];\n        var id = message[\"Id\"].ToString();\n        switch (type)\n        {\n            case \"Register\":\n                AddListener(id, sender);\n                response.Add(\"Status\", \"OK\");\n                break;\n\n            case \"Unregister\":\n                RemoveListener(id);\n                response.Add(\"Status\", \"OK\");\n                break;\n\n            case \"Message\":\n                response = await SendMessage(id, message);\n                break;\n\n            default:\n                response.Add(\"Status\", \"Error\");\n                response.Add(\"ErrorMessage\", \"Unknown KnowzyAppServiceMessage type\");\n                break;\n        }\n    }\n    else\n    {\n        response.Add(\"Status\", \"Error\");\n        response.Add(\"ErrorMessage\", \"Missing valid Type or Id parameters\");\n    }\n\n    await args.Request.SendResponseAsync(response);\n    messageDeferral.Complete(); // Complete the deferral so that the platform knows that we're done responding to the app service call.\n}",
            "title": "Add Listener support to the App Service"
        },
        {
            "location": "/stories/2/223_AppServices/#enable-microsoftknowzywpf-to-use-the-app-service",
            "text": "Add a Click event to the Menu Menu in Views\\MainView.xaml in the Microsoft.Knowzy.WPF project near line 42.  <MenuItem Header=\"{x:Static localization:Resources.Menu_Menu}\" Template=\"{DynamicResource MenuItemControlTemplate}\" Click=\"Menu_Click\"/>    Add the Menu_Click handler in MainView.xaml.cs in the Microsoft.Knowzy.WPF project.  AppService _appService = null;\n\nprivate async void Menu_Click(object sender, EventArgs e)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        if(_appService == null)\n        {\n            // start the app service\n            _appService = new AppService();\n            var result = await _appService.StartAppServiceConnection(\"com.microsoft.knowzy.appservice.test\");\n        }\n\n        // start the XAML UI that will communicate with the App Service\n        Uri uri = new Uri(\"com.microsoft.knowzy.protocol.test://\" + \"message?appserviceid=\" + \"com.microsoft.knowzy.appservice.test\");\n        await UriProtocol.SendUri(uri);\n    }\n}    This code will open a connection to the Knowzy App Service and will also open the Xaml AppServiceTest page in the UWP portion of Knowzy. The AppServiceTest page will connect to the AppService and send a message\nto the WPF app through the AppService when the use clicks on the Connect button. The WPF app will echo the message and send it back to the UWP app through the App Service.",
            "title": "Enable Microsoft.Knowzy.WPF to use the App Service"
        },
        {
            "location": "/stories/2/223_AppServices/#add-the-new-uri-protocol-to-packageappxmanifest-in-the-microsoftknowzyuwp-project",
            "text": "<uap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\">\n<uap:Protocol Name=\"com.microsoft.knowzy.protocol.test\" />\n</uap:Extension>",
            "title": "Add the new Uri protocol to package.appxmanifest in the Microsoft.Knowzy.UWP project"
        },
        {
            "location": "/stories/2/223_AppServices/#add-the-xaml-ui-page-that-will-communicate-with-the-app-service",
            "text": "Add a new XAML page to Microsoft.Knowzy.UWP project. Name the page AppServiceTest.xaml.    Add some XAML UI elements to AppServiceTest.xaml  <Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" Margin=\"12\">\n    <StackPanel Orientation=\"Vertical\">\n        <TextBox Name=\"textBox\" />\n        <Button Content=\"Connect\" Click=\"Button_Click\" />\n    </StackPanel>\n</Grid>    Modify the OnActivated() method in App.xaml.cs in the Microsoft.Knowzy.UWP project as follows:  protected override void OnActivated(IActivatedEventArgs args)\n{\n    if (args.Kind == ActivationKind.Protocol)\n    {\n        ProtocolActivatedEventArgs eventArgs = args as ProtocolActivatedEventArgs;\n        // TODO: Handle URI activation\n        // The received URI is eventArgs.Uri.AbsoluteUri\n\n        Uri uri = eventArgs.Uri;\n        if (uri.Scheme == \"com.microsoft.knowzy.protocol.3d\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(MainPage), uri.Query);\n            Window.Current.Activate();\n        }\n        else if (uri.Scheme == \"com.microsoft.knowzy.protocol.test\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(AppServiceTest), uri.Query);\n            Window.Current.Activate();\n        }\n    }\n}    Add the following using directive to AppServiceTest.xaml.cs  using Windows.ApplicationModel.AppService;    Add the following properties to the AppServiceTest class:  private String _connectionId;\nprivate AppServiceConnection _connection = null;    Add the uri protocol handler to parse the appserviceid from the uri.  protected override void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        WwwFormUrlDecoder decoder = new WwwFormUrlDecoder(args.Parameter.ToString());\n        try\n        {\n            _connectionId = decoder.GetFirstValueByName(\"appserviceid\");\n        }\n        catch (Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine(\"AppServiceTest OnNavigatedTo Error: \" + ex.Message);\n        }\n    }\n}    Add the Button_Click handler  private async void Button_Click(object sender, RoutedEventArgs e)\n{\n    if (_connection == null)\n    {\n        _connection = new AppServiceConnection();\n\n        // Here, we use the app service name defined in the app service provider's Package.appxmanifest file in the <Extension> section.\n        _connection.AppServiceName = \"com.microsoft.knowzy.appservice\"; ;\n\n        // Use Windows.ApplicationModel.Package.Current.Id.FamilyName within the app service provider to get this value.\n        _connection.PackageFamilyName = Windows.ApplicationModel.Package.Current.Id.FamilyName;\n\n        var status = await _connection.OpenAsync();\n        if (status != AppServiceConnectionStatus.Success)\n        {\n            textBox.Text = \"Failed to connect \" + status;\n            return;\n        }\n    }\n\n    ValueSet data = new ValueSet();\n    data.Add(\"Type\", \"Message\");\n    data.Add(\"Id\", _connectionId);\n    data.Add(\"Data\", \"Message from AppServiceTest XAML UI\");\n    textBox.Text = \"Sending message to App Service connection listener: \" + _connectionId;\n\n    var response = await _connection.SendMessageAsync(data);\n    if (response.Status == AppServiceResponseStatus.Success)\n    {\n        var message = response.Message;\n        bool result = message.ContainsKey(\"Status\") && message[\"Status\"].ToString() == \"OK\";\n        if (result)\n        {\n            var text = message[\"Data\"] as String;\n            textBox.Text = text;\n        }\n    }\n}    Build and run the Knowzy app by starting the Microsoft.Knowzy.Debug project.    Click on the  Menu  menu item.    When the AppServiceTest windows appears, click on the  Connect  button.    The following things should now happen    The UWP app will send a message to the AppService    The AppService wil forward the event to the WPF via its listener connection    The WPF responds to the message and send the result back to the App Service    The App Service returns the result from the WPF app back to the UWP app    The UWP app displays the result it received from the WPF app.       You have now successfully developed a solution for communicating between the UWP and WPF portions of your Desktop Bridge app using an App Service.",
            "title": "Add the XAML ui page that will communicate with the App Service"
        },
        {
            "location": "/stories/2/223_AppServices/#references",
            "text": "Create and consume an app service    App services sample    Adding UWP features to your existing PC software",
            "title": "References"
        },
        {
            "location": "/stories/2/223_AppServices/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/2/231_Inking_Dial/",
            "text": "Task 2.3.1 - Add support for ink\n\n\nOur development department is pleased with the results of \nTask 2.2.2 Add support for other apps to share images with the Knowzy App\n \nthat allowed Knowzy app users to share images from other Windows 10 applications with the Knowzy app. However, we would like Knowzy users to be able\nto annotate the image with the Windows 10 Inking APIs before sharing the image.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 2.2.2\n and all of it's prerequisites\n\n\nTask\n\n\n\n\n\n\nShare an image from another Windows 10 App. The Knowzy app should appear as one of the options for Share Targets.\n\n\n\n\n\n\nDisplay a XAML UI for sharing with the Knowzy app.\n\n\n\n\n\n\nEnable Inking controls on the SharePage to allow the user to annotate the image. Look \nhere\n\nfor some sample code. You will need to add the Win2D.uwp NuGet Package to your UWP project.\n\n\n\n\n\n\nDisplay a Toast that displays the annotated image after the sharing operation has completed.\n\n\n\n\n\n\nComments\n\n\n@ 8:12am\n\n\nOur research has found a starting point for the inking idea \nhere\n\n\n@ 10:43am\n\n\nWe also found sample code for Inking \nhere\n\n\ncontinue to \nnext task >>",
            "title": "231 Inking Dial"
        },
        {
            "location": "/stories/2/231_Inking_Dial/#task-231-add-support-for-ink",
            "text": "Our development department is pleased with the results of  Task 2.2.2 Add support for other apps to share images with the Knowzy App  \nthat allowed Knowzy app users to share images from other Windows 10 applications with the Knowzy app. However, we would like Knowzy users to be able\nto annotate the image with the Windows 10 Inking APIs before sharing the image.",
            "title": "Task 2.3.1 - Add support for ink"
        },
        {
            "location": "/stories/2/231_Inking_Dial/#prerequisites",
            "text": "This task has a dependency on  Task 2.2.2  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/2/231_Inking_Dial/#task",
            "text": "Share an image from another Windows 10 App. The Knowzy app should appear as one of the options for Share Targets.    Display a XAML UI for sharing with the Knowzy app.    Enable Inking controls on the SharePage to allow the user to annotate the image. Look  here \nfor some sample code. You will need to add the Win2D.uwp NuGet Package to your UWP project.    Display a Toast that displays the annotated image after the sharing operation has completed.",
            "title": "Task"
        },
        {
            "location": "/stories/2/231_Inking_Dial/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/2/231_Inking_Dial/#812am",
            "text": "Our research has found a starting point for the inking idea  here",
            "title": "@ 8:12am"
        },
        {
            "location": "/stories/2/231_Inking_Dial/#1043am",
            "text": "We also found sample code for Inking  here",
            "title": "@ 10:43am"
        },
        {
            "location": "/stories/2/231_Inking_Dial/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/2/232_Windows_Hello/",
            "text": "Task 2.3.2 - Complete support for Windows Hello Authentication\n\n\nOur development department is pleased with the results of \nTask 2.1.4 Integrate Windows Hello Authentication\n \nthat prototyped using Windows Hello to log into the Knowzy app if the user was using the Desktop Bridge version of Knowzy. We now want you to\nattempt a more complete implementation.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 2.1.4\n and all of it's prerequisites\n\n\nTask\n\n\n\n\n\n\nImplement a complete solution for Windows Hello.\n\n\n\n\n\n\nImplement a local Windows Hello Server\n\n\n\n\n\n\nUpdate Xaml UI as needed.\n\n\n\n\n\n\nComments\n\n\n@ 8:14am\n\n\nOur research has found a starting point for Windows Hello \nhere\n\n\n@ 10:49am\n\n\nWe also found sample code for Windows Hello \nhere\n\n\ncontinue to \nnext task >>",
            "title": "232 Windows Hello"
        },
        {
            "location": "/stories/2/232_Windows_Hello/#task-232-complete-support-for-windows-hello-authentication",
            "text": "Our development department is pleased with the results of  Task 2.1.4 Integrate Windows Hello Authentication  \nthat prototyped using Windows Hello to log into the Knowzy app if the user was using the Desktop Bridge version of Knowzy. We now want you to\nattempt a more complete implementation.",
            "title": "Task 2.3.2 - Complete support for Windows Hello Authentication"
        },
        {
            "location": "/stories/2/232_Windows_Hello/#prerequisites",
            "text": "This task has a dependency on  Task 2.1.4  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/2/232_Windows_Hello/#task",
            "text": "Implement a complete solution for Windows Hello.    Implement a local Windows Hello Server    Update Xaml UI as needed.",
            "title": "Task"
        },
        {
            "location": "/stories/2/232_Windows_Hello/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/2/232_Windows_Hello/#814am",
            "text": "Our research has found a starting point for Windows Hello  here",
            "title": "@ 8:14am"
        },
        {
            "location": "/stories/2/232_Windows_Hello/#1049am",
            "text": "We also found sample code for Windows Hello  here",
            "title": "@ 10:49am"
        },
        {
            "location": "/stories/2/232_Windows_Hello/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/2/233_Extend/",
            "text": "Task 2.3.3 - Integrate with more UWP APIs\n\n\nNow that we have moved our apps to UWP, we can start taking advantage of some new APIs to light up our app on Windows 10. Time to build on top of what you've already built and differentiate your app.\n\n\nPrerequisites\n\n\nThis task assumes you have completed at least one of the Tasks in 2.2 \n\n\nTask\n\n\nChose one or more from the below APIs to integrate in your app in a meaningful way. You are not limited to the below features - if you find an API or feature is not listed below, ask your proctors if it will satisfy the requirements for this task\n\n\n\n\n\n\nComposition, Animations, and Effects\n\n\n\n\n\n\nUWP Community Toolkit\n\n\n\n\n\n\nDial\n\n\n\n\n\n\nProject Rome\n\n\n\n\n\n\nInking\n\n\n\n\n\n\nDevices/Sensors\n\n\n\n\n\n\nMaps\n\n\n\n\n\n\n...\n\n\n\n\n\n\nResource\n\n\nMake sure to visit the \nGetting Started\n portal for \ndocumentation\n, and check out the \nUWP samples\n for ideas.",
            "title": "233 Extend"
        },
        {
            "location": "/stories/2/233_Extend/#task-233-integrate-with-more-uwp-apis",
            "text": "Now that we have moved our apps to UWP, we can start taking advantage of some new APIs to light up our app on Windows 10. Time to build on top of what you've already built and differentiate your app.",
            "title": "Task 2.3.3 - Integrate with more UWP APIs"
        },
        {
            "location": "/stories/2/233_Extend/#prerequisites",
            "text": "This task assumes you have completed at least one of the Tasks in 2.2",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/2/233_Extend/#task",
            "text": "Chose one or more from the below APIs to integrate in your app in a meaningful way. You are not limited to the below features - if you find an API or feature is not listed below, ask your proctors if it will satisfy the requirements for this task    Composition, Animations, and Effects    UWP Community Toolkit    Dial    Project Rome    Inking    Devices/Sensors    Maps    ...",
            "title": "Task"
        },
        {
            "location": "/stories/2/233_Extend/#resource",
            "text": "Make sure to visit the  Getting Started  portal for  documentation , and check out the  UWP samples  for ideas.",
            "title": "Resource"
        },
        {
            "location": "/stories/3/311_XamarinForms/",
            "text": "Task 3.1.1 - Create a Xamarin.Forms app with shared UI\n\n\nBuilding a cross platform mobile application will help our marketing department reach an even wider audience and potential customers. Xamarin.Forms will allow us to build the application only once and still be able to reach multiple platforms. \n\n\nGoals for this task:\n Mobile application with Shared App running on Android and UWP\n\n\nThis is going to be an entire new product for Knowzy and we will start from scratch. We've already done some investigation from the requirements that our management has given us and we have written a guide for the developer on how to get started.\n\n\nPrerequisites\n\n\nThis walkthrough assumes that you have:\n\n Windows 10 Creators Update\n\n Visual Studio 2017 with the Mobile Development with .NET workload the Universal Windows Platform development workload installed. If not, make sure you \ndo that first\n and then come back here.\n\n\nTask\n\n\nStart by creating a new Xamarin.Forms application\n\n\n\n\n\n\nIn Visual Studio, click on \nFile -> New -> Project\n. \n\n\n\n\n\n\nUnder \nTemplates -> Visual C# -> Cross-Platform\n select \nCross Platform App (Xamarin.Forms or Native)\n. Pick a name and Create the project\n    > Note: pick a short name and place the project closer to the root of your drive (ex: c:\\source) in order to avoid long names that might cause issues later when running your project\n\n\n\n\n\n\nWe will start with a Blank App. Make sure Xamarin.Forms is selected under \nUI Technology\n and Shared Project under \nCode Sharing Strategy\n\n\n\n\n\n\n\n\n\n\nNote: A \nXamarin Mac Agent\n window might open asking you to connect to a Mac as soon as you create the project. You can safely ignore and close this window.\n\n\nNote: A \nNew Universal Windows Project\n might open asking you to choose target and minimum platform version. Make sure \nTarget Version\n is \nWindows 10 Creators Update\n. Minimum version can be anything.\n\n\n\n\n![New UWP](images/new_uwp.png)\n\n\n\nThat's it. At this point, you should probably spend some time checking out the new solution. You will notice there are four projects in the solution, one shared project and three platform specific projects. To run the app on the specific platform, use the drop down at the top of Visual Studio to select what project to run:\n\n\n\n\nWe will focus on UWP and Android for our first release. To run on your machine as UWP, select the UWP project first. Then change the architecture (the dropdown on the left of the Startup projects dropdown) and select x86 or x64. Then simply click the play button to build and run the app:\n\n\n\n\nTo test and debug the app on Andorid, there are several options:\n\n\n\n\n\n\nUse the Android SDK Emulator\n\n\n\n\n\n\nUse the Visual Studio Emulator\n\n\n\n\n\n\nUse a real device\n\n\n\n\n\n\n\n\nNote: If you try to run the faster x86 version of the Android SDK Emulator and get an exception, you might need to turn of the hypervisor by running the following command in Command Prompt as Administrator: \nbcdedit /set hypervisorlaunchtype off\n and reboot\n\n\n\n\nChange the Startup Project to the Android project and use the dropdown on the right to select the emulator (or device). Then click the play icon to build and run in the emulator.\n\n\n\n\nNow get to know your new app.\n\n\n\n\nNote: Since we will not be using the iOS project for this release, feel free to remove it from your solution\n\n\n\n\nAdd shared Business Logic\n\n\nFor our first task, we want to be able to list all the different Knowzy products. Fortunately, there is already a public feed for all products that we can use located \nhere\n. We can use this to get all of the data for our app. \n\n\n\n\n\n\nLet's create a new class that we can use to represent our nose model. Right click on the Shared project (the one without a platform specifier at the end) and click \nAdd -> Class\n:\n\n\n\n\nName the new class \nNose\n. Erase everything between the namespace definition. We need our new class to match the data we get from our JSON feed, so we will create a new class from the JSON. Copy this JSON but don't paste it anywhere yet:\n\n\n{\n    \"Id\": \"RN3454\",\n    \"Name\": \"Black Nose\",\n    \"RawMaterial\": \"Black foam\",\n    \"Notes\": \"Everything you'd expect, and a little something more.\",\n    \"Image\": \"https://raw.githubusercontent.com/Knowzy/KnowzyInternalApps/master/src/Noses/Frabicnose400x300.jpg\"\n}\n\n\n\nSwitch to Visual Studio, place the cursor where you want to copy the new class (between the namespace braces). In Visual Studio, click on \nEdit -> Paste Special -> Paste JSON as Classes\n. This will generate a new class for you by using the JSON you just copied and you just need to change the name from RootObject to \nNose\n.\n\n\n\n\n\n\n\n\nNow that we have our model, let's create a way to retrieve the data from our feed. \n\n\n\n\n\n\nFirst, we will use Json.Net to deserialize the JSON, so you will need to first reference the Nuget package to both the UWP and Android project. Right click on each project, click on \nManage Nuget Packages\n. Search for \nNewtonsoft.Json\n and install it (make sure to switch to the \nBrowse\n tab when searching).\n\n\n\n\n\n\nFollow the same steps as above to create a new class in the shared project. \n\n\n\n\nName the new class \nDataProvider\n\n\nMake the class public. \n\n\n\n\nAdd this static method in the class to pull in the data from the link above:\n\n\npublic static async Task<Nose[]> GetProducts()\n{\n    using (var client = new HttpClient())\n    {\n        var json = await client.GetStringAsync(\"https://raw.githubusercontent.com/Knowzy/KnowzyInternalApps/master/src/Noses/noses.json\");\n\n        return JsonConvert.DeserializeObject<Nose[]>(json);\n    }\n}\n\n\n\nYou will need to add few namespaces for this function to work:\n\n\nusing Newtonsoft.Json;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\n\n\n\n\n\n\n\n\n\n\nWe now have a static method that retrieves the JSON feed and deserializes into Nose objects that we can use in out app.\n\n\nAdd shared UI\n\n\nNow that we have the business logic out of the way, on to the UI. Xamarin.Forms uses XAML to define the shared UI, so if you've used XAML before, you will feel right at home. All the shared code is in the shared project in the solution, and there is already a page created for us: MainPage.xaml. Go ahead and open the page. Currently there is only one element there, a \nLabel\n. Instead of a Label, we will use a \nListView\n to display all of the products.\n\n\n\n\n\n\nRemove the Label and add a new element ListView instead. Give it a name. In this case it's \nProductListView\n*\n\n\n<ListView x:Name=\"ProductListView\">\n\n</ListView>\n\n\n\n\n\n\n\nOpen MainPage.xaml.cs. This is where the code goes for your view. Here we can override the \nOnAppearing\n method which will allows us to get the list of products and set them as the source of the ListView. Add the following code:\n\n\n    protected async override void OnAppearing()\n    {\n        base.OnAppearing();\n        ProductListView.ItemsSource = await DataProvider.GetProducts();\n    }\n\n\n\n\n\n\n\nFinally, we need to define how each product will look like. For that we will create a data template to customize each \nCell\n. Here is what the final XAML looks like for the ListView\n\n\n<ListView x:Name=\"ProductListView\">\n    <ListView.ItemTemplate>\n        <DataTemplate>\n            <ViewCell>\n                <StackLayout Orientation=\"Horizontal\">\n                    <Image Source=\"{Binding Image}\" HeightRequest=\"150\" WidthRequest=\"150\"></Image>\n                    <Label Text=\"{Binding Name}\"></Label>\n                </StackLayout>\n            </ViewCell>\n        </DataTemplate>\n    </ListView.ItemTemplate>\n</ListView>\n\n\n\n\n\n\n\nTask Complete\n. Go ahead and run the the app on your machine and run the app in the Android emulator.\n\n\n\n\nGo to the next Task\n where you will add another page and the capability to capture an image by using APIs specific to each platform.\n\n\nResources\n\n\n\n\nXamarin.Forms Quickstart\n\n\nIntroduction to Xamarin.Forms\n\n\nXamarin.Forms XAML documentation\n\n\n\n\ncontinue to \nnext task >>",
            "title": "311 XamarinForms"
        },
        {
            "location": "/stories/3/311_XamarinForms/#task-311-create-a-xamarinforms-app-with-shared-ui",
            "text": "Building a cross platform mobile application will help our marketing department reach an even wider audience and potential customers. Xamarin.Forms will allow us to build the application only once and still be able to reach multiple platforms.   Goals for this task:  Mobile application with Shared App running on Android and UWP  This is going to be an entire new product for Knowzy and we will start from scratch. We've already done some investigation from the requirements that our management has given us and we have written a guide for the developer on how to get started.",
            "title": "Task 3.1.1 - Create a Xamarin.Forms app with shared UI"
        },
        {
            "location": "/stories/3/311_XamarinForms/#prerequisites",
            "text": "This walkthrough assumes that you have:  Windows 10 Creators Update  Visual Studio 2017 with the Mobile Development with .NET workload the Universal Windows Platform development workload installed. If not, make sure you  do that first  and then come back here.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/311_XamarinForms/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/3/311_XamarinForms/#start-by-creating-a-new-xamarinforms-application",
            "text": "In Visual Studio, click on  File -> New -> Project .     Under  Templates -> Visual C# -> Cross-Platform  select  Cross Platform App (Xamarin.Forms or Native) . Pick a name and Create the project\n    > Note: pick a short name and place the project closer to the root of your drive (ex: c:\\source) in order to avoid long names that might cause issues later when running your project    We will start with a Blank App. Make sure Xamarin.Forms is selected under  UI Technology  and Shared Project under  Code Sharing Strategy      Note: A  Xamarin Mac Agent  window might open asking you to connect to a Mac as soon as you create the project. You can safely ignore and close this window.  Note: A  New Universal Windows Project  might open asking you to choose target and minimum platform version. Make sure  Target Version  is  Windows 10 Creators Update . Minimum version can be anything.   ![New UWP](images/new_uwp.png)  That's it. At this point, you should probably spend some time checking out the new solution. You will notice there are four projects in the solution, one shared project and three platform specific projects. To run the app on the specific platform, use the drop down at the top of Visual Studio to select what project to run:   We will focus on UWP and Android for our first release. To run on your machine as UWP, select the UWP project first. Then change the architecture (the dropdown on the left of the Startup projects dropdown) and select x86 or x64. Then simply click the play button to build and run the app:   To test and debug the app on Andorid, there are several options:    Use the Android SDK Emulator    Use the Visual Studio Emulator    Use a real device     Note: If you try to run the faster x86 version of the Android SDK Emulator and get an exception, you might need to turn of the hypervisor by running the following command in Command Prompt as Administrator:  bcdedit /set hypervisorlaunchtype off  and reboot   Change the Startup Project to the Android project and use the dropdown on the right to select the emulator (or device). Then click the play icon to build and run in the emulator.   Now get to know your new app.   Note: Since we will not be using the iOS project for this release, feel free to remove it from your solution",
            "title": "Start by creating a new Xamarin.Forms application"
        },
        {
            "location": "/stories/3/311_XamarinForms/#add-shared-business-logic",
            "text": "For our first task, we want to be able to list all the different Knowzy products. Fortunately, there is already a public feed for all products that we can use located  here . We can use this to get all of the data for our app.     Let's create a new class that we can use to represent our nose model. Right click on the Shared project (the one without a platform specifier at the end) and click  Add -> Class :   Name the new class  Nose . Erase everything between the namespace definition. We need our new class to match the data we get from our JSON feed, so we will create a new class from the JSON. Copy this JSON but don't paste it anywhere yet:  {\n    \"Id\": \"RN3454\",\n    \"Name\": \"Black Nose\",\n    \"RawMaterial\": \"Black foam\",\n    \"Notes\": \"Everything you'd expect, and a little something more.\",\n    \"Image\": \"https://raw.githubusercontent.com/Knowzy/KnowzyInternalApps/master/src/Noses/Frabicnose400x300.jpg\"\n}  Switch to Visual Studio, place the cursor where you want to copy the new class (between the namespace braces). In Visual Studio, click on  Edit -> Paste Special -> Paste JSON as Classes . This will generate a new class for you by using the JSON you just copied and you just need to change the name from RootObject to  Nose .     Now that we have our model, let's create a way to retrieve the data from our feed.     First, we will use Json.Net to deserialize the JSON, so you will need to first reference the Nuget package to both the UWP and Android project. Right click on each project, click on  Manage Nuget Packages . Search for  Newtonsoft.Json  and install it (make sure to switch to the  Browse  tab when searching).    Follow the same steps as above to create a new class in the shared project.    Name the new class  DataProvider  Make the class public.    Add this static method in the class to pull in the data from the link above:  public static async Task<Nose[]> GetProducts()\n{\n    using (var client = new HttpClient())\n    {\n        var json = await client.GetStringAsync(\"https://raw.githubusercontent.com/Knowzy/KnowzyInternalApps/master/src/Noses/noses.json\");\n\n        return JsonConvert.DeserializeObject<Nose[]>(json);\n    }\n}  You will need to add few namespaces for this function to work:  using Newtonsoft.Json;\nusing System.Net.Http;\nusing System.Threading.Tasks;      We now have a static method that retrieves the JSON feed and deserializes into Nose objects that we can use in out app.",
            "title": "Add shared Business Logic"
        },
        {
            "location": "/stories/3/311_XamarinForms/#add-shared-ui",
            "text": "Now that we have the business logic out of the way, on to the UI. Xamarin.Forms uses XAML to define the shared UI, so if you've used XAML before, you will feel right at home. All the shared code is in the shared project in the solution, and there is already a page created for us: MainPage.xaml. Go ahead and open the page. Currently there is only one element there, a  Label . Instead of a Label, we will use a  ListView  to display all of the products.    Remove the Label and add a new element ListView instead. Give it a name. In this case it's  ProductListView *  <ListView x:Name=\"ProductListView\">\n\n</ListView>    Open MainPage.xaml.cs. This is where the code goes for your view. Here we can override the  OnAppearing  method which will allows us to get the list of products and set them as the source of the ListView. Add the following code:      protected async override void OnAppearing()\n    {\n        base.OnAppearing();\n        ProductListView.ItemsSource = await DataProvider.GetProducts();\n    }    Finally, we need to define how each product will look like. For that we will create a data template to customize each  Cell . Here is what the final XAML looks like for the ListView  <ListView x:Name=\"ProductListView\">\n    <ListView.ItemTemplate>\n        <DataTemplate>\n            <ViewCell>\n                <StackLayout Orientation=\"Horizontal\">\n                    <Image Source=\"{Binding Image}\" HeightRequest=\"150\" WidthRequest=\"150\"></Image>\n                    <Label Text=\"{Binding Name}\"></Label>\n                </StackLayout>\n            </ViewCell>\n        </DataTemplate>\n    </ListView.ItemTemplate>\n</ListView>    Task Complete . Go ahead and run the the app on your machine and run the app in the Android emulator.   Go to the next Task  where you will add another page and the capability to capture an image by using APIs specific to each platform.",
            "title": "Add shared UI"
        },
        {
            "location": "/stories/3/311_XamarinForms/#resources",
            "text": "Xamarin.Forms Quickstart  Introduction to Xamarin.Forms  Xamarin.Forms XAML documentation",
            "title": "Resources"
        },
        {
            "location": "/stories/3/311_XamarinForms/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/3/312_Camera/",
            "text": "Task 3.1.2 - Capture Images\n\n\nOur marketing department has the idea to allow our app users to capture images and position Knowzy products over the image to see what how they would look like. It's a fun way to try the product without actually buying it, and the marketing department is hoping for these images to be shared on social media and spread the word.\n\n\nGoals for this task:\n Capture image from camera on Android and UWP\n\n\nFor this task, you will need to access APIs that are specific for each platform. We've done the research on how to do it and we've included the steps below.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 3.1.1\n and all of it's prerequisites\n\n\nTask\n\n\nCreate and navigate to a new page\n\n\n\n\n\n\nRight click on the Shared project, go to \nAdd -> New Item\n. Under \nVisual C# -> Cross-Platform\n select \nForms Blank Content Page Xaml\n. Give it a name (we use CameraPage in this guide) and click Add. This will create a new Page where you can navigate to once a product has been selected on the Main page. \n\n\n\n\n\n\nThere are \nmultiple ways to navigate between pages\n. In this example, we will use a \nNavigationPage\n to act as a host for our pages and provide hierarchical navigation. Open App.xaml.cs in the Shared project. Notice the constructor sets the MainPage to a new MainPage (the default page when the app is created):\n\n\nMainPage = new Knowzy.Mobile.MainPage();\n\n\n\n\n\nNote: the \nKnowzy.Mobile\n namespace above might be different for you depending on what you named your project\n\n\n\n\nInstead of setting the MainPage to a new MainPage, set it to a new NavigationPage and pass a new MainPage as a parameter which will set it as the first page in our hierarchical navigation.\n\n\nMainPage = new NavigationPage(new MainPage());\n\n\n\n\n\n\n\nYou are now ready to navigate to the new page. We want to navigate to the new page when a product (nose) is clicked in the main page and we want to pass the nose as a parameter. The easiest way to do that is to pass the clicked nose as a parameter to the constructor when navigating to the new page. Open the code behind of the new page you created (CameraPage in our example) and modify the constructor to accept a parameter of type Nose.\n\n\nNose _nose;\n\npublic CameraPage(Nose nose)\n{\n    _nose = nose;\n    InitializeComponent ();\n}\n\n\n\n\n\n\n\nOpen the xaml file for the main page and add an ItemTapped event handler for when an item has been taped on the ListView.\n\n\n<ListView x:Name=\"ProductListView\" ItemTapped=\"ProductListViewItemTapped\">\n    <!-- ... -->\n</ListView>\n\n\n\n\n\n\n\nIn the code behind for the main page (MainPage.xaml.cs), implement the event handler and add the code to navigate to the new page by passing the taped item\n\n\nprivate void ProductListViewItemTapped(object sender, ItemTappedEventArgs e)\n{\n    Navigation.PushAsync(new CameraPage(e.Item as Nose));\n}\n\n\n\n\n\n\n\nThat's it. Test it out to make sure it all works as expected and you can navigate to the new (but empty) page.\n\n\nCapture image from camera on Android and UWP\n\n\nOnce we've navigated to the new page, the goal is to capture an image from the camera. Because each platform has a different native API for camera capture, we will create an interface that we will implement on each platform. We will then use the \nDependencyService\n from Xamarin.Forms to call the right implementation.\n\n\n\n\n\n\nCreate a new interface class in the Shared Project and change it to an interface called \nIPhotoService\n (Right Click on Shared Project -> Add -> Class). Add a method definition for capturing the photo. It should look like this:\n\n\npublic interface IPhotoService\n{\n    Task<ImageSource> TakePhotoAsync();\n}\n\n\n\nYou will need to add few namespaces:\n\n\nusing System.Threading.Tasks;\nusing Xamarin.Forms;\n\n\n\n\n\n\n\nYou now need to implement this interface for each platform to use the native APIs. Let's start with UWP.\n\n\n\n\n\n\nIn the UWP project, create a new class and call it PhotoService. Extend IPhotoService and register with the DependencyService by adding a metadata attribute above the namespace. The class would look like this:\n\n\nusing Xamarin.Forms;\nusing YourNamespace.UWP;\n\n[assembly: Dependency(typeof(PhotoService))]\nnamespace YourNamespace.UWP\n{\n    public class PhotoService : IPhotoService\n    {\n        public async Task<ImageSource> TakePhotoAsync()\n        {\n\n        }\n    }\n}\n\n\n\n\n\n\n\nImplement the TakePhotoAsync method to use the native \nCameraCaptureUI\n from UWP and make it async:\n\n\npublic Task<ImageSource> TakePhotoAsync()\n{\n    CameraCaptureUI captureUI = new CameraCaptureUI();\n    captureUI.PhotoSettings.Format = CameraCaptureUIPhotoFormat.Jpeg;\n\n    StorageFile photo = await captureUI.CaptureFileAsync(CameraCaptureUIMode.Photo);\n\n    if (photo == null) return null;\n\n    return ImageSource.FromFile(photo.Path);\n}\n\n\n\nYou will need few namespaces:\n\n\nusing Windows.Media.Capture;\nusing Windows.Storage;\n\n\n\n\n\n\n\nThat's all for UWP\n\n\n\n\n\n\nImplementing the Android version is a bit more complicated because it requires the use of Android intents. \n\n\n\n\n\n\nOpen MainActivity.cs in the Android project. This file is the entry point for the Android application. Create a new static readonly property of type \nFile\n to store the captured image and create a new method to start the new Image Capture intent to place the results in a the new file:\n\n\nstatic readonly File file = \n    new File(Android.OS.Environment.GetExternalStoragePublicDirectory(\n        Android.OS.Environment.DirectoryPictures), \"tmp.jpg\");\n\npublic void StartMediaCaptureActivity()\n{\n    var intent = new Intent(MediaStore.ActionImageCapture);\n    intent.PutExtra(MediaStore.ExtraOutput, Android.Net.Uri.FromFile(file));\n    StartActivityForResult(intent, 0);\n}\n\n\n\nAdd these namespaces: \n\n\nusing Java.IO;\nusing Android.Content;\nusing Android.Provider;\n\n\n\n\n\n\n\nNext, in the same file, override the OnActivityResult method to respond when the intent has completed and the image has been captured. In addition create a new event as part of the MainActivity so we can subscribe later to be notified when the image has been captured.\n\n\npublic event EventHandler<File> ImageCaptured;\n\nprotected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n    if (requestCode == 0 && resultCode == Result.Ok)\n    {\n        ImageCaptured?.Invoke(this, file);\n    }\n}\n\n\n\n\n\n\n\nJust like in the UWP project, create a new class in the Android project and call it PhotoService. Extend IPhotoService and register with the DependencyService by adding a metadata attribute above the namespace. The class would look like this:\n\n\nusing Xamarin.Forms;\nusing System.Threading.Tasks;\nusing YourNamespace.Droid;\n\n[assembly: Dependency(typeof(PhotoService))]\nnamespace YourNamespace.Droid\n{\n    public class PhotoService : IPhotoService\n    {\n        public Task<ImageSource> TakePhotoAsync()\n        {\n\n        }\n    }\n}\n\n\n\n\n\nNote: your namespace for Android might be \nDroid\n or \nAndroid\n\n\n\n\n\n\n\n\nYou are now ready to implement the Android version of the TakePhotoAsync method. In the method, (1) call the StartMediaCaptureActivity you created in MainActivity, (2) create an event handler to listen to when the image has been captured, and (3) create a TaskCompletionSource that will complete once the image has been captured and the event has fired. It should look like something like this:\n\n\npublic Task<ImageSource> TakePhotoAsync()\n{\n    var mainActivity = Forms.Context as MainActivity;\n    var tcs = new TaskCompletionSource<ImageSource>();\n    EventHandler<Java.IO.File> handler = null;\n    handler = (s, e) =>\n    {\n        tcs.SetResult(e.Path);\n        mainActivity.ImageCaptured -= handler;\n    };\n\n    mainActivity.ImageCaptured += handler;\n    mainActivity.StartMediaCaptureActivity();\n    return tcs.Task;\n}\n\n\n\n\n\n\n\nYou are now done with Android.\n\n\n\n\n\n\nTime to use the PhotoService. In the new page you created (CameraPage.xaml in this example), create a new Button and a new Image element to host the capture image. Create an event handler for the button when clicked.\n\n\n<StackLayout VerticalOptions=\"FillAndExpand\"\n                HorizontalOptions=\"FillAndExpand\"\n                Orientation=\"Vertical\"\n                Spacing=\"15\">\n    <Button x:Name=\"captureButton\" \n            Text=\"Capture Image\" \n            Clicked=\"captureButton_Clicked\"></Button>\n    <Image x:Name=\"image\"></Image>\n</StackLayout>\n\n\n\n\n\n\n\nIn the event handler, create an instance of the PhotoService via the DependencyService and call the TakePhotoAsync to capture an image. Once the image is captured, set the source of the image:\n\n\nprivate async void captureButton_Clicked(object sender, EventArgs e)\n{\n    var photoService = DependencyService.Get<IPhotoService>();\n    if(photoService != null)\n    {\n        var source = await photoService.TakePhotoAsync();\n        image.Source = source;\n    }\n}\n\n\n\n\n\n\n\nThat's it, run the app and try it out. You should be able to navigate to the new page once you click on a nose. There should be a button to capture an image that will open the platform specific UI for capturing images. Once the image is captured, it should display the image  below the button.\n\n\nGo to the next Task\n where you will extend this page to overlay the noses on top of the image and add Inking capabilities on Windows.\n\n\ncontinue to \nnext task >>",
            "title": "312 Camera"
        },
        {
            "location": "/stories/3/312_Camera/#task-312-capture-images",
            "text": "Our marketing department has the idea to allow our app users to capture images and position Knowzy products over the image to see what how they would look like. It's a fun way to try the product without actually buying it, and the marketing department is hoping for these images to be shared on social media and spread the word.  Goals for this task:  Capture image from camera on Android and UWP  For this task, you will need to access APIs that are specific for each platform. We've done the research on how to do it and we've included the steps below.",
            "title": "Task 3.1.2 - Capture Images"
        },
        {
            "location": "/stories/3/312_Camera/#prerequisites",
            "text": "This task has a dependency on  Task 3.1.1  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/312_Camera/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/3/312_Camera/#create-and-navigate-to-a-new-page",
            "text": "Right click on the Shared project, go to  Add -> New Item . Under  Visual C# -> Cross-Platform  select  Forms Blank Content Page Xaml . Give it a name (we use CameraPage in this guide) and click Add. This will create a new Page where you can navigate to once a product has been selected on the Main page.     There are  multiple ways to navigate between pages . In this example, we will use a  NavigationPage  to act as a host for our pages and provide hierarchical navigation. Open App.xaml.cs in the Shared project. Notice the constructor sets the MainPage to a new MainPage (the default page when the app is created):  MainPage = new Knowzy.Mobile.MainPage();   Note: the  Knowzy.Mobile  namespace above might be different for you depending on what you named your project   Instead of setting the MainPage to a new MainPage, set it to a new NavigationPage and pass a new MainPage as a parameter which will set it as the first page in our hierarchical navigation.  MainPage = new NavigationPage(new MainPage());    You are now ready to navigate to the new page. We want to navigate to the new page when a product (nose) is clicked in the main page and we want to pass the nose as a parameter. The easiest way to do that is to pass the clicked nose as a parameter to the constructor when navigating to the new page. Open the code behind of the new page you created (CameraPage in our example) and modify the constructor to accept a parameter of type Nose.  Nose _nose;\n\npublic CameraPage(Nose nose)\n{\n    _nose = nose;\n    InitializeComponent ();\n}    Open the xaml file for the main page and add an ItemTapped event handler for when an item has been taped on the ListView.  <ListView x:Name=\"ProductListView\" ItemTapped=\"ProductListViewItemTapped\">\n    <!-- ... -->\n</ListView>    In the code behind for the main page (MainPage.xaml.cs), implement the event handler and add the code to navigate to the new page by passing the taped item  private void ProductListViewItemTapped(object sender, ItemTappedEventArgs e)\n{\n    Navigation.PushAsync(new CameraPage(e.Item as Nose));\n}    That's it. Test it out to make sure it all works as expected and you can navigate to the new (but empty) page.",
            "title": "Create and navigate to a new page"
        },
        {
            "location": "/stories/3/312_Camera/#capture-image-from-camera-on-android-and-uwp",
            "text": "Once we've navigated to the new page, the goal is to capture an image from the camera. Because each platform has a different native API for camera capture, we will create an interface that we will implement on each platform. We will then use the  DependencyService  from Xamarin.Forms to call the right implementation.    Create a new interface class in the Shared Project and change it to an interface called  IPhotoService  (Right Click on Shared Project -> Add -> Class). Add a method definition for capturing the photo. It should look like this:  public interface IPhotoService\n{\n    Task<ImageSource> TakePhotoAsync();\n}  You will need to add few namespaces:  using System.Threading.Tasks;\nusing Xamarin.Forms;    You now need to implement this interface for each platform to use the native APIs. Let's start with UWP.    In the UWP project, create a new class and call it PhotoService. Extend IPhotoService and register with the DependencyService by adding a metadata attribute above the namespace. The class would look like this:  using Xamarin.Forms;\nusing YourNamespace.UWP;\n\n[assembly: Dependency(typeof(PhotoService))]\nnamespace YourNamespace.UWP\n{\n    public class PhotoService : IPhotoService\n    {\n        public async Task<ImageSource> TakePhotoAsync()\n        {\n\n        }\n    }\n}    Implement the TakePhotoAsync method to use the native  CameraCaptureUI  from UWP and make it async:  public Task<ImageSource> TakePhotoAsync()\n{\n    CameraCaptureUI captureUI = new CameraCaptureUI();\n    captureUI.PhotoSettings.Format = CameraCaptureUIPhotoFormat.Jpeg;\n\n    StorageFile photo = await captureUI.CaptureFileAsync(CameraCaptureUIMode.Photo);\n\n    if (photo == null) return null;\n\n    return ImageSource.FromFile(photo.Path);\n}  You will need few namespaces:  using Windows.Media.Capture;\nusing Windows.Storage;    That's all for UWP    Implementing the Android version is a bit more complicated because it requires the use of Android intents.     Open MainActivity.cs in the Android project. This file is the entry point for the Android application. Create a new static readonly property of type  File  to store the captured image and create a new method to start the new Image Capture intent to place the results in a the new file:  static readonly File file = \n    new File(Android.OS.Environment.GetExternalStoragePublicDirectory(\n        Android.OS.Environment.DirectoryPictures), \"tmp.jpg\");\n\npublic void StartMediaCaptureActivity()\n{\n    var intent = new Intent(MediaStore.ActionImageCapture);\n    intent.PutExtra(MediaStore.ExtraOutput, Android.Net.Uri.FromFile(file));\n    StartActivityForResult(intent, 0);\n}  Add these namespaces:   using Java.IO;\nusing Android.Content;\nusing Android.Provider;    Next, in the same file, override the OnActivityResult method to respond when the intent has completed and the image has been captured. In addition create a new event as part of the MainActivity so we can subscribe later to be notified when the image has been captured.  public event EventHandler<File> ImageCaptured;\n\nprotected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n    if (requestCode == 0 && resultCode == Result.Ok)\n    {\n        ImageCaptured?.Invoke(this, file);\n    }\n}    Just like in the UWP project, create a new class in the Android project and call it PhotoService. Extend IPhotoService and register with the DependencyService by adding a metadata attribute above the namespace. The class would look like this:  using Xamarin.Forms;\nusing System.Threading.Tasks;\nusing YourNamespace.Droid;\n\n[assembly: Dependency(typeof(PhotoService))]\nnamespace YourNamespace.Droid\n{\n    public class PhotoService : IPhotoService\n    {\n        public Task<ImageSource> TakePhotoAsync()\n        {\n\n        }\n    }\n}   Note: your namespace for Android might be  Droid  or  Android     You are now ready to implement the Android version of the TakePhotoAsync method. In the method, (1) call the StartMediaCaptureActivity you created in MainActivity, (2) create an event handler to listen to when the image has been captured, and (3) create a TaskCompletionSource that will complete once the image has been captured and the event has fired. It should look like something like this:  public Task<ImageSource> TakePhotoAsync()\n{\n    var mainActivity = Forms.Context as MainActivity;\n    var tcs = new TaskCompletionSource<ImageSource>();\n    EventHandler<Java.IO.File> handler = null;\n    handler = (s, e) =>\n    {\n        tcs.SetResult(e.Path);\n        mainActivity.ImageCaptured -= handler;\n    };\n\n    mainActivity.ImageCaptured += handler;\n    mainActivity.StartMediaCaptureActivity();\n    return tcs.Task;\n}    You are now done with Android.    Time to use the PhotoService. In the new page you created (CameraPage.xaml in this example), create a new Button and a new Image element to host the capture image. Create an event handler for the button when clicked.  <StackLayout VerticalOptions=\"FillAndExpand\"\n                HorizontalOptions=\"FillAndExpand\"\n                Orientation=\"Vertical\"\n                Spacing=\"15\">\n    <Button x:Name=\"captureButton\" \n            Text=\"Capture Image\" \n            Clicked=\"captureButton_Clicked\"></Button>\n    <Image x:Name=\"image\"></Image>\n</StackLayout>    In the event handler, create an instance of the PhotoService via the DependencyService and call the TakePhotoAsync to capture an image. Once the image is captured, set the source of the image:  private async void captureButton_Clicked(object sender, EventArgs e)\n{\n    var photoService = DependencyService.Get<IPhotoService>();\n    if(photoService != null)\n    {\n        var source = await photoService.TakePhotoAsync();\n        image.Source = source;\n    }\n}    That's it, run the app and try it out. You should be able to navigate to the new page once you click on a nose. There should be a button to capture an image that will open the platform specific UI for capturing images. Once the image is captured, it should display the image  below the button.  Go to the next Task  where you will extend this page to overlay the noses on top of the image and add Inking capabilities on Windows.",
            "title": "Capture image from camera on Android and UWP"
        },
        {
            "location": "/stories/3/312_Camera/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/3/313_InkCanvas/",
            "text": "Task 3.1.3 - Overlay noses and support inking for UWP\n\n\nOur marketing department has the idea to allow our app users to capture images and position Knowzy products over the image to see what how they would look like. It's a fun way to try the product without actually buying it, and the marketing department is hoping for these images to be shared on social media and spread the word.\n\n\nGoals for this task:\n\n\n Overlay noses on top of image and allow nose to be manipulated\n\n Support inking on UWP devices\n\n\nFor this task, you will need to access APIs that are specific for each platform. We've done the research on how to do it and we've included the steps below.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 3.1.2\n and all of it's prerequisites\n\n\nTask\n\n\nOverlay nose on image and allow to be manipulated\n\n\nOnce the image is captured, let's add the nose image on top and allow the user to move it by panning and resize it by pinching.\n\n\n\n\n\n\nOpen the xaml page you added in the previous task (CameraPage.xaml in this example), and wrap the image element hosting the camera image in a new Grid element. This will allow you to have multiple elements on top of each other. In addition, add a new \nAbsoluteLayout\n element in the grid below the existing Image. Inside the AbsoluteLayout add a new image element used for hosting the nose image. Here is what the final result will look like:\n\n\nBefore:\n\n\n<Image x:Name=\"image\"></Image>\n\n\n\nAfter:\n\n\n<Grid x:Name=\"imageGrid\" IsVisible=\"False\">\n    <Image x:Name=\"image\"></Image>\n    <AbsoluteLayout>\n        <Image x:Name=\"noseImage\"\n            HeightRequest=\"120\" \n            WidthRequest=\"120\" \n            AbsoluteLayout.LayoutBounds=\"0, 0, AutoSize, AutoSize\" \n            AbsoluteLayout.LayoutFlags=\"None\">\n        </Image>\n    </AbsoluteLayout>\n</Grid>\n\n\n\n\n\n\n\nNotice in the xaml above, we've set the visibility of the Grid to False. Once the image has been captured, we can set the visibility to visible and set the source of the noseImage. Here is what the new captureButton click handler looks like:\n\n\nprivate async void captureButton_Clicked(object sender, EventArgs e)\n{\n    var photoService = DependencyService.Get<IPhotoService>();\n    if (photoService != null)\n    {\n        var source = await photoService.TakePhotoAsync();\n        noseImage.Source = ImageSource.FromUri(new Uri(_nose.Image)); // set source of nose image\n        image.Source = source;\n        imageGrid.IsVisible = true; // set visibility to true\n    }\n}\n\n\n\n\n\n\n\nTo allow the elements to be manipulated by panning or pinching, Xamarin.Forms has built in \nGestures\n. As part of the nose image that we added to our page, let's add a new PanGestureRecognizer and a new PinchGestureRecognizer and subscribe to the relevant events so we can manipulate the nose image with gestures:\n\n\n<Image x:Name=\"noseImage\"\n        HeightRequest=\"120\" \n        WidthRequest=\"120\" \n        AbsoluteLayout.LayoutBounds=\"0, 0, AutoSize, AutoSize\" \n        AbsoluteLayout.LayoutFlags=\"None\">\n\n    <!-- Gesture Recongizers -->\n    <Image.GestureRecognizers>\n        <PanGestureRecognizer PanUpdated=\"OnPanUpdated\" />\n        <PinchGestureRecognizer PinchUpdated=\"OnPinchUpdated\" />\n    </Image.GestureRecognizers>\n\n</Image>\n\n\n\n\n\n\n\nIn your code behind, implement the event handlers for the gestures we added to our xaml. The nose moves with the finger or mouse, and when pinching, the scale of the image changes appropriately:\n\n\nprivate void OnPanUpdated(object sender, PanUpdatedEventArgs e)\n{\n    switch (e.StatusType)\n    {\n        case GestureStatus.Started:\n            var bounds = AbsoluteLayout.GetLayoutBounds(noseImage);\n            bounds.X += noseImage.TranslationX;\n            bounds.Y += noseImage.TranslationY;\n            AbsoluteLayout.SetLayoutBounds(noseImage, bounds);\n            noseImage.TranslationX = 0;\n            noseImage.TranslationY = 0;\n            break;\n\n        case GestureStatus.Running:\n            noseImage.TranslationX = e.TotalX;\n            noseImage.TranslationY = e.TotalY;\n            break;\n    }\n}\n\nprivate void OnPinchUpdated(object sender, PinchGestureUpdatedEventArgs e)\n{\n    switch (e.Status)\n    {\n        case GestureStatus.Running:\n            noseImage.Scale *= e.Scale;\n            break;\n    }\n}\n\n\n\n\n\n\n\nThat's all. Run the app, take a photo, position the nose and have fun.\n\n\nAdding inking support on UWP devices.\n\n\nIn addition to using the built in Xamarin.Forms controls, developers have full access to native platform controls as well through \nnative view declaration\n. This allows developers to use native  or custom control (such as the UWP Community Toolkit) and mix them with Xamarin.Forms controls directly in their Xaml files. In our case, we can use the native InkCanvas control and InkToolbar control when the app runs on UWP.\n\n\n\n\n\n\nTo make native views consumable via XAML, we must first add XML namespaces for each platform we\u2019ll be embedding views from. In this case, we will add the namespace for the UWP native controls as part of the ContentPage declaration of page we created in the previous task (CameraPage in our example):\n\n\n<ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n        x:Class=\"App1.CameraPage\"\n\n        xmlns:win=\"clr-namespace:Windows.UI.Xaml.Controls;assembly=Windows,\n            Version=255.255.255.255, Culture=neutral, PublicKeyToken=null,\n            ContentType=WindowsRuntime;targetPlatform=Windows\"\n        >\n\n\n\n\n\n\n\nWe can now add two UWP XAML controls directly on the page. \n\n\n\n\nAdd the InkCanvas below the camera image but above the nose image\n\n\nAdd the InkToolbar control between the top button and the imageGrid.\n<StackLayout VerticalOptions=\"FillAndExpand\"\n            HorizontalOptions=\"FillAndExpand\"\n            Orientation=\"Vertical\"\n            Spacing=\"15\">\n    <Button x:Name=\"captureButton\" \n            Text=\"Capture Image\"\n            Clicked=\"captureButton_Clicked\"></Button>\n\n    <!-- UWP XAML CONTROL InkToolbar -->\n    <ContentView x:Name=\"InkingToolbar\">\n        <win:InkToolbar></win:InkToolbar>\n    </ContentView>\n\n    <Grid x:Name=\"ImageGrid\" IsVisible=\"False\">\n        <Image x:Name=\"image\"></Image>\n\n        <!-- UWP XAML CONTROL InkCanvas -->\n        <ContentView x:Name=\"InkingContent\">\n            <win:InkCanvas></win:InkCanvas>\n        </ContentView>\n\n        <AbsoluteLayout>\n            <!-- ... -->\n        </AbsoluteLayout>\n\n    </Grid>\n</StackLayout>\n\n\n\n\n\n\n\n\n\nNote: It is not possible to name native views, so we use a ContentView as a way to get a reference to the native views in our code behind\n\n\n\n\n\n\n\n\nTo use the native views in the code behind, we need to use compilation directives as the native views will only be used on the platform they are available. In this case, the InkCanvas and InkToolbar are only available on UWP, so we need to use the \nWINDOWS_UWP\n directive to wrap our code. In the constructor of our page, after the call to \nInitializeComponent\n, we need to bind the InkToolbar to the InkCanvas and set the input device type of the InkCanvas to all input types:\n\n\n#if WINDOWS_UWP\n    var inkingWrapper = (Xamarin.Forms.Platform.UWP.NativeViewWrapper)InkingContent.Content;\n    var inkCanvas = (Windows.UI.Xaml.Controls.InkCanvas)inkingWrapper.NativeElement;\n    inkCanvas.InkPresenter.InputDeviceTypes =\n        Windows.UI.Core.CoreInputDeviceTypes.Touch |\n        Windows.UI.Core.CoreInputDeviceTypes.Mouse |\n        Windows.UI.Core.CoreInputDeviceTypes.Pen;\n\n    var inkToolbarWrapper = (Xamarin.Forms.Platform.UWP.NativeViewWrapper)InkingToolbar.Content;\n    var inkToolbar = (Windows.UI.Xaml.Controls.InkToolbar)inkToolbarWrapper.NativeElement;\n    inkToolbar.TargetInkCanvas = inkCanvas;\n#endif\n\n\n\n\n\n\n\nIf you run into a null reference exception, check to see if the following line is added above your page class definition: \n\n\n[XamlCompilation(XamlCompilationOptions.Compile)]\n\n\n\nXamarin adds this line to any new page created to \nimprove the performance\n of Xaml pages. However, this optimization will not work when using native views and needs to be removed.\n\n\n\n\n\n\nThat's it. Run the app and draw the perfect masterpiece. You should now be able to run the app, select a nose, capture an image, position the nose where you want, and on UWP, draw using the pen, mouse or touch.\n\n\nCongratulations, you are now done with the first deliverable. You should now be able to take control and start adding more features on your own. Take a look at the other deliverables and tasks for ideas and small hints on implementing other features that would be useful for our users.\n\n\nReferences\n\n\n\n\nXamarin Native Views\n\n\n\n\ncontinue to \nnext task >>",
            "title": "313 InkCanvas"
        },
        {
            "location": "/stories/3/313_InkCanvas/#task-313-overlay-noses-and-support-inking-for-uwp",
            "text": "Our marketing department has the idea to allow our app users to capture images and position Knowzy products over the image to see what how they would look like. It's a fun way to try the product without actually buying it, and the marketing department is hoping for these images to be shared on social media and spread the word.  Goals for this task:   Overlay noses on top of image and allow nose to be manipulated  Support inking on UWP devices  For this task, you will need to access APIs that are specific for each platform. We've done the research on how to do it and we've included the steps below.",
            "title": "Task 3.1.3 - Overlay noses and support inking for UWP"
        },
        {
            "location": "/stories/3/313_InkCanvas/#prerequisites",
            "text": "This task has a dependency on  Task 3.1.2  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/313_InkCanvas/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/3/313_InkCanvas/#overlay-nose-on-image-and-allow-to-be-manipulated",
            "text": "Once the image is captured, let's add the nose image on top and allow the user to move it by panning and resize it by pinching.    Open the xaml page you added in the previous task (CameraPage.xaml in this example), and wrap the image element hosting the camera image in a new Grid element. This will allow you to have multiple elements on top of each other. In addition, add a new  AbsoluteLayout  element in the grid below the existing Image. Inside the AbsoluteLayout add a new image element used for hosting the nose image. Here is what the final result will look like:  Before:  <Image x:Name=\"image\"></Image>  After:  <Grid x:Name=\"imageGrid\" IsVisible=\"False\">\n    <Image x:Name=\"image\"></Image>\n    <AbsoluteLayout>\n        <Image x:Name=\"noseImage\"\n            HeightRequest=\"120\" \n            WidthRequest=\"120\" \n            AbsoluteLayout.LayoutBounds=\"0, 0, AutoSize, AutoSize\" \n            AbsoluteLayout.LayoutFlags=\"None\">\n        </Image>\n    </AbsoluteLayout>\n</Grid>    Notice in the xaml above, we've set the visibility of the Grid to False. Once the image has been captured, we can set the visibility to visible and set the source of the noseImage. Here is what the new captureButton click handler looks like:  private async void captureButton_Clicked(object sender, EventArgs e)\n{\n    var photoService = DependencyService.Get<IPhotoService>();\n    if (photoService != null)\n    {\n        var source = await photoService.TakePhotoAsync();\n        noseImage.Source = ImageSource.FromUri(new Uri(_nose.Image)); // set source of nose image\n        image.Source = source;\n        imageGrid.IsVisible = true; // set visibility to true\n    }\n}    To allow the elements to be manipulated by panning or pinching, Xamarin.Forms has built in  Gestures . As part of the nose image that we added to our page, let's add a new PanGestureRecognizer and a new PinchGestureRecognizer and subscribe to the relevant events so we can manipulate the nose image with gestures:  <Image x:Name=\"noseImage\"\n        HeightRequest=\"120\" \n        WidthRequest=\"120\" \n        AbsoluteLayout.LayoutBounds=\"0, 0, AutoSize, AutoSize\" \n        AbsoluteLayout.LayoutFlags=\"None\">\n\n    <!-- Gesture Recongizers -->\n    <Image.GestureRecognizers>\n        <PanGestureRecognizer PanUpdated=\"OnPanUpdated\" />\n        <PinchGestureRecognizer PinchUpdated=\"OnPinchUpdated\" />\n    </Image.GestureRecognizers>\n\n</Image>    In your code behind, implement the event handlers for the gestures we added to our xaml. The nose moves with the finger or mouse, and when pinching, the scale of the image changes appropriately:  private void OnPanUpdated(object sender, PanUpdatedEventArgs e)\n{\n    switch (e.StatusType)\n    {\n        case GestureStatus.Started:\n            var bounds = AbsoluteLayout.GetLayoutBounds(noseImage);\n            bounds.X += noseImage.TranslationX;\n            bounds.Y += noseImage.TranslationY;\n            AbsoluteLayout.SetLayoutBounds(noseImage, bounds);\n            noseImage.TranslationX = 0;\n            noseImage.TranslationY = 0;\n            break;\n\n        case GestureStatus.Running:\n            noseImage.TranslationX = e.TotalX;\n            noseImage.TranslationY = e.TotalY;\n            break;\n    }\n}\n\nprivate void OnPinchUpdated(object sender, PinchGestureUpdatedEventArgs e)\n{\n    switch (e.Status)\n    {\n        case GestureStatus.Running:\n            noseImage.Scale *= e.Scale;\n            break;\n    }\n}    That's all. Run the app, take a photo, position the nose and have fun.",
            "title": "Overlay nose on image and allow to be manipulated"
        },
        {
            "location": "/stories/3/313_InkCanvas/#adding-inking-support-on-uwp-devices",
            "text": "In addition to using the built in Xamarin.Forms controls, developers have full access to native platform controls as well through  native view declaration . This allows developers to use native  or custom control (such as the UWP Community Toolkit) and mix them with Xamarin.Forms controls directly in their Xaml files. In our case, we can use the native InkCanvas control and InkToolbar control when the app runs on UWP.    To make native views consumable via XAML, we must first add XML namespaces for each platform we\u2019ll be embedding views from. In this case, we will add the namespace for the UWP native controls as part of the ContentPage declaration of page we created in the previous task (CameraPage in our example):  <ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n        x:Class=\"App1.CameraPage\"\n\n        xmlns:win=\"clr-namespace:Windows.UI.Xaml.Controls;assembly=Windows,\n            Version=255.255.255.255, Culture=neutral, PublicKeyToken=null,\n            ContentType=WindowsRuntime;targetPlatform=Windows\"\n        >    We can now add two UWP XAML controls directly on the page.    Add the InkCanvas below the camera image but above the nose image  Add the InkToolbar control between the top button and the imageGrid. <StackLayout VerticalOptions=\"FillAndExpand\"\n            HorizontalOptions=\"FillAndExpand\"\n            Orientation=\"Vertical\"\n            Spacing=\"15\">\n    <Button x:Name=\"captureButton\" \n            Text=\"Capture Image\"\n            Clicked=\"captureButton_Clicked\"></Button>\n\n    <!-- UWP XAML CONTROL InkToolbar -->\n    <ContentView x:Name=\"InkingToolbar\">\n        <win:InkToolbar></win:InkToolbar>\n    </ContentView>\n\n    <Grid x:Name=\"ImageGrid\" IsVisible=\"False\">\n        <Image x:Name=\"image\"></Image>\n\n        <!-- UWP XAML CONTROL InkCanvas -->\n        <ContentView x:Name=\"InkingContent\">\n            <win:InkCanvas></win:InkCanvas>\n        </ContentView>\n\n        <AbsoluteLayout>\n            <!-- ... -->\n        </AbsoluteLayout>\n\n    </Grid>\n</StackLayout>     Note: It is not possible to name native views, so we use a ContentView as a way to get a reference to the native views in our code behind     To use the native views in the code behind, we need to use compilation directives as the native views will only be used on the platform they are available. In this case, the InkCanvas and InkToolbar are only available on UWP, so we need to use the  WINDOWS_UWP  directive to wrap our code. In the constructor of our page, after the call to  InitializeComponent , we need to bind the InkToolbar to the InkCanvas and set the input device type of the InkCanvas to all input types:  #if WINDOWS_UWP\n    var inkingWrapper = (Xamarin.Forms.Platform.UWP.NativeViewWrapper)InkingContent.Content;\n    var inkCanvas = (Windows.UI.Xaml.Controls.InkCanvas)inkingWrapper.NativeElement;\n    inkCanvas.InkPresenter.InputDeviceTypes =\n        Windows.UI.Core.CoreInputDeviceTypes.Touch |\n        Windows.UI.Core.CoreInputDeviceTypes.Mouse |\n        Windows.UI.Core.CoreInputDeviceTypes.Pen;\n\n    var inkToolbarWrapper = (Xamarin.Forms.Platform.UWP.NativeViewWrapper)InkingToolbar.Content;\n    var inkToolbar = (Windows.UI.Xaml.Controls.InkToolbar)inkToolbarWrapper.NativeElement;\n    inkToolbar.TargetInkCanvas = inkCanvas;\n#endif    If you run into a null reference exception, check to see if the following line is added above your page class definition:   [XamlCompilation(XamlCompilationOptions.Compile)]  Xamarin adds this line to any new page created to  improve the performance  of Xaml pages. However, this optimization will not work when using native views and needs to be removed.    That's it. Run the app and draw the perfect masterpiece. You should now be able to run the app, select a nose, capture an image, position the nose where you want, and on UWP, draw using the pen, mouse or touch.  Congratulations, you are now done with the first deliverable. You should now be able to take control and start adding more features on your own. Take a look at the other deliverables and tasks for ideas and small hints on implementing other features that would be useful for our users.",
            "title": "Adding inking support on UWP devices."
        },
        {
            "location": "/stories/3/313_InkCanvas/#references",
            "text": "Xamarin Native Views",
            "title": "References"
        },
        {
            "location": "/stories/3/313_InkCanvas/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/3/321_Social/",
            "text": "Task 3.2.1 - Support sharing images to Social Networks\n\n\nOur users want to be able to share images to their social networks. We want users to spread the word for our products. Enabling the application to share content on every platform will make everyone happy.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 3.1.2\n and all of it's prerequisites\n\n\nTask\n\n\n\n\nSupport sharing content through each platform native share integration\n\n\nSupport sharing to Facebook or Twitter directly from the app (min UWP)\n\n\n\n\nComments\n\n\n@ 9:23am\n\n\nWe can use the same method as in \nTask 3.1.2\n to create a sharing class for every platform. Found \nthis blog\n post that does something similar.\n\n\n@ 10:31am\n\n\nWe can use the UWP Community toolkit to share to \nFacebook\n and/or \nTwitter\n directly on UWP. Sharing to facebook seems super easy:\n\n\n// Initialize service\nFacebookService.Instance.Initialize(\"AppID\");\n\n// Login to Facebook\nif (!await FacebookService.Instance.LoginAsync())\n{\n    return;\n}\n\n// Post a message with a picture on your wall\nawait FacebookService.Instance.PostPictureToFeedAsync(\"Title\", picture.Name, stream);\n\n\n\n\ncontinue to \nnext task >>",
            "title": "321 Social"
        },
        {
            "location": "/stories/3/321_Social/#task-321-support-sharing-images-to-social-networks",
            "text": "Our users want to be able to share images to their social networks. We want users to spread the word for our products. Enabling the application to share content on every platform will make everyone happy.",
            "title": "Task 3.2.1 - Support sharing images to Social Networks"
        },
        {
            "location": "/stories/3/321_Social/#prerequisites",
            "text": "This task has a dependency on  Task 3.1.2  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/321_Social/#task",
            "text": "Support sharing content through each platform native share integration  Support sharing to Facebook or Twitter directly from the app (min UWP)",
            "title": "Task"
        },
        {
            "location": "/stories/3/321_Social/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/3/321_Social/#923am",
            "text": "We can use the same method as in  Task 3.1.2  to create a sharing class for every platform. Found  this blog  post that does something similar.",
            "title": "@ 9:23am"
        },
        {
            "location": "/stories/3/321_Social/#1031am",
            "text": "We can use the UWP Community toolkit to share to  Facebook  and/or  Twitter  directly on UWP. Sharing to facebook seems super easy:  // Initialize service\nFacebookService.Instance.Initialize(\"AppID\");\n\n// Login to Facebook\nif (!await FacebookService.Instance.LoginAsync())\n{\n    return;\n}\n\n// Post a message with a picture on your wall\nawait FacebookService.Instance.PostPictureToFeedAsync(\"Title\", picture.Name, stream);",
            "title": "@ 10:31am"
        },
        {
            "location": "/stories/3/321_Social/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/3/322_Rome/",
            "text": "Task 3.2.2 - Capture images remotely\n\n\nMany users like to launch their app on the desktop through their phone remotely and control it. \n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 3.1.2\n and all of it's prerequisites\n\n\nTask\n\n\n\n\nSupport launching the app remotely on UWP from Android\n\n\nSupport remote controlling the app remotely\n\n\n\n\nComments\n\n\n@ 9:12am\n\n\nI found \nthis blog post\n that walks through using the Project Rome SDK to use android to launch and control the app on PC, it's exactly what we need.\n\n\n@ 10:21am\n\n\nCheck out \nProject Rome\n for docs and more samples\n\n\n@ 10:45am\n\n\nWe can use an App Service to support the messaging between Android and UWP. Here is great \nblog post\n on exactly that. I found some resources on creating app services:\n\n \nDocs on creating and consuming app service\n\n\n \nDocs on communicating with a remote app service\n\n* \nApp service sample\n\n\ncontinue to \nnext task >>",
            "title": "322 Rome"
        },
        {
            "location": "/stories/3/322_Rome/#task-322-capture-images-remotely",
            "text": "Many users like to launch their app on the desktop through their phone remotely and control it.",
            "title": "Task 3.2.2 - Capture images remotely"
        },
        {
            "location": "/stories/3/322_Rome/#prerequisites",
            "text": "This task has a dependency on  Task 3.1.2  and all of it's prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/322_Rome/#task",
            "text": "Support launching the app remotely on UWP from Android  Support remote controlling the app remotely",
            "title": "Task"
        },
        {
            "location": "/stories/3/322_Rome/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/3/322_Rome/#912am",
            "text": "I found  this blog post  that walks through using the Project Rome SDK to use android to launch and control the app on PC, it's exactly what we need.",
            "title": "@ 9:12am"
        },
        {
            "location": "/stories/3/322_Rome/#1021am",
            "text": "Check out  Project Rome  for docs and more samples",
            "title": "@ 10:21am"
        },
        {
            "location": "/stories/3/322_Rome/#1045am",
            "text": "We can use an App Service to support the messaging between Android and UWP. Here is great  blog post  on exactly that. I found some resources on creating app services:   Docs on creating and consuming app service    Docs on communicating with a remote app service \n*  App service sample",
            "title": "@ 10:45am"
        },
        {
            "location": "/stories/3/322_Rome/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/3/331_CognitiveServices/",
            "text": "Task 3.3.1 - Set up Cognitive Services for image face analysis in Azure\n\n\nThis task will require you to set up a Cognitive Service to be used for facial analysis.  You'll use this so that customers can run your Xamarin app and see what they look like with different KNOWZY noses on their face!\n\n\nPrerequisites\n\n\n\n\nAn Azure Subscription\n\n\n\n\nTask\n\n\n\n\n\n\nCreate a new Cognitive Services \nFace API\n.  \n\n\n\n\n\n\nCopy your Face API's \nName\n and \nKey 1\n for later usage.\n\n\n\n\n\n\nComments\n\n\n@ 2:37am\n\n\nCreating a Face API couldn't be easier, just follow \nthis\n guide I found.\n\n\ncontinue to \nnext task >>",
            "title": "331 CognitiveServices"
        },
        {
            "location": "/stories/3/331_CognitiveServices/#task-331-set-up-cognitive-services-for-image-face-analysis-in-azure",
            "text": "This task will require you to set up a Cognitive Service to be used for facial analysis.  You'll use this so that customers can run your Xamarin app and see what they look like with different KNOWZY noses on their face!",
            "title": "Task 3.3.1 - Set up Cognitive Services for image face analysis in Azure"
        },
        {
            "location": "/stories/3/331_CognitiveServices/#prerequisites",
            "text": "An Azure Subscription",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/331_CognitiveServices/#task",
            "text": "Create a new Cognitive Services  Face API .      Copy your Face API's  Name  and  Key 1  for later usage.",
            "title": "Task"
        },
        {
            "location": "/stories/3/331_CognitiveServices/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/3/331_CognitiveServices/#237am",
            "text": "Creating a Face API couldn't be easier, just follow  this  guide I found.",
            "title": "@ 2:37am"
        },
        {
            "location": "/stories/3/331_CognitiveServices/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/3/332_AzureFunction/",
            "text": "Task 3.3.2 - Create an Azure Function to analyze an image and return nose location\n\n\nNow that you've created a Cognitive Service to tell you where noses are in pictures sent from the KNOWZY mobile app, you need to create an endpoint to accept those pictures and talk to your Cognitive Service.  This task will require you to set up a new Azure Function and then to code and design it to expose an HTTP endpoint to accept an image file and return the location of the nose(s) in any faces found in the picture.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 3.3.1\n and all of it's prerequisites\n\n\nThis walkthrough assumes that you have:\n\n\n\n\nVisual Studio 2017 Preview 3\n.\n\n\nAzure Functions extension\n installed. \n\n\n\n\nTask\n\n\n\n\nCreate a new Azure Functions project in Visual Studio.  \n\n\nCreate an HTTP Trigger which will take in a picture and return data.\n\n\nWithin your Function, use the \nName\n and \nKey\n from \nTask 3.3.1\n to connect to your Cognitive Service and run face detection on the image.\n\n\nReturn the data for the nose location(s) from your Function.\n\n\nPosition nose on top of image in app\n\n\n\n\nComments\n\n\n@ 11:48am\n\n\nThis\n blog post shows off the Visual Studio tooling that you can use to create a new Azure function.\n\n\n@ 1:03pm\n\n\nI found this explanation for Azure Functions of how to do \nHTTP and Webhook Bindings\n.\n\n\n@ 2:57pm\n\n\nI was curious about what the Face API is capable of so I found the \nREST Docs\n.\n\n\n@ 4:32pm\n\n\nThis \nquickstart\n really walks through how to call the Face API from C#.\n\n\ncontinue to \nnext task >>",
            "title": "332 AzureFunction"
        },
        {
            "location": "/stories/3/332_AzureFunction/#task-332-create-an-azure-function-to-analyze-an-image-and-return-nose-location",
            "text": "Now that you've created a Cognitive Service to tell you where noses are in pictures sent from the KNOWZY mobile app, you need to create an endpoint to accept those pictures and talk to your Cognitive Service.  This task will require you to set up a new Azure Function and then to code and design it to expose an HTTP endpoint to accept an image file and return the location of the nose(s) in any faces found in the picture.",
            "title": "Task 3.3.2 - Create an Azure Function to analyze an image and return nose location"
        },
        {
            "location": "/stories/3/332_AzureFunction/#prerequisites",
            "text": "This task has a dependency on  Task 3.3.1  and all of it's prerequisites  This walkthrough assumes that you have:   Visual Studio 2017 Preview 3 .  Azure Functions extension  installed.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/332_AzureFunction/#task",
            "text": "Create a new Azure Functions project in Visual Studio.    Create an HTTP Trigger which will take in a picture and return data.  Within your Function, use the  Name  and  Key  from  Task 3.3.1  to connect to your Cognitive Service and run face detection on the image.  Return the data for the nose location(s) from your Function.  Position nose on top of image in app",
            "title": "Task"
        },
        {
            "location": "/stories/3/332_AzureFunction/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/3/332_AzureFunction/#1148am",
            "text": "This  blog post shows off the Visual Studio tooling that you can use to create a new Azure function.",
            "title": "@ 11:48am"
        },
        {
            "location": "/stories/3/332_AzureFunction/#103pm",
            "text": "I found this explanation for Azure Functions of how to do  HTTP and Webhook Bindings .",
            "title": "@ 1:03pm"
        },
        {
            "location": "/stories/3/332_AzureFunction/#257pm",
            "text": "I was curious about what the Face API is capable of so I found the  REST Docs .",
            "title": "@ 2:57pm"
        },
        {
            "location": "/stories/3/332_AzureFunction/#432pm",
            "text": "This  quickstart  really walks through how to call the Face API from C#.",
            "title": "@ 4:32pm"
        },
        {
            "location": "/stories/3/332_AzureFunction/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/3/341_CICD_WindowsApp/",
            "text": "Task 3.4.1 - Set up Continuous Integration and Deployment for the Windows app using Visual Studio Mobile Center\n\n\nNow that you've made an app that works, the CTO would like to ensure higher quality by setting up Continuous Integration and Delivery.  To that end, you've been instructed to make sure the app compiles with every code check-in, any tests are run, and new versions can be delivered to beta testers with ease.  This task will focus on the Windows version of the app with another task focusing on Android.\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 3.1.1\n and all of it's prerequisites.\n\n\nIf you've already set up a code repository for \nTask 3.4.2\n, you can use that and skip to step 2 below.\n\n\n\n\nTask\n\n\n\n\nAdd your application to a compatible source control system.\n\n\nCreate a UWP app in Mobile Center, and connect it to your repo.\n\n\nEnsure your app builds the first time.  \n\n\nAdd your teammates so they receive notifications on build.\n\n\nMake sure your teammates can install your app.\n\n\n\n\nComments\n\n\n@ 7:37am\n\n\nIt sounds like we can use multiple different source control systems with Mobile Center.  Check out \nthese docs\n I found about connecting to a repository.\n\n\n@ 9:23am\n\n\nIt sounds like the Build config in Mobile Center let's us trigger a build with every code check-in.  That means our builds will happen automatically!\n\n\n@ 11:56am\n\n\nMy friends wanted to know whenever I built an app so I figured out how to create a distribution group \nhere\n.\n\n\ncontinue to \nnext task >>",
            "title": "341 CICD WindowsApp"
        },
        {
            "location": "/stories/3/341_CICD_WindowsApp/#task-341-set-up-continuous-integration-and-deployment-for-the-windows-app-using-visual-studio-mobile-center",
            "text": "Now that you've made an app that works, the CTO would like to ensure higher quality by setting up Continuous Integration and Delivery.  To that end, you've been instructed to make sure the app compiles with every code check-in, any tests are run, and new versions can be delivered to beta testers with ease.  This task will focus on the Windows version of the app with another task focusing on Android.",
            "title": "Task 3.4.1 - Set up Continuous Integration and Deployment for the Windows app using Visual Studio Mobile Center"
        },
        {
            "location": "/stories/3/341_CICD_WindowsApp/#prerequisites",
            "text": "This task has a dependency on  Task 3.1.1  and all of it's prerequisites.  If you've already set up a code repository for  Task 3.4.2 , you can use that and skip to step 2 below.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/341_CICD_WindowsApp/#task",
            "text": "Add your application to a compatible source control system.  Create a UWP app in Mobile Center, and connect it to your repo.  Ensure your app builds the first time.    Add your teammates so they receive notifications on build.  Make sure your teammates can install your app.",
            "title": "Task"
        },
        {
            "location": "/stories/3/341_CICD_WindowsApp/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/3/341_CICD_WindowsApp/#737am",
            "text": "It sounds like we can use multiple different source control systems with Mobile Center.  Check out  these docs  I found about connecting to a repository.",
            "title": "@ 7:37am"
        },
        {
            "location": "/stories/3/341_CICD_WindowsApp/#923am",
            "text": "It sounds like the Build config in Mobile Center let's us trigger a build with every code check-in.  That means our builds will happen automatically!",
            "title": "@ 9:23am"
        },
        {
            "location": "/stories/3/341_CICD_WindowsApp/#1156am",
            "text": "My friends wanted to know whenever I built an app so I figured out how to create a distribution group  here .",
            "title": "@ 11:56am"
        },
        {
            "location": "/stories/3/341_CICD_WindowsApp/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/3/342_CICD_AndroidApp/",
            "text": "Task 3.4.2 - Set up Continuous Integration and Deployment for the Android app using Visual Studio Mobile Center\n\n\nNow that you've made an app that works, the CTO would like to ensure higher quality by setting up Continuous Integration and Delivery.  To that end, you've been instructed to make sure the app compiles with every code check-in, any tests are run, and new versions can be delivered to beta testers with ease.  This task will focus on the Android version of the app with another task focusing on Windows.\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 3.1.1\n and all of it's prerequisites.\n\n\nIf you've already set up a code repository for \nTask 3.4.1\n, you can use that and skip to step 2 below.\n\n\n\n\nTask\n\n\n\n\nAdd your application to a compatible source control system.\n\n\nCreate an Android app in Mobile Center, and connect it to your repo.\n\n\nEnsure your app builds the first time.  \n\n\nAdd your teammates so they receive notifications on build.\n\n\nMake sure your teammates can install your app.\n\n\n\n\nComments\n\n\n@ 9:37am\n\n\nIt sounds like we can use multiple different source control systems with Mobile Center.  Check out \nthese docs\n I found about connecting to a repository.\n\n\n@ 10:04am\n\n\nI finally figured out how to \ncreating a Keystore for signing an app\n.  This should save you some time!\n\n\n@ 1:22pm\n\n\nIt sounds like the Build config in Mobile Center let's us trigger a build with every code check-in.  That means our builds will happen automatically!\n\n\n@ 3:56pm\n\n\nMy friends wanted to know whenever I built an app so I figured out how to create a distribution group \nhere\n.\n\n\ncontinue to \nnext task >>",
            "title": "342 CICD AndroidApp"
        },
        {
            "location": "/stories/3/342_CICD_AndroidApp/#task-342-set-up-continuous-integration-and-deployment-for-the-android-app-using-visual-studio-mobile-center",
            "text": "Now that you've made an app that works, the CTO would like to ensure higher quality by setting up Continuous Integration and Delivery.  To that end, you've been instructed to make sure the app compiles with every code check-in, any tests are run, and new versions can be delivered to beta testers with ease.  This task will focus on the Android version of the app with another task focusing on Windows.",
            "title": "Task 3.4.2 - Set up Continuous Integration and Deployment for the Android app using Visual Studio Mobile Center"
        },
        {
            "location": "/stories/3/342_CICD_AndroidApp/#prerequisites",
            "text": "This task has a dependency on  Task 3.1.1  and all of it's prerequisites.  If you've already set up a code repository for  Task 3.4.1 , you can use that and skip to step 2 below.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/342_CICD_AndroidApp/#task",
            "text": "Add your application to a compatible source control system.  Create an Android app in Mobile Center, and connect it to your repo.  Ensure your app builds the first time.    Add your teammates so they receive notifications on build.  Make sure your teammates can install your app.",
            "title": "Task"
        },
        {
            "location": "/stories/3/342_CICD_AndroidApp/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/3/342_CICD_AndroidApp/#937am",
            "text": "It sounds like we can use multiple different source control systems with Mobile Center.  Check out  these docs  I found about connecting to a repository.",
            "title": "@ 9:37am"
        },
        {
            "location": "/stories/3/342_CICD_AndroidApp/#1004am",
            "text": "I finally figured out how to  creating a Keystore for signing an app .  This should save you some time!",
            "title": "@ 10:04am"
        },
        {
            "location": "/stories/3/342_CICD_AndroidApp/#122pm",
            "text": "It sounds like the Build config in Mobile Center let's us trigger a build with every code check-in.  That means our builds will happen automatically!",
            "title": "@ 1:22pm"
        },
        {
            "location": "/stories/3/342_CICD_AndroidApp/#356pm",
            "text": "My friends wanted to know whenever I built an app so I figured out how to create a distribution group  here .",
            "title": "@ 3:56pm"
        },
        {
            "location": "/stories/3/342_CICD_AndroidApp/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/3/343_EventLogging/",
            "text": "Task 3.4.3 - Add Custom Event Logging using Visual Studio Mobile Center\n\n\nNow that you've completed Continuous Integration and Delivery, it's time to get some more value out of Mobile Center.  Specifically, we want you to use the Mobile Center SDK to start recording analytics on the usage of your app.  This will help show the execs how many people are using the app and how.\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 3.4.1\n or \nTask 3.4.2\n so your app is already connected to Mobile Center.\n\n\n\n\nTask\n\n\n\n\nAdd the Mobile Center SDK to your solution and projects.\n\n\nConfigure the SDK on app start.\n\n\nAdd some custom logging and log an event in your app.\n\n\n\n\nComments\n\n\n@ 12:20pm\n\n\nI found a great walkthrough on installing the Mobile Center SDK \nhere\n.\n\n\n@ 2:31pm\n\n\nThis\n made adding logging to my Xamarin app super easy.\n\n\n@ 4:17pm\n\n\nIt looks like there is a bit of customization you need to do for UWP.  \nCheck it out\n.\n\n\ncontinue to \nnext task >>",
            "title": "343 EventLogging"
        },
        {
            "location": "/stories/3/343_EventLogging/#task-343-add-custom-event-logging-using-visual-studio-mobile-center",
            "text": "Now that you've completed Continuous Integration and Delivery, it's time to get some more value out of Mobile Center.  Specifically, we want you to use the Mobile Center SDK to start recording analytics on the usage of your app.  This will help show the execs how many people are using the app and how.",
            "title": "Task 3.4.3 - Add Custom Event Logging using Visual Studio Mobile Center"
        },
        {
            "location": "/stories/3/343_EventLogging/#prerequisites",
            "text": "This task has a dependency on  Task 3.4.1  or  Task 3.4.2  so your app is already connected to Mobile Center.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/343_EventLogging/#task",
            "text": "Add the Mobile Center SDK to your solution and projects.  Configure the SDK on app start.  Add some custom logging and log an event in your app.",
            "title": "Task"
        },
        {
            "location": "/stories/3/343_EventLogging/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/3/343_EventLogging/#1220pm",
            "text": "I found a great walkthrough on installing the Mobile Center SDK  here .",
            "title": "@ 12:20pm"
        },
        {
            "location": "/stories/3/343_EventLogging/#231pm",
            "text": "This  made adding logging to my Xamarin app super easy.",
            "title": "@ 2:31pm"
        },
        {
            "location": "/stories/3/343_EventLogging/#417pm",
            "text": "It looks like there is a bit of customization you need to do for UWP.   Check it out .",
            "title": "@ 4:17pm"
        },
        {
            "location": "/stories/3/343_EventLogging/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/3/351_Bot/",
            "text": "Task 3.5.1 - Create a Customer Bot\n\n\nOur users want to be able to check and modify the status of their orders from anywhere, including chat bot platforms like Skype and Facebook. They'd also like to send feedback and create support tickets from the bot.\n\n\nPrerequisites\n\n\nThis task has a dependency on the \nOrders API created under section 4.1.2\n and all of its prerequisites\n\n\nTask\n\n\n\n\nCreate a bot using the Microsoft Bot Framework that asks for the user to log in (a Minimum Viable Product would be asking for the user id to identify the user). \n\n\nOnce the user logs in, the bot can list user orders, find a specific order status from an Order ID, and cancel the order if it hasn't been shipped.\n\n\nThe bot also allows the user to open support tickets and send feedback.\n\n\n\n\nComments\n\n\n@ 9:02am\n\n\nI've done a bit of investigation, found these samples \nin C#\n and \nin Node.js\n that should help us get started.  The core-MultiDialogs and the cards-CarouselCards samples seem interesting.\n\n\n@ 9:23am\n\n\nIf the bot asks the user to sign in we can use this \nnice library called BotAuth\n for it. \n\n\n@ 10:31am\n\n\nWe can use this to keep track of the user's id (\nC#\n and \nNode.js\n) like in the core-State sample. After logging in we can use the user id to get our bot to call the \nOrders API\n to get order details for the user. \n\n\n@ 11:05am\n\n\nWe can use Microsoft Cognitive Services to enhance our bot, like the \nLanguage Understanding Intelligent Service\n to \nunderstand commands\n and the \nText Analytics API\n for sentiment analysis of feedback.",
            "title": "351 Bot"
        },
        {
            "location": "/stories/3/351_Bot/#task-351-create-a-customer-bot",
            "text": "Our users want to be able to check and modify the status of their orders from anywhere, including chat bot platforms like Skype and Facebook. They'd also like to send feedback and create support tickets from the bot.",
            "title": "Task 3.5.1 - Create a Customer Bot"
        },
        {
            "location": "/stories/3/351_Bot/#prerequisites",
            "text": "This task has a dependency on the  Orders API created under section 4.1.2  and all of its prerequisites",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/3/351_Bot/#task",
            "text": "Create a bot using the Microsoft Bot Framework that asks for the user to log in (a Minimum Viable Product would be asking for the user id to identify the user).   Once the user logs in, the bot can list user orders, find a specific order status from an Order ID, and cancel the order if it hasn't been shipped.  The bot also allows the user to open support tickets and send feedback.",
            "title": "Task"
        },
        {
            "location": "/stories/3/351_Bot/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/3/351_Bot/#902am",
            "text": "I've done a bit of investigation, found these samples  in C#  and  in Node.js  that should help us get started.  The core-MultiDialogs and the cards-CarouselCards samples seem interesting.",
            "title": "@ 9:02am"
        },
        {
            "location": "/stories/3/351_Bot/#923am",
            "text": "If the bot asks the user to sign in we can use this  nice library called BotAuth  for it.",
            "title": "@ 9:23am"
        },
        {
            "location": "/stories/3/351_Bot/#1031am",
            "text": "We can use this to keep track of the user's id ( C#  and  Node.js ) like in the core-State sample. After logging in we can use the user id to get our bot to call the  Orders API  to get order details for the user.",
            "title": "@ 10:31am"
        },
        {
            "location": "/stories/3/351_Bot/#1105am",
            "text": "We can use Microsoft Cognitive Services to enhance our bot, like the  Language Understanding Intelligent Service  to  understand commands  and the  Text Analytics API  for sentiment analysis of feedback.",
            "title": "@ 11:05am"
        },
        {
            "location": "/stories/4/411_CosmosDB/",
            "text": "Task 4.1.1 - Create a shared CosmosDB to store all data\n\n\n1. Pre-Requisites\n\n\n\n\nYou should download and extract the \nCosmosDB Data Migration Tool\n\n\nYou'll need access to an azure subscription.\n\n\n\n\na. Working with Cloud Shell\n\n\nAzure Cloud Shell comes with the Azure CLI already configured, which makes setup straightforward. We'll be using Azure Cloud Shell throughout this guide, so to get started we need to get Cloud Shell pointed toward the subscription we want to work with.\n\n\nNB: All shell instructions are based on using the cloud shell, using a local powershell, bash session or command prompt may cause unexpected results.\n\n\ni) Access Azure Cloud Shell using the \n>_\n Icon in the \ntop right corner\n of the portal.\n\n\n\n\nii) Point to your Azure subscription\n\n\nIf you have more than one subscription in your azure portal, it's a good idea to first check which one your CLI is pointed to.  The command for this is:\n\n    az account show\n\nIf it's not pointed to the subscription you want to use, you can re-point your CLI to the correct subscription using:\n\n    az account set --subscription <SubscriptionId>\n\nYou can list out all subscriptions you have access to using:\n\n    az account list\n\n\n\nb. Create a resource group\n\n\nWe need to create a resource-group to ring-fence all of our work, we'll start out by storing a couple of variables we're going to use again in our shell. \n(Note; many resources within Azure require a unique name, as such we recommend you use the guidelines in the published \nnaming conventions\n)\n\n\nc. First store the name you want to use for your resource group:\n\n\nResource group names must be globally unique within azure, so make sure its both memorable, and specific to you and your project.\n\n\nRESOURCE_GROUP=<unique name>\n\n\n\nd. Then the location we're going to create it in \n(for our example you should pick from: 'eastus', 'westeurope' or 'southeastasia')\n\n\nLOCATION=eastus\n\n\n\ne. Create our new resource group within our current subscription:\n\n\n    az group create --name $RESOURCE_GROUP --location $LOCATION\n\n\n\n\n2. Create and initialise CosmosDB\n\n\na. Store the name of our database:\n\n\nLike resource group names, CosmosDB names must be globally unique within azure, so again we should select something specific.\n\n\nCOSMOSDB_NAME=<unique database name> _(names must be all lower case and no symbols)_\n\n\n\nb. Create the CosmosDB instance\n\n\nWe can now go ahead and use the Azure CLI within the Cloud Shell to create our CosmosDB Instance.\n\n\naz cosmosdb create -g $RESOURCE_GROUP -n $COSMOSDB_NAME --locations \"EAST US2\"=0\n\n\n\nThis command will take some time to complete. You'll know it's succeeded when the cloud shell console outputs something like this, containing the name you specified in step 1 above in the 'documentEndpoint':\n\n\n\n\nc. Import data into collections\n\n\nFor this step we'll need to use the \nCosmosDB Data Migration Tool\n that you should have already downloaded and extracted.\n\n\nWe're going to perform the following steps for 3 collections we need to add to Azure; \nCustomers\n, \nProducts\n and \nOrders\n. For convenience sake you can download a zip file containing all three: \nHere\n.\n\n\ni) Load up the UI version of the data migration tool by running 'dtui.exe'\n\n\n\n\nii) You should be greeted with the following screen below, we can just click 'Next' for now.\n\n\n\n\niii) This is the 'Source Information' screen where we specify the information source for our import, select the JSON file for the collection you want to import (We'll use customers.json for our example) then click next to move on.\n\n\n\n\niv) You should be presented with a screen that looks like below, the 'Target Information' screen, where specify information about the destination of our import. First set the 'Export to' option to: 'CosmosDB - Sequential record import (partitioned collection).\n\n\n\n\nv) We'll need to retrieve our 'Connection String' from the Azure Portal. Open the portal, and select your CosmosDB Instance, then click on 'Keys' and select 'Read/Write Keys' and click the button next to 'PRIMARY CONNECTION STRING' to copy it to your clipboard.\n\n\n\n\nvi) Go back to the CosmosDB Data Migration Tool and paste the value into the box for the connection string. The importer also requires that you specify the database you'll be importing to so add the following string with the name of your database (which you defined in step 2a) to the end of the connection string you just pasted:\n\n\nDatabase=<your CosmosDB name>\n\n\n\nSo you have something that looks like this:\n\n\n\n\nv) Click the 'verify' button, and you should get confirmation that the importer can successfully connect to your CosmosDB. Which should look like this:\n\n\n\n\nvi) Now we need to specify the other parameters for the new collection, complete the rest of the form as below:\n\n\n\n\nCollection: [name of collection] - \nThis is the name of the collection that will be created, you should choose from (orders, customers or products) dependent which import you are completing, we chose customers.json so our collection is 'customers'\n>\n\n\nPartition Key: /[partition key] - \nThis is the partition key that will be applied to the collection, for customers and orders we do this for '/companyName' for products we use '/category', be careful of case sensitivity here!\n\n\nCollection Throughput: 400 - _This is the preset throughput to configure the collection for, we want to keep costs down during dev, so we should change this from 1000 (the default) to 400.\n\n\nId Field: id - \nThis is the ID field of the schema, for sake of simplicity we've made them all 'id' (case sensitive), but this is customisable in more advanced scenarios.\n\n\n\n\nOnce your form looks as below, then we're ready to click next!\n\n\n\n\nvii) Click 'Next' on the 'Advanced' settings screen, we want our errors to show in the tool UI so we don't need to specify anything here. Then you should be presented with a screen that looks like this:\n\n\n\n\nviii) Carefully review the import settings, and when you're satisfied click 'Import', if the import fails, errors will be displayed in the UI. All being well, your import will succeed and you'll see a screen similar to:\n\n\n\n\nix) You can now return to the portal, select your CosmosDB Instance, and click on 'Document Explorer' to explore your new schema.\n\n\n\n\nx) To import the other two collections (products and orders in our example given here), simply click 'New Import' and follow steps (ii) through (ix) using the next JSON file and schema Name for your chosen collection.\n\n\n\n\n3. References\n\n\nCosmosDB Migration Tool Download\n\n\ncontinue to \nnext task >>",
            "title": "411 CosmosDB"
        },
        {
            "location": "/stories/4/411_CosmosDB/#task-411-create-a-shared-cosmosdb-to-store-all-data",
            "text": "",
            "title": "Task 4.1.1 - Create a shared CosmosDB to store all data"
        },
        {
            "location": "/stories/4/411_CosmosDB/#1-pre-requisites",
            "text": "You should download and extract the  CosmosDB Data Migration Tool  You'll need access to an azure subscription.",
            "title": "1. Pre-Requisites"
        },
        {
            "location": "/stories/4/411_CosmosDB/#a-working-with-cloud-shell",
            "text": "Azure Cloud Shell comes with the Azure CLI already configured, which makes setup straightforward. We'll be using Azure Cloud Shell throughout this guide, so to get started we need to get Cloud Shell pointed toward the subscription we want to work with.  NB: All shell instructions are based on using the cloud shell, using a local powershell, bash session or command prompt may cause unexpected results.  i) Access Azure Cloud Shell using the  >_  Icon in the  top right corner  of the portal.   ii) Point to your Azure subscription  If you have more than one subscription in your azure portal, it's a good idea to first check which one your CLI is pointed to.  The command for this is:\n\n    az account show\n\nIf it's not pointed to the subscription you want to use, you can re-point your CLI to the correct subscription using:\n\n    az account set --subscription <SubscriptionId>\n\nYou can list out all subscriptions you have access to using:\n\n    az account list",
            "title": "a. Working with Cloud Shell"
        },
        {
            "location": "/stories/4/411_CosmosDB/#b-create-a-resource-group",
            "text": "We need to create a resource-group to ring-fence all of our work, we'll start out by storing a couple of variables we're going to use again in our shell.  (Note; many resources within Azure require a unique name, as such we recommend you use the guidelines in the published  naming conventions )",
            "title": "b. Create a resource group"
        },
        {
            "location": "/stories/4/411_CosmosDB/#c-first-store-the-name-you-want-to-use-for-your-resource-group",
            "text": "Resource group names must be globally unique within azure, so make sure its both memorable, and specific to you and your project.  RESOURCE_GROUP=<unique name>",
            "title": "c. First store the name you want to use for your resource group:"
        },
        {
            "location": "/stories/4/411_CosmosDB/#d-then-the-location-were-going-to-create-it-in-for-our-example-you-should-pick-from-eastus-westeurope-or-southeastasia",
            "text": "LOCATION=eastus",
            "title": "d. Then the location we're going to create it in (for our example you should pick from: 'eastus', 'westeurope' or 'southeastasia')"
        },
        {
            "location": "/stories/4/411_CosmosDB/#e-create-our-new-resource-group-within-our-current-subscription",
            "text": "az group create --name $RESOURCE_GROUP --location $LOCATION",
            "title": "e. Create our new resource group within our current subscription:"
        },
        {
            "location": "/stories/4/411_CosmosDB/#2-create-and-initialise-cosmosdb",
            "text": "",
            "title": "2. Create and initialise CosmosDB"
        },
        {
            "location": "/stories/4/411_CosmosDB/#a-store-the-name-of-our-database",
            "text": "Like resource group names, CosmosDB names must be globally unique within azure, so again we should select something specific.  COSMOSDB_NAME=<unique database name> _(names must be all lower case and no symbols)_",
            "title": "a. Store the name of our database:"
        },
        {
            "location": "/stories/4/411_CosmosDB/#b-create-the-cosmosdb-instance",
            "text": "We can now go ahead and use the Azure CLI within the Cloud Shell to create our CosmosDB Instance.  az cosmosdb create -g $RESOURCE_GROUP -n $COSMOSDB_NAME --locations \"EAST US2\"=0  This command will take some time to complete. You'll know it's succeeded when the cloud shell console outputs something like this, containing the name you specified in step 1 above in the 'documentEndpoint':",
            "title": "b. Create the CosmosDB instance"
        },
        {
            "location": "/stories/4/411_CosmosDB/#c-import-data-into-collections",
            "text": "For this step we'll need to use the  CosmosDB Data Migration Tool  that you should have already downloaded and extracted.  We're going to perform the following steps for 3 collections we need to add to Azure;  Customers ,  Products  and  Orders . For convenience sake you can download a zip file containing all three:  Here .  i) Load up the UI version of the data migration tool by running 'dtui.exe'   ii) You should be greeted with the following screen below, we can just click 'Next' for now.   iii) This is the 'Source Information' screen where we specify the information source for our import, select the JSON file for the collection you want to import (We'll use customers.json for our example) then click next to move on.   iv) You should be presented with a screen that looks like below, the 'Target Information' screen, where specify information about the destination of our import. First set the 'Export to' option to: 'CosmosDB - Sequential record import (partitioned collection).   v) We'll need to retrieve our 'Connection String' from the Azure Portal. Open the portal, and select your CosmosDB Instance, then click on 'Keys' and select 'Read/Write Keys' and click the button next to 'PRIMARY CONNECTION STRING' to copy it to your clipboard.   vi) Go back to the CosmosDB Data Migration Tool and paste the value into the box for the connection string. The importer also requires that you specify the database you'll be importing to so add the following string with the name of your database (which you defined in step 2a) to the end of the connection string you just pasted:  Database=<your CosmosDB name>  So you have something that looks like this:   v) Click the 'verify' button, and you should get confirmation that the importer can successfully connect to your CosmosDB. Which should look like this:   vi) Now we need to specify the other parameters for the new collection, complete the rest of the form as below:   Collection: [name of collection] -  This is the name of the collection that will be created, you should choose from (orders, customers or products) dependent which import you are completing, we chose customers.json so our collection is 'customers' >  Partition Key: /[partition key] -  This is the partition key that will be applied to the collection, for customers and orders we do this for '/companyName' for products we use '/category', be careful of case sensitivity here!  Collection Throughput: 400 - _This is the preset throughput to configure the collection for, we want to keep costs down during dev, so we should change this from 1000 (the default) to 400.  Id Field: id -  This is the ID field of the schema, for sake of simplicity we've made them all 'id' (case sensitive), but this is customisable in more advanced scenarios.   Once your form looks as below, then we're ready to click next!   vii) Click 'Next' on the 'Advanced' settings screen, we want our errors to show in the tool UI so we don't need to specify anything here. Then you should be presented with a screen that looks like this:   viii) Carefully review the import settings, and when you're satisfied click 'Import', if the import fails, errors will be displayed in the UI. All being well, your import will succeed and you'll see a screen similar to:   ix) You can now return to the portal, select your CosmosDB Instance, and click on 'Document Explorer' to explore your new schema.   x) To import the other two collections (products and orders in our example given here), simply click 'New Import' and follow steps (ii) through (ix) using the next JSON file and schema Name for your chosen collection.",
            "title": "c. Import data into collections"
        },
        {
            "location": "/stories/4/411_CosmosDB/#3-references",
            "text": "CosmosDB Migration Tool Download",
            "title": "3. References"
        },
        {
            "location": "/stories/4/411_CosmosDB/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/4/412_OrdersAPI/",
            "text": "Task 4.1.2 - Create API endpoint for shipping and receiving services\n\n\nNow that you've created a database to store your data, it's time to create APIs to access that data.  Knowzy believes in a microservices based architecture so you'll need to start by creating a new API for orders so the Web app is not going directly to the database.\n\n\nThe end goal is a .NET Core based cross-platform solution. The architecture proposes a simplified microservice oriented architecture implementation with multiple autonomous microservices (each one owning its own data/db). The microservices will implement a simple CRUD approach using Http as the current communication protocol.\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on Tasks \n1.1.1\n and \n4.1.1\n and all of their prerequisites.\n\n\n\n\nCreating a .NET Core App\n\n\n1. Create a New WebAPI Project\n\n\nFrom Windows Explorer create a new folder called \nAPIs\n in the \nsrc\\2. Services\n folder of the solution.\n\n\nOpen the \nMicrosoft.Knowzy\n solution in Visual Studio 2017. Add a new solution folder called \nAPIs\n to the \n2. Services\n folder. Create a new \nASP.NET Core Web Application\n project called \nMicrosoft.Knowzy.OrdersAPI\n in that folder:\n\n\n\n\nChoose Web API for the project type, and leave the other options as they are (we will add Docker support later):\n\n\n\n\nLet's test it out to make sure everything is working properly. In Visual Studio, right click on the project and select \nDebug -> Start New Instance\n. Visual Studio will start a browser window for you to see your app running. Click the \nStop\n button in Visual Studio to stop the API app.\n\n\n2. Using Environment Variables and Connecting to CosmosDB\n\n\nIn a real-world app, you won't check your secrets into source control, and you won't be writing local code that connects directly to your production data store. Depending on your environment, you might not even have access to production. To address these issues and see how they tie in with Docker, we're going to use the \nCOSMOSDB_ENDPOINT\n and \nCOSMOSDB_KEY\n environment variables.\n\n\nThe default Web API template already calls \n.AddEnvironmentVariables()\n (look for it in \nStartup.cs\n), so we just need to set a variable, then access it in our code. \n\n\nAdd these values to the Environment Variables section of the \nMicrosoft.Knowzy.OrdersAPI\n project properties:\n\n\n\n\nTo use these environment variables in our code, we'll just pass the entire configuration object down to a new data access class.\n\n\nIn \nStartup.cs\n, make the following changes:\n\n\npublic void ConfigureServices(IServiceConnection services)\n{\n  // Add framework services.\n  services.AddMvc();\n+ services.AddSingleton<IConfiguration>(Configuration);\n}\n\n\n\n\nNow let's connect our solution to our data store in \nCosmosDB\n that was created as part of task \n4.1.1\n. \n\n\nStart by adding a Nuget package reference to the latest stable version of \nMicrosoft.Azure.DocumentDB.Core\n to the \nMicrosoft.Knowzy.OrdersAPI\n project.\n\n\nAdd a new folder called \nData\n to the \nMicrosoft.Knowzy.OrdersAPI\n project. This folder will have the classes that interact with your CosmosDB data store. \n\n\nAdd a new interface called \nIOrdersStore.cs\n to the \nData\n folder and populate it with the following:\n\n\nusing System;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public interface IOrdersStore : IDisposable\n    {\n        Task<bool> Connected();\n    }\n}\n\n\n\n\nAdd a new class called \nOrdersStore.cs\n to the \nData\n folder and populate it with a method to check if it can connect to CosmosDB. Make sure to update the database and collection name in this code to match yours:\n\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Azure.Documents.Client;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public class OrdersStore : IOrdersStore\n    {\n        private readonly DocumentClient _client;\n        private Uri _ordersLink;\n        public OrdersStore(IConfiguration config)\n        {\n            var EndpointUri = config[\"COSMOSDB_ENDPOINT\"];\n            var PrimaryKey = config[\"COSMOSDB_KEY\"];\n            _client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n            //Make sure the below values match your set up\n            _ordersLink = UriFactory.CreateDocumentCollectionUri(\"knowzydb\", \"orders\"); \n        }\n\n        public async Task<bool> Connected()\n        {\n            try\n            {\n                var db = await _client.GetDatabaseAccountAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        private bool disposedValue = false; // To detect redundant calls\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    _client.Dispose();\n                }\n                disposedValue = true;\n            }\n        }\n\n        void IDisposable.Dispose()\n        {\n            Dispose(true);\n        }\n    }\n}\n\n\n\n\nNote how we are using the \nASP.NET Core dependency injection\n to get the config instance passed into the class initializer for us, and with it we get the environment variable values. You can read more about configuration in ASP.NET Core in \nthis help article\n.\n\n\nModify \nStartup.cs\n and register our data access with the list of services (IoC):\n\n\npublic void ConfigureServices(IServiceConnection services)\n{\n  // Add framework services.\n  services.AddMvc();\n  services.AddSingleton<IConfiguration>(Configuration);\n+ services.AddSingleton<Data.IOrdersStore, Data.OrdersStore>();\n}\n\n\n\n\nTo test it outupdate the \nValuesController.cs\n file follows:\n\n\n...\n+ using Microsoft.Knowzy.OrdersAPI.Data;\n...\n   public class ValuesController : Controller\n{\n+        private IOrdersStore _ordersStore;\n+        public ValuesController(IOrdersStore ordersStore)\n+        {\n+            _ordersStore = ordersStore;\n+        }\n\n\n...\n    // GET api/values/5\n    [HttpGet(\"{id}\")]\n-    public string Get(int id)\n+    public async Task<string> Get(int id)\n    {\n-      return \"value\";\n+      var status = await _ordersStore.Connected() ? \"connected\" : \"not connected\";\n+      return $\"We are {status} to CosmosDB! and your value is {id}\";\n    }\n  }\n\n\n\n\nIf you now run the API app again and call \n/api/values/5\n on your API you should see \nWe are connected to CosmosDB! and your value is 5\n returned.\n\n\n3. Implement the Orders API\n\n\nNow it's time to implement the endpoints for the Shipping and Receiving controllers of our Orders API, running the API app as needed to verify your app locally.\n\n\nIn the \nMicrosoft.Knowzy.OrdersAPI\n add a project reference to the \nMicrosoft.Knowzy.Domain\n project. This reference has the model classes we will use in the Orders API for serialization.\n\n\nEdit the \nIOrdersStore.cs\n interface to add the GetShippings method:\n\n\n...\n+ using System.Collections.Generic;\n...\n    public interface IOrdersStore : IDisposable\n    {\n        Task<bool> Connected();\n\n+        IEnumerable<Domain.Shipping> GetShippings();\n    }\n\n\n\n\nAnd edit the \nOrdersStore.cs\n class to implement that method to return all orders:\n\n\n...\n+ using System.Collections.Generic;\n+ using System.Linq;\n...\n+        public IEnumerable<Domain.Shipping> GetShippings()\n+        {\n+            FeedOptions options = new FeedOptions();\n+            options.EnableCrossPartitionQuery = true;\n+\n+           return _client.CreateDocumentQuery<Domain.Shipping>(\n+               _ordersLink,\n+               \"SELECT * FROM orders o WHERE o.type='shipping'\",\n+               _options).ToList();\n+        }\n\n\n\n\nAdd a new class called \nShippingController.cs\n to the \nControllers\n folder to return all shipping orders in the Get method (choose to add a new class instead of a new Controller as we don't need the scaffolding from adding a Controller:\n\n\nusing System;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Knowzy.OrdersAPI.Data;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Controllers\n{\n    [Route(\"api/[controller]\")]\n    public class ShippingController : Controller\n    {\n        private IOrdersStore _ordersStore;\n        public ShippingController(IOrdersStore ordersStore)\n        {\n            _ordersStore = ordersStore;\n        }\n        // GET api/values\n        [HttpGet]\n        public IEnumerable<Domain.Shipping> Get()\n        {\n            return _ordersStore.GetShippings();\n        }\n    }\n}\n\n\n\n\nNow, when you run and browse your API to \n/api/Shipping\n you should get back the json array with all the shipping orders in the CosmosDB \norders\n collection.\n\n\nYou now need to finalize the Orders API. This is the full \nIOrderStore.cs\n interface:\n\n\nusing System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.Knowzy.Domain;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public interface IOrdersStore : IDisposable\n    {\n        Task<bool> Connected();\n        IEnumerable<Shipping> GetShippings();\n        Shipping GetShipping(string orderId);\n        IEnumerable<Receiving> GetReceivings();\n        Receiving GetReceiving(string orderId);\n        Task<Order> UpsertAsync(Domain.Order order);\n        Task DeleteOrderAsync(string orderId);\n        IEnumerable<PostalCarrier> GetPostalCarriers();\n    }\n}\n\n\n\n\nNote that CosmosDB \nsupports parameterized SQL queries\n to avoid SQL injection.\n\n\nUpdate \nOrdersStore.cs\n to implement the rest of the interface. This should be all you need to implement the rest of the Shipping controller and create the Receiving and PostalCarrier controllers.\n\n\nUpdate \nShippingController.cs\n to use your updated Orders Store class with Get(id), Put, Post and Delete methods. Use \nthis guide\n to help. \n\n\nCreate a new controller called \nReceivingController.cs\n to handle all the CRUD methods for Receiving. Note that this can share most of of the same \nOrderStore.cs\n methods you used for Shipping (both Shipping and Receiving domain classes implement the Order domain class).\n\n\nCreate a new controller called \nPostalCarrierController.cs\n to handle just the Get (read all) method for it. You can find the PostalCarriers inside the orders collection in CosmosDB. \n\n\n4. Package for release\n\n\nNow that we've got a working API app, let's package up all of our required files into a single folder for easy distribution. This time, we'll specify the Release configuration. \n\n\nOr from Visual Studio 2017, change the configuration to \nRelease\n, right click on the API project, select \nPublish\n, and choose \nFolder\n as the destination.\n\n\nBy default, this places your app files in a folder named \nbin/Release/PublishOutput\n. We'll use this output path in \nStep 4.1.4\n when we build a Docker image for our app.\n\n\n5. References\n\n\n\n\nTroubleshooting guide\n\n\n.NET Core CLI reference\n\n\nIntroduction to ASP.NET Core\n\n\nConfiguration in .NET Core\n\n\nAzure Cosmos DB: Getting started with the CosmosDB API and .NET Core\n\n\neShopOnContainers sample reference microservice and container based application\n\n\n\n\ncontinue to \nnext task >>",
            "title": "412 OrdersAPI"
        },
        {
            "location": "/stories/4/412_OrdersAPI/#task-412-create-api-endpoint-for-shipping-and-receiving-services",
            "text": "Now that you've created a database to store your data, it's time to create APIs to access that data.  Knowzy believes in a microservices based architecture so you'll need to start by creating a new API for orders so the Web app is not going directly to the database.  The end goal is a .NET Core based cross-platform solution. The architecture proposes a simplified microservice oriented architecture implementation with multiple autonomous microservices (each one owning its own data/db). The microservices will implement a simple CRUD approach using Http as the current communication protocol.",
            "title": "Task 4.1.2 - Create API endpoint for shipping and receiving services"
        },
        {
            "location": "/stories/4/412_OrdersAPI/#prerequisites",
            "text": "This task has a dependency on Tasks  1.1.1  and  4.1.1  and all of their prerequisites.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/4/412_OrdersAPI/#creating-a-net-core-app",
            "text": "",
            "title": "Creating a .NET Core App"
        },
        {
            "location": "/stories/4/412_OrdersAPI/#1-create-a-new-webapi-project",
            "text": "From Windows Explorer create a new folder called  APIs  in the  src\\2. Services  folder of the solution.  Open the  Microsoft.Knowzy  solution in Visual Studio 2017. Add a new solution folder called  APIs  to the  2. Services  folder. Create a new  ASP.NET Core Web Application  project called  Microsoft.Knowzy.OrdersAPI  in that folder:   Choose Web API for the project type, and leave the other options as they are (we will add Docker support later):   Let's test it out to make sure everything is working properly. In Visual Studio, right click on the project and select  Debug -> Start New Instance . Visual Studio will start a browser window for you to see your app running. Click the  Stop  button in Visual Studio to stop the API app.",
            "title": "1. Create a New WebAPI Project"
        },
        {
            "location": "/stories/4/412_OrdersAPI/#2-using-environment-variables-and-connecting-to-cosmosdb",
            "text": "In a real-world app, you won't check your secrets into source control, and you won't be writing local code that connects directly to your production data store. Depending on your environment, you might not even have access to production. To address these issues and see how they tie in with Docker, we're going to use the  COSMOSDB_ENDPOINT  and  COSMOSDB_KEY  environment variables.  The default Web API template already calls  .AddEnvironmentVariables()  (look for it in  Startup.cs ), so we just need to set a variable, then access it in our code.   Add these values to the Environment Variables section of the  Microsoft.Knowzy.OrdersAPI  project properties:   To use these environment variables in our code, we'll just pass the entire configuration object down to a new data access class.  In  Startup.cs , make the following changes:  public void ConfigureServices(IServiceConnection services)\n{\n  // Add framework services.\n  services.AddMvc();\n+ services.AddSingleton<IConfiguration>(Configuration);\n}  Now let's connect our solution to our data store in  CosmosDB  that was created as part of task  4.1.1 .   Start by adding a Nuget package reference to the latest stable version of  Microsoft.Azure.DocumentDB.Core  to the  Microsoft.Knowzy.OrdersAPI  project.  Add a new folder called  Data  to the  Microsoft.Knowzy.OrdersAPI  project. This folder will have the classes that interact with your CosmosDB data store.   Add a new interface called  IOrdersStore.cs  to the  Data  folder and populate it with the following:  using System;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public interface IOrdersStore : IDisposable\n    {\n        Task<bool> Connected();\n    }\n}  Add a new class called  OrdersStore.cs  to the  Data  folder and populate it with a method to check if it can connect to CosmosDB. Make sure to update the database and collection name in this code to match yours:  using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Azure.Documents.Client;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public class OrdersStore : IOrdersStore\n    {\n        private readonly DocumentClient _client;\n        private Uri _ordersLink;\n        public OrdersStore(IConfiguration config)\n        {\n            var EndpointUri = config[\"COSMOSDB_ENDPOINT\"];\n            var PrimaryKey = config[\"COSMOSDB_KEY\"];\n            _client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n            //Make sure the below values match your set up\n            _ordersLink = UriFactory.CreateDocumentCollectionUri(\"knowzydb\", \"orders\"); \n        }\n\n        public async Task<bool> Connected()\n        {\n            try\n            {\n                var db = await _client.GetDatabaseAccountAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        private bool disposedValue = false; // To detect redundant calls\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    _client.Dispose();\n                }\n                disposedValue = true;\n            }\n        }\n\n        void IDisposable.Dispose()\n        {\n            Dispose(true);\n        }\n    }\n}  Note how we are using the  ASP.NET Core dependency injection  to get the config instance passed into the class initializer for us, and with it we get the environment variable values. You can read more about configuration in ASP.NET Core in  this help article .  Modify  Startup.cs  and register our data access with the list of services (IoC):  public void ConfigureServices(IServiceConnection services)\n{\n  // Add framework services.\n  services.AddMvc();\n  services.AddSingleton<IConfiguration>(Configuration);\n+ services.AddSingleton<Data.IOrdersStore, Data.OrdersStore>();\n}  To test it outupdate the  ValuesController.cs  file follows:  ...\n+ using Microsoft.Knowzy.OrdersAPI.Data;\n...\n   public class ValuesController : Controller\n{\n+        private IOrdersStore _ordersStore;\n+        public ValuesController(IOrdersStore ordersStore)\n+        {\n+            _ordersStore = ordersStore;\n+        }\n\n\n...\n    // GET api/values/5\n    [HttpGet(\"{id}\")]\n-    public string Get(int id)\n+    public async Task<string> Get(int id)\n    {\n-      return \"value\";\n+      var status = await _ordersStore.Connected() ? \"connected\" : \"not connected\";\n+      return $\"We are {status} to CosmosDB! and your value is {id}\";\n    }\n  }  If you now run the API app again and call  /api/values/5  on your API you should see  We are connected to CosmosDB! and your value is 5  returned.",
            "title": "2. Using Environment Variables and Connecting to CosmosDB"
        },
        {
            "location": "/stories/4/412_OrdersAPI/#3-implement-the-orders-api",
            "text": "Now it's time to implement the endpoints for the Shipping and Receiving controllers of our Orders API, running the API app as needed to verify your app locally.  In the  Microsoft.Knowzy.OrdersAPI  add a project reference to the  Microsoft.Knowzy.Domain  project. This reference has the model classes we will use in the Orders API for serialization.  Edit the  IOrdersStore.cs  interface to add the GetShippings method:  ...\n+ using System.Collections.Generic;\n...\n    public interface IOrdersStore : IDisposable\n    {\n        Task<bool> Connected();\n\n+        IEnumerable<Domain.Shipping> GetShippings();\n    }  And edit the  OrdersStore.cs  class to implement that method to return all orders:  ...\n+ using System.Collections.Generic;\n+ using System.Linq;\n...\n+        public IEnumerable<Domain.Shipping> GetShippings()\n+        {\n+            FeedOptions options = new FeedOptions();\n+            options.EnableCrossPartitionQuery = true;\n+\n+           return _client.CreateDocumentQuery<Domain.Shipping>(\n+               _ordersLink,\n+               \"SELECT * FROM orders o WHERE o.type='shipping'\",\n+               _options).ToList();\n+        }  Add a new class called  ShippingController.cs  to the  Controllers  folder to return all shipping orders in the Get method (choose to add a new class instead of a new Controller as we don't need the scaffolding from adding a Controller:  using System;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Knowzy.OrdersAPI.Data;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Controllers\n{\n    [Route(\"api/[controller]\")]\n    public class ShippingController : Controller\n    {\n        private IOrdersStore _ordersStore;\n        public ShippingController(IOrdersStore ordersStore)\n        {\n            _ordersStore = ordersStore;\n        }\n        // GET api/values\n        [HttpGet]\n        public IEnumerable<Domain.Shipping> Get()\n        {\n            return _ordersStore.GetShippings();\n        }\n    }\n}  Now, when you run and browse your API to  /api/Shipping  you should get back the json array with all the shipping orders in the CosmosDB  orders  collection.  You now need to finalize the Orders API. This is the full  IOrderStore.cs  interface:  using System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.Knowzy.Domain;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public interface IOrdersStore : IDisposable\n    {\n        Task<bool> Connected();\n        IEnumerable<Shipping> GetShippings();\n        Shipping GetShipping(string orderId);\n        IEnumerable<Receiving> GetReceivings();\n        Receiving GetReceiving(string orderId);\n        Task<Order> UpsertAsync(Domain.Order order);\n        Task DeleteOrderAsync(string orderId);\n        IEnumerable<PostalCarrier> GetPostalCarriers();\n    }\n}  Note that CosmosDB  supports parameterized SQL queries  to avoid SQL injection.  Update  OrdersStore.cs  to implement the rest of the interface. This should be all you need to implement the rest of the Shipping controller and create the Receiving and PostalCarrier controllers.  Update  ShippingController.cs  to use your updated Orders Store class with Get(id), Put, Post and Delete methods. Use  this guide  to help.   Create a new controller called  ReceivingController.cs  to handle all the CRUD methods for Receiving. Note that this can share most of of the same  OrderStore.cs  methods you used for Shipping (both Shipping and Receiving domain classes implement the Order domain class).  Create a new controller called  PostalCarrierController.cs  to handle just the Get (read all) method for it. You can find the PostalCarriers inside the orders collection in CosmosDB.",
            "title": "3. Implement the Orders API"
        },
        {
            "location": "/stories/4/412_OrdersAPI/#4-package-for-release",
            "text": "Now that we've got a working API app, let's package up all of our required files into a single folder for easy distribution. This time, we'll specify the Release configuration.   Or from Visual Studio 2017, change the configuration to  Release , right click on the API project, select  Publish , and choose  Folder  as the destination.  By default, this places your app files in a folder named  bin/Release/PublishOutput . We'll use this output path in  Step 4.1.4  when we build a Docker image for our app.",
            "title": "4. Package for release"
        },
        {
            "location": "/stories/4/412_OrdersAPI/#5-references",
            "text": "Troubleshooting guide  .NET Core CLI reference  Introduction to ASP.NET Core  Configuration in .NET Core  Azure Cosmos DB: Getting started with the CosmosDB API and .NET Core  eShopOnContainers sample reference microservice and container based application",
            "title": "5. References"
        },
        {
            "location": "/stories/4/412_OrdersAPI/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/4/413_ProductsAPI/",
            "text": "Task 4.1.3 - Create API endpoint for product services\n\n\nYou've finished creating the Orders API, it's time to create one for Products.  \n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 4.1.2\n and all of its prerequisites.\n\n\n.NET Core SDK 1.1\n\n\n\n\nCreating a .NET Core App\n\n\n1. Create a New WebAPI Project\n\n\nOur steps to get started with the Products API are the same as our previous step where we created the \nOrders API\n. \n\n\nAgain you can use Visual Studio 2017 to create a new project in the \nsrc\\2. Services\\APIs\\Microsoft.Knowzy.ProductsAPI\n folder.\n\n\n2. Implement the Products API\n\n\nGo ahead and implement the Products API endpoints, using Visual Studio 2017 to test locally.\n\n\nImplement the following methods in the Products API that are used by the website:\n- Get all products\n- Get Product by id (includes product stock availability)\n- Add new product\n\n\n3. Package for release\n\n\nLike before, package the Products API using Visual Studio, then continue to \nTask 4.1.4 - Create Docker images\n. \n\n\n4. References\n\n\n\n\nTroubleshooting guide\n\n\nStep 4.1.2 - Orders API\n\n\n\n\ncontinue to \nnext task >>",
            "title": "413 ProductsAPI"
        },
        {
            "location": "/stories/4/413_ProductsAPI/#task-413-create-api-endpoint-for-product-services",
            "text": "You've finished creating the Orders API, it's time to create one for Products.",
            "title": "Task 4.1.3 - Create API endpoint for product services"
        },
        {
            "location": "/stories/4/413_ProductsAPI/#prerequisites",
            "text": "This task has a dependency on  Task 4.1.2  and all of its prerequisites.  .NET Core SDK 1.1",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/4/413_ProductsAPI/#creating-a-net-core-app",
            "text": "",
            "title": "Creating a .NET Core App"
        },
        {
            "location": "/stories/4/413_ProductsAPI/#1-create-a-new-webapi-project",
            "text": "Our steps to get started with the Products API are the same as our previous step where we created the  Orders API .   Again you can use Visual Studio 2017 to create a new project in the  src\\2. Services\\APIs\\Microsoft.Knowzy.ProductsAPI  folder.",
            "title": "1. Create a New WebAPI Project"
        },
        {
            "location": "/stories/4/413_ProductsAPI/#2-implement-the-products-api",
            "text": "Go ahead and implement the Products API endpoints, using Visual Studio 2017 to test locally.  Implement the following methods in the Products API that are used by the website:\n- Get all products\n- Get Product by id (includes product stock availability)\n- Add new product",
            "title": "2. Implement the Products API"
        },
        {
            "location": "/stories/4/413_ProductsAPI/#3-package-for-release",
            "text": "Like before, package the Products API using Visual Studio, then continue to  Task 4.1.4 - Create Docker images .",
            "title": "3. Package for release"
        },
        {
            "location": "/stories/4/413_ProductsAPI/#4-references",
            "text": "Troubleshooting guide  Step 4.1.2 - Orders API",
            "title": "4. References"
        },
        {
            "location": "/stories/4/413_ProductsAPI/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/4/414_Docker/",
            "text": "Task 4.1.4 - Create Docker images\n\n\n1. Prerequisites\n\n\n\n\nDocker for Windows\n (Stable channel)\n\n\n\n\na. Configuring Docker for Windows\n\n\nOn Windows, you'll need to share your drive with Docker in order to build images.\n\n\ni) Open up Docker settings by right-clicking the Docker icon in the taskbar, and choosing Settings\n\n\nii) Go to the \nShared Drives\n tab and share the C drive \n\n\n\n\nIf you receive a firewall error, try these \nTroubleshooting\n steps. \n\n\n2. Building Images\n\n\nIf you have Visual Studio 2017 you can have it create Docker files for you by simply:\n* Right click on the Microsoft.Knowzy.WebApp project, select \nAdd -> Docker Support\n. If you are on prompted for Target OS, choose \nLinux\n and click OK.\n\n\n\n\n\n\nThis will create a Dockerfile file in your WebApp project, and add a new docker-compose project type to your solution.\n\n\n\n\nUse the same instructions and add Docker Support to the Microsoft.Knowzy.OrdersAPI project \n\n\nUse the same instructions and add Docker Support to the Microsoft.Knowzy.ProductsAPI project\n\n\n\n\nIn the end you should have Dockerfile in each of those three projects, and all three referenced in your Docker compose project. \n\n\nNow under the \ndocker-compose.yml\n file, find the \ndocker-compose.override.yml\n file, and modify it with the following (changing the values of your CosmosDB endpoint and key):\n\n\nversion: '3'\n\nservices:\n  microsoft.knowzy.webapp:\n    environment:\n     - ASPNETCORE_ENVIRONMENT=Development\n     - ASPNETCORE_URLS=http://0.0.0.0:5101\n     - ORDERSAPI_URL=http://microsoft.knowzy.ordersapi:5102\n     - PRODUCTSAPI_URL=http://microsoft.knowzy.productsapi:5103\n    ports:\n      - \"5101:5101\"\n\n  microsoft.knowzy.ordersapi:\n    environment:\n      - ASPNETCORE_ENVIRONMENT=Development\n      - ASPNETCORE_URLS=http://0.0.0.0:5102\n      - COSMOSDB_ENDPOINT=<**YOUR COSMOSDB ENDPOINT**>\n      - COSMOSDB_KEY=<**YOUR KEY**>\n    ports:\n      - \"5102:5102\"\n\n  microsoft.knowzy.productsapi:\n    environment:\n      - ASPNETCORE_ENVIRONMENT=Development\n      - ASPNETCORE_URLS=http://0.0.0.0:5103\n      - COSMOSDB_ENDPOINT=<**YOUR COSMOSDB ENDPOINT**>\n      - COSMOSDB_KEY=<**YOUR KEY**>\n    ports:\n      - \"5103:5103\"\n\n\n\n\nYou can now start debugging the Docker Compose project; it will create all three Docker images and run them on your local dev environment.\n\n\nDockerfile Reference\n\n\nIf you're new to Docker, here's a quick overview of the Dockerfile for the Orders API, with an explanation for each statement\n\n\n# Use the aspnetcore image as a base\nFROM microsoft/aspnetcore:1.1\n\n# Create a variable called source that has the path of the publish directory\nARG source\n\n# Use /app inside the created container to hold our files\nWORKDIR /app\n\n# Expose port 80 from our created container. This gets overwritten by the docker compose override file\nEXPOSE 80\n\n# Copy from files in the source folder (or obj/Docker/publish if source was not set) into the current folder (/app). \nCOPY ${source:-obj/Docker/publish} .\n\n# The entrypoint for the container is the command: dotnet Microsoft.Knowzy.OrdersAPI.dll\nENTRYPOINT [\"dotnet\", \"Microsoft.Knowzy.OrdersAPI.dll\"]\n\n\n\n\n\n\nNote how we are using \ndotnet\n and the kestrel web server in the configuration to host the APIs and the Web App in their containers. For more information on hosting ASP.NET Core in production see this \narticle\n.\n\n\n\n\ndocker-compose.yml Reference\n\n\nAnd an overview of what's going on in the docker-compose file\n\n\nversion: '3'\n\nservices:\n\n  # Defines a service and gives it a name\n  microsoft.knowzy.webapp:\n\n    # The image tag (in Docker, tags are used as version numbers)\n    image: microsoft.knowzy.webapp\n\n    # Tell Docker to build a new image\n    build:\n      # Specify the location of the Dockerfile used to build the image\n      context: ./src/1. WebApp/Microsoft.Knowzy.WebApp\n      dockerfile: Dockerfile\n\n...\n\n\n\n\n3. Interacting with Docker via PowerShell\n\n\nYou've run your apps by debugging the docker-compose project in Visual Studio. Before you can push your images out to the world, you'll need to know a few things about interacting with Docker. Open up a PowerShell session in the \nKnowzy_Shipping_WebApp\n folder\n\n\n# List your running containers\ndocker ps\n\n\n\n\nCONTAINER ID        IMAGE                          COMMAND               CREATED             STATUS              PORTS                            NAMES\nb0ee3710499e        microsoft.knowzy.webapp        \"tail -f /dev/null\"   2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5101->5101/tcp   dockercompose9124822939927181477_microsoft.knowzy.webapp_1\n82a53378a7c6        microsoft.knowzy.ordersapi     \"tail -f /dev/null\"   2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5102->5102/tcp   dockercompose9124822939927181477_microsoft.knowzy.ordersapi_1\n88b91969038c        microsoft.knowzy.productsapi   \"tail -f /dev/null\"   2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5103->5103/tcp   dockercompose9124822939927181477_microsoft.knowzy.productsapi_1\n\n\n\n\nYou'll see that Visual Studio and Docker have generated 3 images, started 3 containers, and have grouped them all together with the same name prefix, in this case, \ndockercompose9124822939927181477\n.\n\n\nSince you've mapped host ports to containers, you're now able to interact with each of them on localhost by navigating to these urls:\n\n\n\n\nOrders API - \nhttp://localhost:5102/api/values/5\n\n\nProducts API - \nhttp://localhost:5103/api/values/5\n\n\nWeb App - \nhttp://localhost:5101\n\n\n\n\nDocker containers come and go frequently. You may want to practice and stop your currently running containers to free up some computing resources. In your PowerShell window, run the following, using your name prefix, which was displayed by \ndocker ps\n. \n\n\n# Remove resources for your named project\ndocker-compose -p <YOUR_NAME_PREFIX> down\n\n\n\n\nIf you want to spin up your containers again, you can debug the docker-compose project in Visual Studio, or interact directly via PowerShell by running the following commands\n\n\n# Create and start containers\n# -f: Use the compose & override files\n# -d: Detach (Run containers in the background)\n# --build: Build images before starting containers\ndocker-compose -f \"docker-compose.yml\" -f \"docker-compose.override.yml\" up -d --build\n\n# Remove containers. \n# Because we used the defaults, so we don't have to specify a project name\ndocker-compose down\n\n\n\n\nNote that you don't have to use Docker Compose to run your containers. You could do it all using just the \ndocker\n command to create / start / remove the containers, but higher level tooling can greatly increase your productivity.\n\n\nAfter you're done interacting with your containers, run the following to look at the images that you've built\n\n\ndocker image ls \n\n\n\n\nREPOSITORY                                                     TAG                 IMAGE ID            CREATED             SIZE\nmicrosoft.knowzy.productsapi                                   latest              0cf302713f5a        12 minutes ago      325 MB\nmicrosoft.knowzy.webapp                                        latest              a26d42ad4ecd        12 minutes ago      337 MB\nmicrosoft.knowzy.ordersapi                                     latest              f48275db75b4        12 minutes ago      325 MB\n\n\n\n\n4. Deploying to a Docker Registry\n\n\nSo far, you've developed a few applications, packaged them in Docker images, and have tested them in a production-like environment by running them inside a container on your local computer. To get your apps running in the cloud, your next step is to push your images to a Docker registry.\n\n\nYou can use \nAzure Container Registry\n to hold your images. There are a few reasons to do this. First, you want to make sure our images aren't available to just anyone on the Internet. You want to be able to control access to your images! You will also want your images to be available in the same region as your compute resources for quick deployments.\n\n\n a. Create an Azure Container Registry in Azure Cloud Shell\n\n\nUsing the Azure Cloud Shell, set up some variables for your registry. These will be specific to you:\n\n\n# Create some variables using Azure Cloud Shell\nRESOURCE_GROUP=myResourceGroup\nACR_NAME=buildtourregistry\n\n\n\n\n\n\nIf your resource group hasn't been created yet, the following command will create one in the East US region: \naz group create -n $RESOURCE_GROUP -l eastus\n\n\n\n\nNext, use an Azure CLI command to create your container registry. \n\n\nNote the use of the \n--admin-enabled\n switch, which enables a simple username/password logon. In a production environment, you'll likely want to disable this option and create a Service Principal, but this will get us up and running for now.\n\n\naz acr create --resource-group $RESOURCE_GROUP --name $ACR_NAME --sku Basic --admin-enabled\n\n\n\n\nYou're all set up with a registry, with the full name of \n$ACR_NAME.azurecr.io\n.\n\n\nExecute the following command to get the admin password for your newly created registry:\n\n\naz acr credential show -n $ACR_NAME -g $RESOURCE_GROUP\n\n\n\n\nb. Connect to Your Registry with PowerShell\n\n\nGo back to your PowerShell window and login to your registry so we can push some images. Run the following command, using either the \npassword\n or \npassword2\n result from the previous command as your password:\n\n\n# Set up PowerShell variables to match those used in the Cloud Shell\n# Again - these will be specific to you\n$ACR_NAME = \"buildtourregistry\"\n\ndocker login -u $ACR_NAME -p <your password> \"$ACR_NAME.azurecr.io\"\n\n\n\n\n\n\nIf you're having trouble copy/pasting the password from the Azure Cloud Shell to PowerShell, try highlighting your password and making sure your cursor is over the highlighted text, and then right click\n\n\n\n\nc. Push an Image\n\n\nYou've already got some tagged images, and now you need to tell Docker that they're associated with your newly created registry. You'll specify the \nknowzy\n namespace before pushing them to keep these apps grouped together. This is as simple as adding another tag for our existing images, using the following commands.\n\n\n# Add additional tags to the existing images\ndocker tag microsoft.knowzy.ordersapi \"$ACR_NAME.azurecr.io/knowzy/ordersapi:1\"\ndocker tag microsoft.knowzy.productsapi \"$ACR_NAME.azurecr.io/knowzy/productsapi:1\"\ndocker tag microsoft.knowzy.webapp \"$ACR_NAME.azurecr.io/knowzy/webapp:1\"\n\n# View the new tags. Notice there are multiple tags for the same image id\ndocker image ls\n\n\n\n\nTo push images to your registry, use the following commands:\n\n\n# The first push will take a moment\ndocker push \"$ACR_NAME.azurecr.io/knowzy/ordersapi:1\"\n\n# The subsequent images will be much faster because they use a common base image\ndocker push \"$ACR_NAME.azurecr.io/knowzy/productsapi:1\"\ndocker push \"$ACR_NAME.azurecr.io/knowzy/webapp:1\"\n\n\n\n\nWhen finished, you can look at your images in your Azure Container Registry by using the following commands in the Azure Cloud Shell:\n\n\n# Use the Cloud Shell to inspect your registry\naz acr repository list -n $ACR_NAME\naz acr repository show-tags -n $ACR_NAME --repository knowzy/ordersapi\n\n\n\n\n4. References\n\n\n\n\nTroubleshooting guide\n\n\nDockerfile reference\n\n\nDocker CLI reference\n\n\nAzure CLI reference\n\n\nAzure Container Registry reference\n\n\n\n\ncontinue to \nnext task >>",
            "title": "414 Docker"
        },
        {
            "location": "/stories/4/414_Docker/#task-414-create-docker-images",
            "text": "",
            "title": "Task 4.1.4 - Create Docker images"
        },
        {
            "location": "/stories/4/414_Docker/#1-prerequisites",
            "text": "Docker for Windows  (Stable channel)",
            "title": "1. Prerequisites"
        },
        {
            "location": "/stories/4/414_Docker/#a-configuring-docker-for-windows",
            "text": "On Windows, you'll need to share your drive with Docker in order to build images.  i) Open up Docker settings by right-clicking the Docker icon in the taskbar, and choosing Settings  ii) Go to the  Shared Drives  tab and share the C drive    If you receive a firewall error, try these  Troubleshooting  steps.",
            "title": "a. Configuring Docker for Windows"
        },
        {
            "location": "/stories/4/414_Docker/#2-building-images",
            "text": "If you have Visual Studio 2017 you can have it create Docker files for you by simply:\n* Right click on the Microsoft.Knowzy.WebApp project, select  Add -> Docker Support . If you are on prompted for Target OS, choose  Linux  and click OK.    This will create a Dockerfile file in your WebApp project, and add a new docker-compose project type to your solution.   Use the same instructions and add Docker Support to the Microsoft.Knowzy.OrdersAPI project   Use the same instructions and add Docker Support to the Microsoft.Knowzy.ProductsAPI project   In the end you should have Dockerfile in each of those three projects, and all three referenced in your Docker compose project.   Now under the  docker-compose.yml  file, find the  docker-compose.override.yml  file, and modify it with the following (changing the values of your CosmosDB endpoint and key):  version: '3'\n\nservices:\n  microsoft.knowzy.webapp:\n    environment:\n     - ASPNETCORE_ENVIRONMENT=Development\n     - ASPNETCORE_URLS=http://0.0.0.0:5101\n     - ORDERSAPI_URL=http://microsoft.knowzy.ordersapi:5102\n     - PRODUCTSAPI_URL=http://microsoft.knowzy.productsapi:5103\n    ports:\n      - \"5101:5101\"\n\n  microsoft.knowzy.ordersapi:\n    environment:\n      - ASPNETCORE_ENVIRONMENT=Development\n      - ASPNETCORE_URLS=http://0.0.0.0:5102\n      - COSMOSDB_ENDPOINT=<**YOUR COSMOSDB ENDPOINT**>\n      - COSMOSDB_KEY=<**YOUR KEY**>\n    ports:\n      - \"5102:5102\"\n\n  microsoft.knowzy.productsapi:\n    environment:\n      - ASPNETCORE_ENVIRONMENT=Development\n      - ASPNETCORE_URLS=http://0.0.0.0:5103\n      - COSMOSDB_ENDPOINT=<**YOUR COSMOSDB ENDPOINT**>\n      - COSMOSDB_KEY=<**YOUR KEY**>\n    ports:\n      - \"5103:5103\"  You can now start debugging the Docker Compose project; it will create all three Docker images and run them on your local dev environment.",
            "title": "2. Building Images"
        },
        {
            "location": "/stories/4/414_Docker/#dockerfile-reference",
            "text": "If you're new to Docker, here's a quick overview of the Dockerfile for the Orders API, with an explanation for each statement  # Use the aspnetcore image as a base\nFROM microsoft/aspnetcore:1.1\n\n# Create a variable called source that has the path of the publish directory\nARG source\n\n# Use /app inside the created container to hold our files\nWORKDIR /app\n\n# Expose port 80 from our created container. This gets overwritten by the docker compose override file\nEXPOSE 80\n\n# Copy from files in the source folder (or obj/Docker/publish if source was not set) into the current folder (/app). \nCOPY ${source:-obj/Docker/publish} .\n\n# The entrypoint for the container is the command: dotnet Microsoft.Knowzy.OrdersAPI.dll\nENTRYPOINT [\"dotnet\", \"Microsoft.Knowzy.OrdersAPI.dll\"]   Note how we are using  dotnet  and the kestrel web server in the configuration to host the APIs and the Web App in their containers. For more information on hosting ASP.NET Core in production see this  article .",
            "title": "Dockerfile Reference"
        },
        {
            "location": "/stories/4/414_Docker/#docker-composeyml-reference",
            "text": "And an overview of what's going on in the docker-compose file  version: '3'\n\nservices:\n\n  # Defines a service and gives it a name\n  microsoft.knowzy.webapp:\n\n    # The image tag (in Docker, tags are used as version numbers)\n    image: microsoft.knowzy.webapp\n\n    # Tell Docker to build a new image\n    build:\n      # Specify the location of the Dockerfile used to build the image\n      context: ./src/1. WebApp/Microsoft.Knowzy.WebApp\n      dockerfile: Dockerfile\n\n...",
            "title": "docker-compose.yml Reference"
        },
        {
            "location": "/stories/4/414_Docker/#3-interacting-with-docker-via-powershell",
            "text": "You've run your apps by debugging the docker-compose project in Visual Studio. Before you can push your images out to the world, you'll need to know a few things about interacting with Docker. Open up a PowerShell session in the  Knowzy_Shipping_WebApp  folder  # List your running containers\ndocker ps  CONTAINER ID        IMAGE                          COMMAND               CREATED             STATUS              PORTS                            NAMES\nb0ee3710499e        microsoft.knowzy.webapp        \"tail -f /dev/null\"   2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5101->5101/tcp   dockercompose9124822939927181477_microsoft.knowzy.webapp_1\n82a53378a7c6        microsoft.knowzy.ordersapi     \"tail -f /dev/null\"   2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5102->5102/tcp   dockercompose9124822939927181477_microsoft.knowzy.ordersapi_1\n88b91969038c        microsoft.knowzy.productsapi   \"tail -f /dev/null\"   2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5103->5103/tcp   dockercompose9124822939927181477_microsoft.knowzy.productsapi_1  You'll see that Visual Studio and Docker have generated 3 images, started 3 containers, and have grouped them all together with the same name prefix, in this case,  dockercompose9124822939927181477 .  Since you've mapped host ports to containers, you're now able to interact with each of them on localhost by navigating to these urls:   Orders API -  http://localhost:5102/api/values/5  Products API -  http://localhost:5103/api/values/5  Web App -  http://localhost:5101   Docker containers come and go frequently. You may want to practice and stop your currently running containers to free up some computing resources. In your PowerShell window, run the following, using your name prefix, which was displayed by  docker ps .   # Remove resources for your named project\ndocker-compose -p <YOUR_NAME_PREFIX> down  If you want to spin up your containers again, you can debug the docker-compose project in Visual Studio, or interact directly via PowerShell by running the following commands  # Create and start containers\n# -f: Use the compose & override files\n# -d: Detach (Run containers in the background)\n# --build: Build images before starting containers\ndocker-compose -f \"docker-compose.yml\" -f \"docker-compose.override.yml\" up -d --build\n\n# Remove containers. \n# Because we used the defaults, so we don't have to specify a project name\ndocker-compose down  Note that you don't have to use Docker Compose to run your containers. You could do it all using just the  docker  command to create / start / remove the containers, but higher level tooling can greatly increase your productivity.  After you're done interacting with your containers, run the following to look at the images that you've built  docker image ls   REPOSITORY                                                     TAG                 IMAGE ID            CREATED             SIZE\nmicrosoft.knowzy.productsapi                                   latest              0cf302713f5a        12 minutes ago      325 MB\nmicrosoft.knowzy.webapp                                        latest              a26d42ad4ecd        12 minutes ago      337 MB\nmicrosoft.knowzy.ordersapi                                     latest              f48275db75b4        12 minutes ago      325 MB",
            "title": "3. Interacting with Docker via PowerShell"
        },
        {
            "location": "/stories/4/414_Docker/#4-deploying-to-a-docker-registry",
            "text": "So far, you've developed a few applications, packaged them in Docker images, and have tested them in a production-like environment by running them inside a container on your local computer. To get your apps running in the cloud, your next step is to push your images to a Docker registry.  You can use  Azure Container Registry  to hold your images. There are a few reasons to do this. First, you want to make sure our images aren't available to just anyone on the Internet. You want to be able to control access to your images! You will also want your images to be available in the same region as your compute resources for quick deployments.",
            "title": "4. Deploying to a Docker Registry"
        },
        {
            "location": "/stories/4/414_Docker/#b-connect-to-your-registry-with-powershell",
            "text": "Go back to your PowerShell window and login to your registry so we can push some images. Run the following command, using either the  password  or  password2  result from the previous command as your password:  # Set up PowerShell variables to match those used in the Cloud Shell\n# Again - these will be specific to you\n$ACR_NAME = \"buildtourregistry\"\n\ndocker login -u $ACR_NAME -p <your password> \"$ACR_NAME.azurecr.io\"   If you're having trouble copy/pasting the password from the Azure Cloud Shell to PowerShell, try highlighting your password and making sure your cursor is over the highlighted text, and then right click",
            "title": "b. Connect to Your Registry with PowerShell"
        },
        {
            "location": "/stories/4/414_Docker/#c-push-an-image",
            "text": "You've already got some tagged images, and now you need to tell Docker that they're associated with your newly created registry. You'll specify the  knowzy  namespace before pushing them to keep these apps grouped together. This is as simple as adding another tag for our existing images, using the following commands.  # Add additional tags to the existing images\ndocker tag microsoft.knowzy.ordersapi \"$ACR_NAME.azurecr.io/knowzy/ordersapi:1\"\ndocker tag microsoft.knowzy.productsapi \"$ACR_NAME.azurecr.io/knowzy/productsapi:1\"\ndocker tag microsoft.knowzy.webapp \"$ACR_NAME.azurecr.io/knowzy/webapp:1\"\n\n# View the new tags. Notice there are multiple tags for the same image id\ndocker image ls  To push images to your registry, use the following commands:  # The first push will take a moment\ndocker push \"$ACR_NAME.azurecr.io/knowzy/ordersapi:1\"\n\n# The subsequent images will be much faster because they use a common base image\ndocker push \"$ACR_NAME.azurecr.io/knowzy/productsapi:1\"\ndocker push \"$ACR_NAME.azurecr.io/knowzy/webapp:1\"  When finished, you can look at your images in your Azure Container Registry by using the following commands in the Azure Cloud Shell:  # Use the Cloud Shell to inspect your registry\naz acr repository list -n $ACR_NAME\naz acr repository show-tags -n $ACR_NAME --repository knowzy/ordersapi",
            "title": "c. Push an Image"
        },
        {
            "location": "/stories/4/414_Docker/#4-references",
            "text": "Troubleshooting guide  Dockerfile reference  Docker CLI reference  Azure CLI reference  Azure Container Registry reference",
            "title": "4. References"
        },
        {
            "location": "/stories/4/414_Docker/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/4/415_Kubernetes/",
            "text": "Task 4.1.5 - Deploy to Kubernetes on Azure Container Services\n\n\n1. Prerequisites\n\n\n\n\nAccess to Azure subscription.\n\n\nAzure Cloud Shell should be \nConfigured for persistent shell storage\n.\n\n\nAzure Cloud shell should be pointed toward the correct subscription, more details in \nStep 4.1.1\n\n\nYou'll also need the name of the resource group created in \nStep 4.1.1\n\n\n\n\n2. Creating and deploying to a Kubernetes cluster in Azure Container Service\n\n\na. Set up the cluster with Azure Cloud Shell\n\n\nWe're going to be working within the Azure Cloud Shell. Lets start by setting up a few variables:\n\n\n# Use the name of the Resource Group created in 4.1.1 if this is not the same Cloud Shell session\nRESOURCE_GROUP=<resource group name>\n\n# A unique DNS Prefix for your cluster, which will also be the Kubernetes cluster name\nDNS_PREFIX=<unique cluster name>\n\n# The name for the ACS Instance\nACS_NAME=<unique ACS instance name>\n\n\n\n\nb. Create the cluster using the Azure CLI\n\n\nWe'll add the \n--generate-ssh-keys\n parameter which generates the necessary SSH key files for the deployment if they don't exist already in the default \n~/.ssh/\n directory.\n\n\n\n\nThese keys are needed to grant access to the cluster, and will be stored in the Storage Account created for your Cloud Shell. You can learn more by visiting the \nCloud Shell documentation\n\n\n\n\naz acs create --orchestrator-type=kubernetes --agent-vm-size Standard_A1 --resource-group $RESOURCE_GROUP --name=$ACS_NAME --dns-prefix=$DNS_PREFIX --generate-ssh-keys\n\n\n\n\nThis will take several minutes as your resources are created and configured. Once your cluster is created, you'll need to get the config from Kubernetes into your Cloud Shell session so that you can interact with it.\n\n\naz acs kubernetes get-credentials --resource-group=$RESOURCE_GROUP --name=$ACS_NAME\n\n\n\n\nVerify that you can used \nkubectl\n to talk to the cluster\n\n\nkubectl cluster-info\n\n\n\n\nc. Deploying your container images \n(from \nStep 4.1.4\n)\n\n\ni) Store the name of your Azure Container Registry\n\n\nThis registry was generated in step \n4.1.4\n, and is where the images containing the apps and services we want to deploy are located.\n\n\nACR_NAME=<name of registry that contains your images>\n\n\n\n\nii) Deploy your two services from their respective Docker images. We can deploy by telling kubernetes to get the docker images and deploy them, using the run command in \nkubectl\n, we're passing the \n--env\n parameter, to tell the container images the connection string for your data-store, so the running services once deployed know how to connect to the CosmosDB.\n\n\n# Deploy to Kubernetes\nkubectl run ordersapi --image=$ACR_NAME.azurecr.io/knowzy/ordersapi:1 --env \"COSMOSDB_ENDPOINT=https://<< your cosmosdb name>>.documents.azure.com:443/\" --env \"COSMOSDB_KEY=<your Cosmos DB key string>\"\nkubectl run productsapi --image=$ACR_NAME.azurecr.io/knowzy/productsapi:1 --env \"COSMOSDB_ENDPOINT=https://<< your cosmosdb name>>.documents.azure.com:443/\" --env \"COSMOSDB_KEY=<your Cosmos DB key string>\"\nkubectl run webapp --image=$ACR_NAME.azurecr.io/knowzy/webapp:1\n\n# View your running pods\nkubectl get pods\n\n\n\n\niii) Expose your services\n\n\nYou've got containers running on Kubernetes, but they're not yet exposed to the outside world. Let's do that now\n\n\n# This will create an Azure Load Balancer to direct traffic to your app\nkubectl expose deployment ordersapi --port=80 --type=LoadBalancer\nkubectl expose deployment productsapi --port=80 --type=LoadBalancer\n\n# List Kubernetes services, which includes the external IP\nkubectl get svc\n\n\n\n\nNAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE\nkubernetes   10.0.0.1     <none>        443/TCP        2d\nordersapi    10.0.8.27    <pending>     80:30213/TCP   3h\nproductsapi  10.0.8.28    <pending>     80:30175/TCP   19s\n\n\n\n\nInitially, you will see something similar to the above. Wait a couple of minutes for the IP's and load balancers to be provisioned, and re-run \nkubectl get svc\n to see your public-facing IP's.\n\n\nNAME          CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE\nkubernetes    10.0.0.1       <none>          443/TCP          2d\nordersapi     10.0.8.27      13.81.60.236    80:30213/TCP     3h\nproductsapi   10.0.8.28      52.232.72.172   80:30175/TCP     5m\n\n\n\n\nYou can test your deployment as soon as the \n<pending>\n external IP is provided. Simply go into your browser to the url provided \nhttp://<<External IP>>/api/values\n.\n\n\niii) Deploy your webapp from the Docker image. We deploy the same way as above, but we don't need the database parameter, as the front end web application should have no direct access to the CosmosDB. Instead we should provide the url to the api services\n\n\nkubectl run webapp --image=$ACR_NAME.azurecr.io/knowzy/webapp:1 --env \"PRODUCTSAPI_URL=<<Orders API IP>>\" --env \"ORDERAPI_URL=<<Orders API IP>>\"\n\n\n\n\niv) Expose your webapp and consume your APIs\n\n\nkubectl expose deployment webapp --port=80 --type=LoadBalancer\n\n\n\n\nWait for the IP to come back \nkubectl get sv\n and access it in your browser\n\n\nNAME          CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE\nkubernetes    10.0.0.1       <none>          443/TCP          2d\nordersapi     10.0.8.27      13.8.60.236    8080:30213/TCP   3h\nproductsapi   10.0.148.198   52.232.72.12   80:30175/TCP     5m\nwebapp   10.0.142.191   54.22.172.17   80:31945/TCP     5m\n\n\n\n\n3. References\n\n\n\n\nPersisting Files in Azure Cloud Shell\n\n\nAzure resource naming best practices\n\n\nAzure CLI reference\n\n\nkubectl overview\n\n\n\n\ncontinue to \nnext task >>",
            "title": "415 Kubernetes"
        },
        {
            "location": "/stories/4/415_Kubernetes/#task-415-deploy-to-kubernetes-on-azure-container-services",
            "text": "",
            "title": "Task 4.1.5 - Deploy to Kubernetes on Azure Container Services"
        },
        {
            "location": "/stories/4/415_Kubernetes/#1-prerequisites",
            "text": "Access to Azure subscription.  Azure Cloud Shell should be  Configured for persistent shell storage .  Azure Cloud shell should be pointed toward the correct subscription, more details in  Step 4.1.1  You'll also need the name of the resource group created in  Step 4.1.1",
            "title": "1. Prerequisites"
        },
        {
            "location": "/stories/4/415_Kubernetes/#2-creating-and-deploying-to-a-kubernetes-cluster-in-azure-container-service",
            "text": "",
            "title": "2. Creating and deploying to a Kubernetes cluster in Azure Container Service"
        },
        {
            "location": "/stories/4/415_Kubernetes/#a-set-up-the-cluster-with-azure-cloud-shell",
            "text": "We're going to be working within the Azure Cloud Shell. Lets start by setting up a few variables:  # Use the name of the Resource Group created in 4.1.1 if this is not the same Cloud Shell session\nRESOURCE_GROUP=<resource group name>\n\n# A unique DNS Prefix for your cluster, which will also be the Kubernetes cluster name\nDNS_PREFIX=<unique cluster name>\n\n# The name for the ACS Instance\nACS_NAME=<unique ACS instance name>",
            "title": "a. Set up the cluster with Azure Cloud Shell"
        },
        {
            "location": "/stories/4/415_Kubernetes/#b-create-the-cluster-using-the-azure-cli",
            "text": "We'll add the  --generate-ssh-keys  parameter which generates the necessary SSH key files for the deployment if they don't exist already in the default  ~/.ssh/  directory.   These keys are needed to grant access to the cluster, and will be stored in the Storage Account created for your Cloud Shell. You can learn more by visiting the  Cloud Shell documentation   az acs create --orchestrator-type=kubernetes --agent-vm-size Standard_A1 --resource-group $RESOURCE_GROUP --name=$ACS_NAME --dns-prefix=$DNS_PREFIX --generate-ssh-keys  This will take several minutes as your resources are created and configured. Once your cluster is created, you'll need to get the config from Kubernetes into your Cloud Shell session so that you can interact with it.  az acs kubernetes get-credentials --resource-group=$RESOURCE_GROUP --name=$ACS_NAME  Verify that you can used  kubectl  to talk to the cluster  kubectl cluster-info",
            "title": "b. Create the cluster using the Azure CLI"
        },
        {
            "location": "/stories/4/415_Kubernetes/#c-deploying-your-container-images-from-step-414",
            "text": "i) Store the name of your Azure Container Registry  This registry was generated in step  4.1.4 , and is where the images containing the apps and services we want to deploy are located.  ACR_NAME=<name of registry that contains your images>  ii) Deploy your two services from their respective Docker images. We can deploy by telling kubernetes to get the docker images and deploy them, using the run command in  kubectl , we're passing the  --env  parameter, to tell the container images the connection string for your data-store, so the running services once deployed know how to connect to the CosmosDB.  # Deploy to Kubernetes\nkubectl run ordersapi --image=$ACR_NAME.azurecr.io/knowzy/ordersapi:1 --env \"COSMOSDB_ENDPOINT=https://<< your cosmosdb name>>.documents.azure.com:443/\" --env \"COSMOSDB_KEY=<your Cosmos DB key string>\"\nkubectl run productsapi --image=$ACR_NAME.azurecr.io/knowzy/productsapi:1 --env \"COSMOSDB_ENDPOINT=https://<< your cosmosdb name>>.documents.azure.com:443/\" --env \"COSMOSDB_KEY=<your Cosmos DB key string>\"\nkubectl run webapp --image=$ACR_NAME.azurecr.io/knowzy/webapp:1\n\n# View your running pods\nkubectl get pods  iii) Expose your services  You've got containers running on Kubernetes, but they're not yet exposed to the outside world. Let's do that now  # This will create an Azure Load Balancer to direct traffic to your app\nkubectl expose deployment ordersapi --port=80 --type=LoadBalancer\nkubectl expose deployment productsapi --port=80 --type=LoadBalancer\n\n# List Kubernetes services, which includes the external IP\nkubectl get svc  NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE\nkubernetes   10.0.0.1     <none>        443/TCP        2d\nordersapi    10.0.8.27    <pending>     80:30213/TCP   3h\nproductsapi  10.0.8.28    <pending>     80:30175/TCP   19s  Initially, you will see something similar to the above. Wait a couple of minutes for the IP's and load balancers to be provisioned, and re-run  kubectl get svc  to see your public-facing IP's.  NAME          CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE\nkubernetes    10.0.0.1       <none>          443/TCP          2d\nordersapi     10.0.8.27      13.81.60.236    80:30213/TCP     3h\nproductsapi   10.0.8.28      52.232.72.172   80:30175/TCP     5m  You can test your deployment as soon as the  <pending>  external IP is provided. Simply go into your browser to the url provided  http://<<External IP>>/api/values .  iii) Deploy your webapp from the Docker image. We deploy the same way as above, but we don't need the database parameter, as the front end web application should have no direct access to the CosmosDB. Instead we should provide the url to the api services  kubectl run webapp --image=$ACR_NAME.azurecr.io/knowzy/webapp:1 --env \"PRODUCTSAPI_URL=<<Orders API IP>>\" --env \"ORDERAPI_URL=<<Orders API IP>>\"  iv) Expose your webapp and consume your APIs  kubectl expose deployment webapp --port=80 --type=LoadBalancer  Wait for the IP to come back  kubectl get sv  and access it in your browser  NAME          CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE\nkubernetes    10.0.0.1       <none>          443/TCP          2d\nordersapi     10.0.8.27      13.8.60.236    8080:30213/TCP   3h\nproductsapi   10.0.148.198   52.232.72.12   80:30175/TCP     5m\nwebapp   10.0.142.191   54.22.172.17   80:31945/TCP     5m",
            "title": "c. Deploying your container images (from Step 4.1.4)"
        },
        {
            "location": "/stories/4/415_Kubernetes/#3-references",
            "text": "Persisting Files in Azure Cloud Shell  Azure resource naming best practices  Azure CLI reference  kubectl overview",
            "title": "3. References"
        },
        {
            "location": "/stories/4/415_Kubernetes/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/4/416_Integrate/",
            "text": "Task 4.1.6 - Integrate Website and APIs\n\n\nNow that the APIs and the website and clients have been implemented, our team wants to integrate the website code with the APIs. \n\n\nPrerequisites\n\n\nThis task has a dependency on the Web App from \n1.1.1\n, the APIs created under section \n4.1.2\n and \n4.1.3\n, and the deployment to Kubernetes steps in section \n4.1.5\n, and all of their prerequisites.\n\n\nTask\n\n\n\n\n\n\nUpdate the website code to use the APIs instead of static files for data access.\n\n\n\n\n\n\nRedeploy the website with the updates.\n\n\n\n\n\n\nComments\n\n\n@ 9:02am\n\n\nI looked at the website code, and it seems to currently use a mock implementation of the API/data access. It's getting the initial data from static json files, and keeping the data in memory. In order to override the existing implementation for accesing data and integrate with the APIs we should implement the \nIOrderRepository\n interface whith our own custom class implementation that calls the APIs (using \nOrderRepositoryMock.cs\n as guidance), and then change the service configuration in \nStartup.cs\n class adding the new implementation files:\n\n\nc#\nservices.AddScoped<IOrderRepository, OrderRepository>();\n\n\n@ 11:15am\n\n\nIn the Docker instructions in \n4.1.4\n for the dev machine, and Kubernetes instructions in \n4.1.5\n the web app container has the ORDERSAPI_URL and PRODUCTSAPI_URL environment variables with the two API endpoints URLs passed in to it. Now we can run website in the dev machine and deploy it via kubernetes again to get it to use the APIs.\n\n\ncontinue to \nnext task >>",
            "title": "416 Integrate"
        },
        {
            "location": "/stories/4/416_Integrate/#task-416-integrate-website-and-apis",
            "text": "Now that the APIs and the website and clients have been implemented, our team wants to integrate the website code with the APIs.",
            "title": "Task 4.1.6 - Integrate Website and APIs"
        },
        {
            "location": "/stories/4/416_Integrate/#prerequisites",
            "text": "This task has a dependency on the Web App from  1.1.1 , the APIs created under section  4.1.2  and  4.1.3 , and the deployment to Kubernetes steps in section  4.1.5 , and all of their prerequisites.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/4/416_Integrate/#task",
            "text": "Update the website code to use the APIs instead of static files for data access.    Redeploy the website with the updates.",
            "title": "Task"
        },
        {
            "location": "/stories/4/416_Integrate/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/4/416_Integrate/#902am",
            "text": "I looked at the website code, and it seems to currently use a mock implementation of the API/data access. It's getting the initial data from static json files, and keeping the data in memory. In order to override the existing implementation for accesing data and integrate with the APIs we should implement the  IOrderRepository  interface whith our own custom class implementation that calls the APIs (using  OrderRepositoryMock.cs  as guidance), and then change the service configuration in  Startup.cs  class adding the new implementation files:  c#\nservices.AddScoped<IOrderRepository, OrderRepository>();",
            "title": "@ 9:02am"
        },
        {
            "location": "/stories/4/416_Integrate/#1115am",
            "text": "In the Docker instructions in  4.1.4  for the dev machine, and Kubernetes instructions in  4.1.5  the web app container has the ORDERSAPI_URL and PRODUCTSAPI_URL environment variables with the two API endpoints URLs passed in to it. Now we can run website in the dev machine and deploy it via kubernetes again to get it to use the APIs.",
            "title": "@ 11:15am"
        },
        {
            "location": "/stories/4/416_Integrate/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/4/421_SetupVSTS/",
            "text": "Task 4.2.1 - Setup Visual Studio Team Services\n\n\nIn order to collaborate as a team, it would be best to store your source code in a Version Control System.  While there are many options for this, the CTO of Knowzy has asked you to use Visual Studio Team Services (VSTS) so that later on your can use it for Continuous Integration, Continuous Delivery, program management, and project planning.  In this task, you'll set up a VSTS instance to share with the team.\n\n\nPrerequisites\n\n\nThe only prerequisite for this task is that you have a Microsoft account.  If you do not already have one you can \nsign up for one here\n.\n\n\nTask\n\n\n\n\nSign up for a free Visual Studio Team Services account. \n\n\n\n\nOR\n\n\n\n\nSelect a Visual Studio Team Services account you already have access to and can share with your team.\n\n\n\n\nReferences\n\n\n\n\nVisual Studio Team Services landing page\n\n\n\n\ncontinue to \nnext task >>",
            "title": "421 SetupVSTS"
        },
        {
            "location": "/stories/4/421_SetupVSTS/#task-421-setup-visual-studio-team-services",
            "text": "In order to collaborate as a team, it would be best to store your source code in a Version Control System.  While there are many options for this, the CTO of Knowzy has asked you to use Visual Studio Team Services (VSTS) so that later on your can use it for Continuous Integration, Continuous Delivery, program management, and project planning.  In this task, you'll set up a VSTS instance to share with the team.",
            "title": "Task 4.2.1 - Setup Visual Studio Team Services"
        },
        {
            "location": "/stories/4/421_SetupVSTS/#prerequisites",
            "text": "The only prerequisite for this task is that you have a Microsoft account.  If you do not already have one you can  sign up for one here .",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/4/421_SetupVSTS/#task",
            "text": "Sign up for a free Visual Studio Team Services account.    OR   Select a Visual Studio Team Services account you already have access to and can share with your team.",
            "title": "Task"
        },
        {
            "location": "/stories/4/421_SetupVSTS/#references",
            "text": "Visual Studio Team Services landing page",
            "title": "References"
        },
        {
            "location": "/stories/4/421_SetupVSTS/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/4/422_DevopsKubernetes/",
            "text": "Challenge 4.2.2 - Continuous Delivery to Kubernetes using VSTS\n\n\nThe CTO is pleased that you've deployed to Azure and Kubernetes.  However, now they'd like you to set up Continuous Delivery using the Visual Studio Team Services (VSTS) account you set up in \nTask 4.2.1\n.  Using VSTS will enable our development and operations department to have work together efficiently as a team and push new stable releases into production. The primary goal of this challenge is to automatically post a new release of our code into our production Kubernetes cluster with any commit to our git repository.\n\n\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 4.1.5\n, \nTask 4.2.1\n, and all of their prerequisites.\n\n\nAccess to the Azure subscription you used in \nTask 4.1.5\n.\n\n\n\n\nTask\n\n\n\n\nSet up CI / CD with your application and Kubernetes on Azure.\n\n\n\n\nComments\n\n\n@ 3:37am\n\n\nI wasn't really sure where to get started with continuous integration or delivery but \nthis\n really helped me understand!\n\n\n@ 5:23am\n\n\nIt looks like you can install the \nKubernetes Extension for VSTS here\n.\n\n\n@ 10:15am\n\n\nI think I found \nstep by step instructions\n on setting this up!\n\n\n@ 4:58pm\n\n\nIf all goes according to plan, I should be able to demonstrate this working by \nfollowing this\n.\n\n\ncontinue to \nnext task >>",
            "title": "422 DevopsKubernetes"
        },
        {
            "location": "/stories/4/422_DevopsKubernetes/#challenge-422-continuous-delivery-to-kubernetes-using-vsts",
            "text": "The CTO is pleased that you've deployed to Azure and Kubernetes.  However, now they'd like you to set up Continuous Delivery using the Visual Studio Team Services (VSTS) account you set up in  Task 4.2.1 .  Using VSTS will enable our development and operations department to have work together efficiently as a team and push new stable releases into production. The primary goal of this challenge is to automatically post a new release of our code into our production Kubernetes cluster with any commit to our git repository.",
            "title": "Challenge 4.2.2 - Continuous Delivery to Kubernetes using VSTS"
        },
        {
            "location": "/stories/4/422_DevopsKubernetes/#prerequisites",
            "text": "This task has a dependency on  Task 4.1.5 ,  Task 4.2.1 , and all of their prerequisites.  Access to the Azure subscription you used in  Task 4.1.5 .",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/4/422_DevopsKubernetes/#task",
            "text": "Set up CI / CD with your application and Kubernetes on Azure.",
            "title": "Task"
        },
        {
            "location": "/stories/4/422_DevopsKubernetes/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/4/422_DevopsKubernetes/#337am",
            "text": "I wasn't really sure where to get started with continuous integration or delivery but  this  really helped me understand!",
            "title": "@ 3:37am"
        },
        {
            "location": "/stories/4/422_DevopsKubernetes/#523am",
            "text": "It looks like you can install the  Kubernetes Extension for VSTS here .",
            "title": "@ 5:23am"
        },
        {
            "location": "/stories/4/422_DevopsKubernetes/#1015am",
            "text": "I think I found  step by step instructions  on setting this up!",
            "title": "@ 10:15am"
        },
        {
            "location": "/stories/4/422_DevopsKubernetes/#458pm",
            "text": "If all goes according to plan, I should be able to demonstrate this working by  following this .",
            "title": "@ 4:58pm"
        },
        {
            "location": "/stories/4/422_DevopsKubernetes/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/4/431_Telemetry/",
            "text": "Task 4.3.1 - Set up Telemetry\n\n\nOur development team want to be able to monitor the health of the applications as well as find the source of bugs. The team also want to learn from production and use it to decide on future projects. \n\n\nPrerequisites\n\n\nThis task has a dependency on the Web App from \n1.1.1\n and the APIs created under section \n4.1.2\n and \n4.1.3\n and all of their prerequisites.\n\n\nTask\n\n\n\n\nCreate an Application Insights account from the Azure Portal or Visual Studio. \n\n\nAdd Application Insights telemetry logging to the Web App, Orders API, and Products API.\n\n\nUpdate the containers and kubernetes implementation to pass in the value of your instrumentation key to the applications in the containers.\n\n\nUse the Azure Portal to see the telemetry that is being captured.\n\n\n\n\nComments\n\n\n@ 9:02am\n\n\nI've found the following instructions that should help us get started:\n\n \nApplication Insights for ASP.NET Core\n\n\n \nManaging ASP.NET Core App Settings on Kubernetes",
            "title": "431 Telemetry"
        },
        {
            "location": "/stories/4/431_Telemetry/#task-431-set-up-telemetry",
            "text": "Our development team want to be able to monitor the health of the applications as well as find the source of bugs. The team also want to learn from production and use it to decide on future projects.",
            "title": "Task 4.3.1 - Set up Telemetry"
        },
        {
            "location": "/stories/4/431_Telemetry/#prerequisites",
            "text": "This task has a dependency on the Web App from  1.1.1  and the APIs created under section  4.1.2  and  4.1.3  and all of their prerequisites.",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/4/431_Telemetry/#task",
            "text": "Create an Application Insights account from the Azure Portal or Visual Studio.   Add Application Insights telemetry logging to the Web App, Orders API, and Products API.  Update the containers and kubernetes implementation to pass in the value of your instrumentation key to the applications in the containers.  Use the Azure Portal to see the telemetry that is being captured.",
            "title": "Task"
        },
        {
            "location": "/stories/4/431_Telemetry/#comments",
            "text": "",
            "title": "Comments"
        },
        {
            "location": "/stories/4/431_Telemetry/#902am",
            "text": "I've found the following instructions that should help us get started:   Application Insights for ASP.NET Core    Managing ASP.NET Core App Settings on Kubernetes",
            "title": "@ 9:02am"
        },
        {
            "location": "/stories/4/497_KubernetesVSTS/",
            "text": "Setting Up Kubernetes and VSTS\n\n\nFor the sake of this exercise, \nlets focus only on the API code\n and any new releases you have. These changes will be tested by VSTS and, pushed into Azure Container Registry (ACR) once all your tests have passed (we won't go into writing tests today). Then VSTS will automatically deploy the latest version of the app into your cluster by obtaining the latest image from ACR.\n\n\nThe following two resources will provide you all the answers on how to accomplish this task, it\u00b4s your duty to understand them and consolidate the concepts to set up a full development cycle. Please note that none of these are a step-by-step tutorial to achieve what you want, but jointly you will be able to make it work:\n\n\n\n\nCI/CD to Kubernetes clusters using VSTS\n\n\nBuild and deploy your ASP.NET Core app to Azure\n\n\n\n\nYou should be able to do the following steps to provide CI/CD in a Kubernetes cluster using Azure.\n\n\n\n\nCreate a new project in your VSTS account.\n\n\nPush your API code into the project's repository in VSTS.\n\n\nInstall the VSTS Kubernetes \nextension\n.\n\n\nProvide Continuous Integration with VSTS by pushing your docker images with the latest version of the tested code into ACR.\n\n\nSet up a trigger to pull your new docker image into your Kubernetes cluster after it has been properly tested and deployed.",
            "title": "497 KubernetesVSTS"
        },
        {
            "location": "/stories/4/497_KubernetesVSTS/#setting-up-kubernetes-and-vsts",
            "text": "For the sake of this exercise,  lets focus only on the API code  and any new releases you have. These changes will be tested by VSTS and, pushed into Azure Container Registry (ACR) once all your tests have passed (we won't go into writing tests today). Then VSTS will automatically deploy the latest version of the app into your cluster by obtaining the latest image from ACR.  The following two resources will provide you all the answers on how to accomplish this task, it\u00b4s your duty to understand them and consolidate the concepts to set up a full development cycle. Please note that none of these are a step-by-step tutorial to achieve what you want, but jointly you will be able to make it work:   CI/CD to Kubernetes clusters using VSTS  Build and deploy your ASP.NET Core app to Azure   You should be able to do the following steps to provide CI/CD in a Kubernetes cluster using Azure.   Create a new project in your VSTS account.  Push your API code into the project's repository in VSTS.  Install the VSTS Kubernetes  extension .  Provide Continuous Integration with VSTS by pushing your docker images with the latest version of the tested code into ACR.  Set up a trigger to pull your new docker image into your Kubernetes cluster after it has been properly tested and deployed.",
            "title": "Setting Up Kubernetes and VSTS"
        },
        {
            "location": "/stories/4/498_KubernetesCICDBehavior/",
            "text": "Kubernetes and VSTS Expected Behavior\n\n\nAt the end of this challenge you should be able to follow these steps and get similar results:\n\n\n\n\nCommit a new change into your \nmaster\n branch.\n\n\nVSTS will build your project and test it.\n\n\nIf all the tests have been passed, VSTS will create and push a new Docker image with the new code. Please refer to previous section \n'Create Docker images'\n for the definition of the image.\n\n\nYour Kubernetes task created with the help of the VSTS Kubernetes \nextension\n will now run to pull the new image into the cluster.\n\n\nDo a request into your freshly deployed API and verify that your new changes are up and running.",
            "title": "498 KubernetesCICDBehavior"
        },
        {
            "location": "/stories/4/498_KubernetesCICDBehavior/#kubernetes-and-vsts-expected-behavior",
            "text": "At the end of this challenge you should be able to follow these steps and get similar results:   Commit a new change into your  master  branch.  VSTS will build your project and test it.  If all the tests have been passed, VSTS will create and push a new Docker image with the new code. Please refer to previous section  'Create Docker images'  for the definition of the image.  Your Kubernetes task created with the help of the VSTS Kubernetes  extension  will now run to pull the new image into the cluster.  Do a request into your freshly deployed API and verify that your new changes are up and running.",
            "title": "Kubernetes and VSTS Expected Behavior"
        },
        {
            "location": "/stories/4/499_Troubleshooting/",
            "text": "Task 4 Troubleshooting Guide\n\n\n\"Firewall detected\" when sharing drive\n\n\nIf you encounter a firewall error when sharing drives with Docker, you may need to reset Windows File and Printer sharing on your Hyper-V virtual switch.\n\n\n\n\nRight click your network connection in the taskbar, and choose \nNetwork and Sharing Center\n\n\nIn the left menu, select \nChange Adapter Settings\n\n\nRight click and open the properties for the \"vEthernet (DockerNAT)\" adapter\n\n\nUncheck the box for \nFile and Printer Sharing for Windows\n and hit OK\n\n\n\nOpen the properties again, re-enable \nFile and Printer Sharing for Windows\n and hit OK\n\n\nYou should now be able to share drives with Docker\n\n\n\n\nCase sensitivity\n\n\nIf you're using Windows to follow along, it's important to note that we're using Linux containers on Docker.\nThis means that if you have a case mismatch between file/folder names, you may encounter errors when building or\nrunning containers because Linux uses a case-sensitive file system.\n\n\nFor example, this could happen if you named your folder \nordersApi\n, which by default will produce a dll with\nthe path \nordersApi/bin/Release/netcoreapp1.1/publish/ordersApi.dll\n. When the supplied \nDockerfile\n is\nexecuted inside \nordersApi\n, everything looks great! But when you run the container, it will fail because\nthe \nENTRYPOINT\n is specified to look for \nordersapi.dll",
            "title": "499 Troubleshooting"
        },
        {
            "location": "/stories/4/499_Troubleshooting/#task-4-troubleshooting-guide",
            "text": "",
            "title": "Task 4 Troubleshooting Guide"
        },
        {
            "location": "/stories/4/499_Troubleshooting/#firewall-detected-when-sharing-drive",
            "text": "If you encounter a firewall error when sharing drives with Docker, you may need to reset Windows File and Printer sharing on your Hyper-V virtual switch.   Right click your network connection in the taskbar, and choose  Network and Sharing Center  In the left menu, select  Change Adapter Settings  Right click and open the properties for the \"vEthernet (DockerNAT)\" adapter  Uncheck the box for  File and Printer Sharing for Windows  and hit OK  Open the properties again, re-enable  File and Printer Sharing for Windows  and hit OK  You should now be able to share drives with Docker",
            "title": "\"Firewall detected\" when sharing drive"
        },
        {
            "location": "/stories/4/499_Troubleshooting/#case-sensitivity",
            "text": "If you're using Windows to follow along, it's important to note that we're using Linux containers on Docker.\nThis means that if you have a case mismatch between file/folder names, you may encounter errors when building or\nrunning containers because Linux uses a case-sensitive file system.  For example, this could happen if you named your folder  ordersApi , which by default will produce a dll with\nthe path  ordersApi/bin/Release/netcoreapp1.1/publish/ordersApi.dll . When the supplied  Dockerfile  is\nexecuted inside  ordersApi , everything looks great! But when you run the container, it will fail because\nthe  ENTRYPOINT  is specified to look for  ordersapi.dll",
            "title": "Case sensitivity"
        },
        {
            "location": "/stories/5/511_Paint3d/",
            "text": "Task 5.1.1 - Create the model in Paint3D\n\n\nCreating a 3D model of our products will open up a world of opportunities. We can 3D print prototype noses, render them in 3D to visualize how they look, or even see them for ourselves in Virtual Reality!\n\n\n3D Paint is a simple tool in the Windows 10 Creators Update that allows us to create and paint 3D models. Perfect for this task!\n\n\nPrerequisites\n\n\nThis walkthrough assumes that you have:\n\n Windows 10 Creators Update\n\n Paint 3D\n\n\nTask\n\n\nThe Nose 3D model\n\n\nThe first part of this task is to create the Nose 3D model itself, with a base color.\n\n\n\n\nLaunch \nPaint 3D\n using the Windows Start Menu. If the Welcome Screen is displayed, dismiss it.\n\n\nYou will see a blank white scene when Paint 3D has launched. This is the canvas you will be working on to create your Knowzy nose prototype.\n\n\nThe top-center menu allows you to select what tools you want to use. The first one is Art Tools for paining and coloring, while the next (cube icon) is for actually creating 3D objects. Select this menu tab.\n    \n\n\nIn the 3D objects menu tab, select the Sphere tool (should be selected by default) by clicking the Sphere icon under 3D objects.\n\n\nThis allows you to draw a Sphere on the canvas. Before doing so, use the Color Selector below the tool to select what color you want the nose to have as a base. Note, by changing the dropdown above the color selector from Matte to Gloss will make the nose look shiny - play with this to get the nose YOU want to design!\n\n\nDraw the Sphere on the canvas by placing the mouse pointer where you want it, left clicking and dragging it to the size you want. You can force the size to be uniform by holding \nSHIFT\n while dragging. This is how our first prototype looked like:\n    \n\n\n\n\nPainting the Nose\n\n\nThe second task is to give the nose some details. This can be stickers, color variations and drawings.\n1. Select the Art Tools tab to see what tools you have for drawing. \n\n\n\n\nNote: For these steps, it is very important to not draw on the white canvas itself as it will make it a part of the 3D model itself.\n\n\n\n\n\n\n\n\nYou can now use any of the Art Tools to draw on the model itself. Feel free to be creative here! For our first prototype, we simply used the Calligraphy Tool with the Thickness set to 36px to draw to nose holes on the bottom of the nose.\n\n\n\n\n\n\n\n\nThe third menu tab is for placing Stickers on the model. Feel free to play around with the various tools to become familiar with the software - this allows you to be very creative when designing new prototypes for us!\n\n\n\n\n\n\nSaving and Exporting\n\n\nThe last task here is to save the model, and export it as FBX to be used with Unity or BabylonJS (by converting to OBJ, see BabylonJS task).\n\n\n\n\nSave the Project itself as a Paint 3D project by clicking the Folder icon on the top-left corner of the window, and give it a proper name.\n\n\n\n\nNow, export the scene by clicking the same folder icon on the top-left corner of the window, and select FBX under Export:\n\n\n\n\n\n\n\n\nSave it in a location you can remember for the tasks ahead.\n\n\n\n\n\n\nCongratulations, you have now mastered Paint 3D and how to use it to create Nose Prototypes in 3D!\n\n\nReferences\n\n\nThe FBX export of our first Nose Prototype:\n\nNose Prototype (FBX)\n\n\ncontinue to \nnext task >>",
            "title": "511 Paint3d"
        },
        {
            "location": "/stories/5/511_Paint3d/#task-511-create-the-model-in-paint3d",
            "text": "Creating a 3D model of our products will open up a world of opportunities. We can 3D print prototype noses, render them in 3D to visualize how they look, or even see them for ourselves in Virtual Reality!  3D Paint is a simple tool in the Windows 10 Creators Update that allows us to create and paint 3D models. Perfect for this task!",
            "title": "Task 5.1.1 - Create the model in Paint3D"
        },
        {
            "location": "/stories/5/511_Paint3d/#prerequisites",
            "text": "This walkthrough assumes that you have:  Windows 10 Creators Update  Paint 3D",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/5/511_Paint3d/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/5/511_Paint3d/#the-nose-3d-model",
            "text": "The first part of this task is to create the Nose 3D model itself, with a base color.   Launch  Paint 3D  using the Windows Start Menu. If the Welcome Screen is displayed, dismiss it.  You will see a blank white scene when Paint 3D has launched. This is the canvas you will be working on to create your Knowzy nose prototype.  The top-center menu allows you to select what tools you want to use. The first one is Art Tools for paining and coloring, while the next (cube icon) is for actually creating 3D objects. Select this menu tab.\n      In the 3D objects menu tab, select the Sphere tool (should be selected by default) by clicking the Sphere icon under 3D objects.  This allows you to draw a Sphere on the canvas. Before doing so, use the Color Selector below the tool to select what color you want the nose to have as a base. Note, by changing the dropdown above the color selector from Matte to Gloss will make the nose look shiny - play with this to get the nose YOU want to design!  Draw the Sphere on the canvas by placing the mouse pointer where you want it, left clicking and dragging it to the size you want. You can force the size to be uniform by holding  SHIFT  while dragging. This is how our first prototype looked like:",
            "title": "The Nose 3D model"
        },
        {
            "location": "/stories/5/511_Paint3d/#painting-the-nose",
            "text": "The second task is to give the nose some details. This can be stickers, color variations and drawings.\n1. Select the Art Tools tab to see what tools you have for drawing.    Note: For these steps, it is very important to not draw on the white canvas itself as it will make it a part of the 3D model itself.     You can now use any of the Art Tools to draw on the model itself. Feel free to be creative here! For our first prototype, we simply used the Calligraphy Tool with the Thickness set to 36px to draw to nose holes on the bottom of the nose.     The third menu tab is for placing Stickers on the model. Feel free to play around with the various tools to become familiar with the software - this allows you to be very creative when designing new prototypes for us!",
            "title": "Painting the Nose"
        },
        {
            "location": "/stories/5/511_Paint3d/#saving-and-exporting",
            "text": "The last task here is to save the model, and export it as FBX to be used with Unity or BabylonJS (by converting to OBJ, see BabylonJS task).   Save the Project itself as a Paint 3D project by clicking the Folder icon on the top-left corner of the window, and give it a proper name.   Now, export the scene by clicking the same folder icon on the top-left corner of the window, and select FBX under Export:     Save it in a location you can remember for the tasks ahead.    Congratulations, you have now mastered Paint 3D and how to use it to create Nose Prototypes in 3D!",
            "title": "Saving and Exporting"
        },
        {
            "location": "/stories/5/511_Paint3d/#references",
            "text": "The FBX export of our first Nose Prototype: Nose Prototype (FBX)",
            "title": "References"
        },
        {
            "location": "/stories/5/511_Paint3d/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/5/512a_Unity/",
            "text": "Task 5.1.2a - Create a Unity solution to visualize 3D Model\n\n\nNow that we have a proper 3D model of our nose prototype, we can start rendering it in real-time through a UWP app. To create the app, we use the Unity 3D rendering engine.\nUnity 3D has built-in support for loading FBX, so all we need to do is to load the model, add it to a scene and export it as a UWP. This allows us to properly simulate how our prototypes looks in the real world!\n\n\nPrerequisites\n\n\nThis walkthrough assumes that you have:\n\n Windows 10 Creators Update\n\n 3D Nose Model from Paint 5.1.1\n* Unity 5.6 with UWP Plugin for exporting UWP\n\n\nTask\n\n\nCreating a new project\n\n\n\n\n\n\nLaunch Unity 3D using the Windows Start Menu. When the Unity 3D Project dialogue is visible, click NEW.\n    > Note: If you launch if for the first time, log in with you free unity3d account.\n\n\n\n\n\n\nIn the Create New Project dialogue, give the project a proper name like \"Nose3D\", select the 3D toggle and where you want it before clicking [Create project].\n\n\n\n\n\n\n\n\nUnity will spend a few seconds on generating the new project. When done, you will see a default blank Unity 3D project.\n\n\n\n\nLet's save the empty scene first by using \nCTRL+S\n or \nFile->Save Scenes\n and name it \nMain.unity\n. Save it directly in the new projects default Assets-folder.\n\n\nUnity 3D is a complex 3D engine, and for rendering our 3D nose we have to touch some of the basics.\n\n\n\n\nThe interface:\n\n\n\n\nThe Unity 3D interface has 5 main parts. The big 3D view is your scene. There are a couple of tabs above this scene named Scene and Game. Scene is where you will be working, and the Game tab is where you can see what the Game looks like when you press Play.\n\n\nThe hierarchy is where you can see all objects currently in your scene. If your Main scene is collapsed, click the triangle to expand its content (just a normal tree-view). By default, the scene has a camera (what you see through in the Game tab), and a Directional Light (think of this as the sun).\nThis is where we will be adding our own objects to build up the scene. Each of these items is a GameObject.\n\n\nThe Project tab contains the entire projects file structure. Everything you work with needs to be in the default Assets folder. Inside this folder you are free to do everything you want to build up your own folder structure.\n\n\nThe Inspector tab contains all the properties of a selected GameObject. If you select the Main Camera GameObject from the Hierarchy, you can see all components and properties attached to this GameObject. This is the way objects are built in Unity, a combination of different components create and defines a GameObjects purpose.\n\n\nThe top menu is the normal Windows menu, with some tools for transforming GameObjects and configuring your scene view and UI layout.\n\n\nLoading the 3D Nose model\n\n\nNext we will have to load the 3D nose model we created earlier.\n1. Create a new folder in the project view from Unity by right-clicking and selecting \nCreate->Folder\n. Name it \nModels\n.\n\n\n![3D objects tool](images/512a_3.png)\n\n\n\n\n\nNow locate the 3D Nose FBX model from where you saved it in 5.1.1 and copy it into the new Models folder using File Explorer.\n\n\n\n\nGo back to Unity 3D. You will notice that it automatically detects a new file and imports it. You can find it in the Assets/Models folder in the project view:\n\n\n\n\n\n\n\n\nNow drag the nose into the scene hierarchy (release it on the gray area) to place it in the scene.\n\n\n\n\n\n\nYou should see the Nose in the Hierarchy View, but it might not be visible in the scene view. Having the GameObject selected, hover the mouse over the scene view window and press \nF\n on the keyboard to focus on the object. You should now see it.\n\n\n\n\nClicking the Game tab on top of the Scene view will let you see what the camera sees. In the end, we want to position it so it is visible by the camera.\n\n\n\n\n\n\n\n\nThere are some issues we need to solve:\n\n\n\n\nThe scale is different between Unity and Paint 3D, so the object we imported is very big.\n\n\nThe origo for the polygons in the 3D model got an offset from center of the GameObject.\n\n\nThe color is a bit dark\n\n\n\n\n\n\n\n\nSolving the scale issue: Click on the NosePrototype to view the Position, Scale and Rotation properties. Set the scale to \n0.01\n\n\n\n\nI. Solving the origo issue: Create a new and empty GameObject in the scene by clicking the small button on the top-left side of the Hierarchy panel named Create and select \nCreate Empty\n.\n\n\n\n\nA new GameObject item is visible in the Scene Hierarchy. Click it to view the properties. First, set the name to Nose, and set the all the Position fields to 0 to center the empty gameobject in the scene. You can focus it again using \nF\n with the mouse hovering the scene view in Scene mode (move out from Game if you didn't do this yet). You can then see the empty GameObject in the center of the scene, with the nose somewhere next to it.\n\n\n\n\nII. Select the Nose 3D model GameObject and use the axis handles to position it as close to the center as possible (drag the red and green handles using the mouse and left mouse button). It does not need to be 100% accurate but give it a good try.\nTip: The handles are there so you can move the object along the selected axis. You can use the Grid and these handles to align them to the center. Look closely in the image below, the grid aligns with the axis handles:\n\n\n\n\nIII. With the Nose model in the center, we need to use the Hierarchy View to make it a child of the new empty \nNose\n GameObject. Drag the NosePrototype GameObject (it will be named the same as you 3D model FBX file name) and drop it on the Nose GameObject to make it a child.\n\n\n\n\nHaving the Nose 3D model GameObject as a child to another will position it relative to the parent GameObject. This means that if we rotate or move it, it will follow.\n8. Fixing the dark color issue: Each GameObject that got a visible surface like our Nose 3D model got a Material. A material is a descriptor on how the surface which the material is assigned to will look and behave. This includes color, texture assignment and light calculations. For those who are familiar with Graphics Programming, a Material is the Shader being used to render the polygons. To find the assigned material, you can either expand the Nose GameObject and select the 3D model GameObject (NosePrototype) and find the Material on it, or navigate to the Materials folder generated when importing the model and clicking it from the Project view.\n\n\n\n\nWhen we imported the object, it automatically generated a Material, set the texture to what we made in Paint 3D and assigned it to the model in Unity. The property that allows us to control the texture is the Albedo property under Main Maps on the Material. You can see the texture next to it in a miniature thumbnail. Next to this property you can see a gray color. This is multiplied with the texture, thus darkening it. Set this color to white to fix the dark coloring issues. Feel free to play around with the metallic and smoothness settings to give it a metallic or matte look based on your preference.\n\n\n\n\n\n\n\n\nWith the issues fixed, the color now looks more natural, the object has a better size and is centered.\n\n\n\n\nVerify that the camera in the Game view sees this too. This is what the user will see when they launch the app later. From this view, you can continue to modify the scale and position if needed. In my case, it now looks like this:\n\n\n\n\n\n\n\n\nMaking the nose rotate\n\n\nTo make this look less static, we will create a custom component using C# to make the nose rotate.\n1. Under Assets, create a new folder named Scripts:\n\n\n![3D objects tool](images/512a_16.png)\n\n\n\n\n\n\n\nIn the Scripts folder, right click and click \nCreate->C# script\n. Name it \nNoseRotator\n\n\n\n\n\n\n\n\nIf the Nose GameObject is not collapsed, collapse it now. Then drag and drop the NoseRotator script on the Nose GameObject in the Hierarchy View to add it as a component to this object:\n\n\n\n\n\n\n\n\nIf you click on the Nose GameObject using the Hierarchy Panel, you can use the Inspector to see the component you added.\n\n\n\n\n\n\n\n\nDouble click the NoseRotator script in the Project view to edit the code. You can use the Unity Preferences (\nEdit->Preferences\n) to set what Editor you want to use. I set it up to use Visual Studio.\n\n\n\n\n\n\nThe script has two functions by default, Start() and Update(). Start is called once when the app launches, and Update() is called every frame.\nSince we will animate this nose, we want to rotate it slightly every time Update is called. In Update(), add the following line:\n\n\ncsharp\n    transform.Rotate(Time.deltaTime * Vector3.up * speed);\n\n\nAlso, add a new public floating point variable called speed to the class, just above Start(). The complete listing should look like this:\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\n\npublic class NoseRotator : MonoBehaviour {\n    public float speed = 50.0f;\n\n\n// Use this for initialization\nvoid Start () {\n\n}\n\n// Update is called once per frame\nvoid Update () {\n    transform.Rotate(Time.deltaTime * Vector3.up * speed);\n}\n\n\n\n}\n```\nThe Rotate function is rotating the GameObject this script is attached to. Time.deltaTime is the amount of time since last frame, so it can be used to sync the timing with the clock. Vector3.up is really just a Vector: 0,1,0. This is used to rotate only around the Y axis, and speed is how fast it will rotate. Since we multiply this with Time.deltaTime, speed will control how many degrees it will rotate pr. second.\n\n\nSave the code and go back to Unity.\n\n\n\n\n\n\nTesting the app\n: Before exporting this as a UWP, we need to ensure the app is working. Click the Play button on top of the scene to automatically enter the Game tab, and start running the code. You should now see the nose rotating in the center of the screen. It might have some offset to it based on how accurate you were when centering it earlier.\n    \n\n\n\n\nTip: With the Nose GameObject selected, you can see the speed variable visible, and set to 50. Since we made the speed variable public, you can directly set the variable inside the editor instead of changing the script.\n\n\n\n\n\n\n\n\nExporting as UWP\n\n\nThe final step is to export our fresh Nose 3D visualizer app as a UWP so we can distribute it. This is very simple using Unity.\n1. To export, go to the Build Settings of the project by using \nFile->Build Settings\n. A new popup will show. A large empty gray area is visible named Scene in Build. Click the button below it named \nAdd Open Scene\n to add our scene \nMain\n to the list.\n2. Select Windows Store and click Build to export:\n\n\n![3D objects tool](images/512a_21.png)\n\nExport it to a new folder somewhere on your PC and press OK to start exporting the project. This will take a minute.\n\n\n\n\n\nWhen the export is done, the folder will open in File Explorer. Open the Nose3D.sln solution in Visual Studio.\n\n\nChange the Build Configuration to \nMaster\n and \nx64\n and build, deploy and run the project.\n\n\n\n\n\n\n\n\nThe project should now build (it might take a few minutes) and run. You should see the rotating 3D nose in the center of the app.\n\n\n\n\nCongratulations, you have now created a 3D Nose visualizer UWP app using Unity! Since this is now a valid Windows Store app, you can now find the app from the Windows Start Menu.\n\n\nReferences\n\n\ncontinue to \nnext task >>",
            "title": "512a Unity"
        },
        {
            "location": "/stories/5/512a_Unity/#task-512a-create-a-unity-solution-to-visualize-3d-model",
            "text": "Now that we have a proper 3D model of our nose prototype, we can start rendering it in real-time through a UWP app. To create the app, we use the Unity 3D rendering engine.\nUnity 3D has built-in support for loading FBX, so all we need to do is to load the model, add it to a scene and export it as a UWP. This allows us to properly simulate how our prototypes looks in the real world!",
            "title": "Task 5.1.2a - Create a Unity solution to visualize 3D Model"
        },
        {
            "location": "/stories/5/512a_Unity/#prerequisites",
            "text": "This walkthrough assumes that you have:  Windows 10 Creators Update  3D Nose Model from Paint 5.1.1\n* Unity 5.6 with UWP Plugin for exporting UWP",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/5/512a_Unity/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/5/512a_Unity/#creating-a-new-project",
            "text": "Launch Unity 3D using the Windows Start Menu. When the Unity 3D Project dialogue is visible, click NEW.\n    > Note: If you launch if for the first time, log in with you free unity3d account.    In the Create New Project dialogue, give the project a proper name like \"Nose3D\", select the 3D toggle and where you want it before clicking [Create project].     Unity will spend a few seconds on generating the new project. When done, you will see a default blank Unity 3D project.   Let's save the empty scene first by using  CTRL+S  or  File->Save Scenes  and name it  Main.unity . Save it directly in the new projects default Assets-folder.  Unity 3D is a complex 3D engine, and for rendering our 3D nose we have to touch some of the basics.   The interface:   The Unity 3D interface has 5 main parts. The big 3D view is your scene. There are a couple of tabs above this scene named Scene and Game. Scene is where you will be working, and the Game tab is where you can see what the Game looks like when you press Play.  The hierarchy is where you can see all objects currently in your scene. If your Main scene is collapsed, click the triangle to expand its content (just a normal tree-view). By default, the scene has a camera (what you see through in the Game tab), and a Directional Light (think of this as the sun).\nThis is where we will be adding our own objects to build up the scene. Each of these items is a GameObject.  The Project tab contains the entire projects file structure. Everything you work with needs to be in the default Assets folder. Inside this folder you are free to do everything you want to build up your own folder structure.  The Inspector tab contains all the properties of a selected GameObject. If you select the Main Camera GameObject from the Hierarchy, you can see all components and properties attached to this GameObject. This is the way objects are built in Unity, a combination of different components create and defines a GameObjects purpose.  The top menu is the normal Windows menu, with some tools for transforming GameObjects and configuring your scene view and UI layout.",
            "title": "Creating a new project"
        },
        {
            "location": "/stories/5/512a_Unity/#loading-the-3d-nose-model",
            "text": "Next we will have to load the 3D nose model we created earlier.\n1. Create a new folder in the project view from Unity by right-clicking and selecting  Create->Folder . Name it  Models .  ![3D objects tool](images/512a_3.png)   Now locate the 3D Nose FBX model from where you saved it in 5.1.1 and copy it into the new Models folder using File Explorer.   Go back to Unity 3D. You will notice that it automatically detects a new file and imports it. You can find it in the Assets/Models folder in the project view:     Now drag the nose into the scene hierarchy (release it on the gray area) to place it in the scene.    You should see the Nose in the Hierarchy View, but it might not be visible in the scene view. Having the GameObject selected, hover the mouse over the scene view window and press  F  on the keyboard to focus on the object. You should now see it.   Clicking the Game tab on top of the Scene view will let you see what the camera sees. In the end, we want to position it so it is visible by the camera.     There are some issues we need to solve:   The scale is different between Unity and Paint 3D, so the object we imported is very big.  The origo for the polygons in the 3D model got an offset from center of the GameObject.  The color is a bit dark     Solving the scale issue: Click on the NosePrototype to view the Position, Scale and Rotation properties. Set the scale to  0.01   I. Solving the origo issue: Create a new and empty GameObject in the scene by clicking the small button on the top-left side of the Hierarchy panel named Create and select  Create Empty .   A new GameObject item is visible in the Scene Hierarchy. Click it to view the properties. First, set the name to Nose, and set the all the Position fields to 0 to center the empty gameobject in the scene. You can focus it again using  F  with the mouse hovering the scene view in Scene mode (move out from Game if you didn't do this yet). You can then see the empty GameObject in the center of the scene, with the nose somewhere next to it.   II. Select the Nose 3D model GameObject and use the axis handles to position it as close to the center as possible (drag the red and green handles using the mouse and left mouse button). It does not need to be 100% accurate but give it a good try.\nTip: The handles are there so you can move the object along the selected axis. You can use the Grid and these handles to align them to the center. Look closely in the image below, the grid aligns with the axis handles:   III. With the Nose model in the center, we need to use the Hierarchy View to make it a child of the new empty  Nose  GameObject. Drag the NosePrototype GameObject (it will be named the same as you 3D model FBX file name) and drop it on the Nose GameObject to make it a child.   Having the Nose 3D model GameObject as a child to another will position it relative to the parent GameObject. This means that if we rotate or move it, it will follow.\n8. Fixing the dark color issue: Each GameObject that got a visible surface like our Nose 3D model got a Material. A material is a descriptor on how the surface which the material is assigned to will look and behave. This includes color, texture assignment and light calculations. For those who are familiar with Graphics Programming, a Material is the Shader being used to render the polygons. To find the assigned material, you can either expand the Nose GameObject and select the 3D model GameObject (NosePrototype) and find the Material on it, or navigate to the Materials folder generated when importing the model and clicking it from the Project view.   When we imported the object, it automatically generated a Material, set the texture to what we made in Paint 3D and assigned it to the model in Unity. The property that allows us to control the texture is the Albedo property under Main Maps on the Material. You can see the texture next to it in a miniature thumbnail. Next to this property you can see a gray color. This is multiplied with the texture, thus darkening it. Set this color to white to fix the dark coloring issues. Feel free to play around with the metallic and smoothness settings to give it a metallic or matte look based on your preference.     With the issues fixed, the color now looks more natural, the object has a better size and is centered.   Verify that the camera in the Game view sees this too. This is what the user will see when they launch the app later. From this view, you can continue to modify the scale and position if needed. In my case, it now looks like this:",
            "title": "Loading the 3D Nose model"
        },
        {
            "location": "/stories/5/512a_Unity/#making-the-nose-rotate",
            "text": "To make this look less static, we will create a custom component using C# to make the nose rotate.\n1. Under Assets, create a new folder named Scripts:  ![3D objects tool](images/512a_16.png)    In the Scripts folder, right click and click  Create->C# script . Name it  NoseRotator     If the Nose GameObject is not collapsed, collapse it now. Then drag and drop the NoseRotator script on the Nose GameObject in the Hierarchy View to add it as a component to this object:     If you click on the Nose GameObject using the Hierarchy Panel, you can use the Inspector to see the component you added.     Double click the NoseRotator script in the Project view to edit the code. You can use the Unity Preferences ( Edit->Preferences ) to set what Editor you want to use. I set it up to use Visual Studio.    The script has two functions by default, Start() and Update(). Start is called once when the app launches, and Update() is called every frame.\nSince we will animate this nose, we want to rotate it slightly every time Update is called. In Update(), add the following line:  csharp\n    transform.Rotate(Time.deltaTime * Vector3.up * speed);  Also, add a new public floating point variable called speed to the class, just above Start(). The complete listing should look like this:\n```csharp\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;  public class NoseRotator : MonoBehaviour {\n    public float speed = 50.0f;  // Use this for initialization\nvoid Start () {\n\n}\n\n// Update is called once per frame\nvoid Update () {\n    transform.Rotate(Time.deltaTime * Vector3.up * speed);\n}  }\n```\nThe Rotate function is rotating the GameObject this script is attached to. Time.deltaTime is the amount of time since last frame, so it can be used to sync the timing with the clock. Vector3.up is really just a Vector: 0,1,0. This is used to rotate only around the Y axis, and speed is how fast it will rotate. Since we multiply this with Time.deltaTime, speed will control how many degrees it will rotate pr. second.  Save the code and go back to Unity.    Testing the app : Before exporting this as a UWP, we need to ensure the app is working. Click the Play button on top of the scene to automatically enter the Game tab, and start running the code. You should now see the nose rotating in the center of the screen. It might have some offset to it based on how accurate you were when centering it earlier.\n       Tip: With the Nose GameObject selected, you can see the speed variable visible, and set to 50. Since we made the speed variable public, you can directly set the variable inside the editor instead of changing the script.",
            "title": "Making the nose rotate"
        },
        {
            "location": "/stories/5/512a_Unity/#exporting-as-uwp",
            "text": "The final step is to export our fresh Nose 3D visualizer app as a UWP so we can distribute it. This is very simple using Unity.\n1. To export, go to the Build Settings of the project by using  File->Build Settings . A new popup will show. A large empty gray area is visible named Scene in Build. Click the button below it named  Add Open Scene  to add our scene  Main  to the list.\n2. Select Windows Store and click Build to export:  ![3D objects tool](images/512a_21.png)\n\nExport it to a new folder somewhere on your PC and press OK to start exporting the project. This will take a minute.   When the export is done, the folder will open in File Explorer. Open the Nose3D.sln solution in Visual Studio.  Change the Build Configuration to  Master  and  x64  and build, deploy and run the project.     The project should now build (it might take a few minutes) and run. You should see the rotating 3D nose in the center of the app.   Congratulations, you have now created a 3D Nose visualizer UWP app using Unity! Since this is now a valid Windows Store app, you can now find the app from the Windows Start Menu.",
            "title": "Exporting as UWP"
        },
        {
            "location": "/stories/5/512a_Unity/#references",
            "text": "",
            "title": "References"
        },
        {
            "location": "/stories/5/512a_Unity/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/5/512b_Babylon/",
            "text": "Task 5.1.2b - Create a BabylonJS solution to visualize 3D Model\n\n\nNow that we have a proper 3D model of our nose prototype, we can start rendering it in real-time through a Javascript UWP application. To create the application, we use the Visual Studio 2017 Javasctipt UWP template.\n\n\nIn order to load and render our model, we will rely on Babylon JS which is a WebGL based 3d engine.\n\n\nAs Babylon does not support natively loading FBX, we will first need to convert our FBX file to a Bablylon supported format (babylon, GlTF or OBJ).\n\n\nPrerequisites\n\n\nThis walkthrough assumes that you have:\n\n Windows 10 Creators Update\n\n 3D Nose Model from Paint 5.1.1\n* Visual Studio 2017 with the Universal Windows Platform Development Workload to create a Javascript UWP\n\n\nTask\n\n\nConvert the model to OBJ\n\n\nTo convert the model, we will use the online FBX to OBJ converter, using the FBX we exported in 5.1.1.\n1. Go to: \nOnline Model Converter\n\n2. Follow the steps in the tool to convert the FBX to OBJ, and download the OBJ file. The MTL file is not needed.\n3. The problem here is that we don't have the texture, but you can use any png file, just create a new file in pain with a red color and use it through these steps.\n\n\nCreating a new project\n\n\n\n\n\n\nLaunch Visual Studio 2017 using the Windows Start Menu. Once open, click File>New>Project...\n    > Note: If you launch if for the first time, log in with your MSA account.\n\n\n\n\n\n\nIn the \"Create New Project\" dialog under template, select Javascript>Windows Universal>Blank App, and give the project a proper name like \"BabylonUWP\".\n\n\n\n\n\n\n\n\nClick Ok to create your project.\n    > Note: You may be asked to turn on the developer mode in the Windows settings in order to create the UWP.\n\n\n\n\n\n\nYour project is now ready and it can easily be launched by pressing F5 (for debug mode) or Ctrl+F5 (for normal mode). You should see an application running with a white page containing the text: \"Content goes here!\".\n\n\n\n\n\n\n\n\nAdding Babylon JS dependency\n\n\nIt is now time to add content in our UWP.\n\n\n\n\n\n\nAdd the Babylon.JS dependency to your project (this allows your project to work offline). Right click on the \njs\n folder, click on \nAdd -> Existing Item...\n. Copy this link to your clipboard (\nhttps://preview.babylonjs.com/babylon.js\n) and paste it in the \nFile name\n box. Click \nAdd\n. \n\n\n\n\n\n\n\n\nAdd the Babylon.JS OBJ Loader dependency to your project (this allows your project to work offline). Similar to the previous step, use this link to add the file to the js folder (\nhttps://preview.babylonjs.com/loaders/babylon.objFileLoader.js\n)\n\n\n\n\n\n\nThe solution folder should now look like this:\n\n\n\n\n\n\n\n\nIt is now time to integrate those files in the application. Open the \nindex.html\n file and add the two following script references \nbefore\n the main.js one:\n\n\n\n\n\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>BabylonUWP</title>\n    <link href=\"css/default.css\" rel=\"stylesheet\" />\n</head>\n<body>\n    <div>Content goes here!</div>\n\n    <script src=\"js/babylon.js\"></script>\n    <script src=\"js/babylon.objFileLoader.js\"></script>\n    <script src=\"js/main.js\"></script>\n</body>\n</html>\n\n\n\n\n\n\nThe project can now be launched in debug by pressing F5 to ensure that the setup is correct. No error should be displayed in the javascript console.\n\n\n\n\nCreate your first scene\n\n\nAs the project is ready, we can now create our first 3D scene as explained in the \nBasic Tutorial\n of Babylon JS.\n\n\n\n\n\n\nThe \ndiv\n element containing the text: \"Content goes here!\" needs to be replaced by a canvas enabling WebGL rendering in Html. Open the \nindex.html\n and replace \n<div>Content goes here!</div>\n by \n<canvas id=\"renderCanvas\"></canvas>\n.\n\n\n\n\n\n\nThe \nindex.html\n file should look like this:\n\n\n\n\n\n\n<!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>BabylonUWP</title>\n    <link href=\"css/default.css\" rel=\"stylesheet\" />\n</head>\n<body>\n    <canvas id=\"renderCanvas\"></canvas>\n\n    <script src=\"js/babylon.js\"></script>\n    <script src=\"js/babylon.objFileLoader.js\"></script>\n    <script src=\"js/main.js\"></script>\n</body>\n</html>\n\n\n\n\n\n\nTo ensure that the canvas is rendered in full screen, replace the content of the file \ncss/default.css\n by the following one:\n\n\n\n\nhtml, body {\n    overflow: hidden;\n    width: 100%;\n    height: 100%;\n    margin: 0;\n    padding: 0;\n}\n\n#renderCanvas {\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n}\n\n\n\n\n\n\nThe setup being done, open the \njs/main.js\n file and replace its content by the following:\n\n\n\n\n// Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's try our built-in 'box' shape. Params: name, size.\nvar box1 = BABYLON.Mesh.CreateBox(\"box1\", 1);\n\n// Creates a default light and camera.\nscene.createDefaultCameraOrLight(true);\n\n// This attaches the input camera controls to the canvas\nscene.activeCamera.attachControl(canvas, false);\n\n// Register a render loop to repeatedly render the scene\nengine.runRenderLoop(function () {\n    scene.render();\n});\n\n\n\n\n\n\n\n\nThe project can now be launched and displays a cube in 3D !!! The camera can rotate by holding the mouse left click on the application. The zoom level is controlled by the mouse wheel.\n\n\n\n\n\n\n\n\nLoading the 3D Nose model\n\n\n\n\n\n\nCreate a folder named \nassets\n at the root of the solution and copy your \nredNose.obj\n file in this folder.\n\n\n\n\n\n\nInstead of creating a sphere, the model needs to be loaded. The content of the \njs/main.js\n file needs to be updated to:\n\n\n\n\n\n\n// Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's load the red nose model.\nBABYLON.SceneLoader.ImportMesh(null, \"assets/\", \"redNose.obj\", scene, function (meshes) {\n    // Keeps track of our model root.\n    var redNoseModel = meshes[0];\n\n    // Creates a default light and camera.\n    scene.createDefaultCameraOrLight(true);\n\n    // This attaches the input camera controls to the canvas\n    scene.activeCamera.attachControl(canvas, false);\n\n    // Register a render loop to repeatedly render the scene\n    engine.runRenderLoop(function () {\n        scene.render();\n    });\n});\n\n\n\n\n\n\nBy launching the project now,  we can see a beautiful red nose model displayed in a Javascript UWP application.\n\n\n\n\nMaking the nose rotate\n\n\nTo make this look less static, we will animate the model.\n\n\n\n\nThe main.js needs to be adapted to integrate the new animation code:\n    > Note: This codes demonstrates the animation system but you could rely upon the manual animation as well: \nAnimation Tutorial\n.\n\n\n\n\n// Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's load the red nose model.\nBABYLON.SceneLoader.ImportMesh(null, \"assets/\", \"redNose.obj\", scene, function (meshes) {\n    // Keeps track of our model root.\n    var redNoseModel = meshes[0];\n\n    // Creates a default light and camera.\n    scene.createDefaultCameraOrLight(true);\n\n    // This attaches the input camera controls to the canvas\n    scene.activeCamera.attachControl(canvas, false);\n\n    // Create a rotation animation at 30 FPS\n    var animation = new BABYLON.Animation(\"rotationAnimation\", \"rotation.y\", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);\n\n    // Add the animation key frames.\n    var keys = [];\n    // At the animation key 0, the value of rotation is \"0\"\n    keys.push({\n        frame: 30 * 0,\n        value: 0\n    });\n\n    // At the animation key at 1 second, the value of scaling is a quarter of turn\n    keys.push({\n        frame: 30 * 1,\n        value: Math.PI / 2\n    });\n\n    // At the animation key at 2 seconds, the value of scaling is a half of turn\n    keys.push({\n        frame: 30 * 2,\n        value: Math.PI\n    });\n\n    // At the animation key at 3 seconds, the value of scaling is 3 quarter of turn\n    keys.push({\n        frame: 30 * 3,\n        value: Math.PI / 2 * 3\n    });\n\n    // At the animation key at 4 seconds, the value of scaling is a full turn\n    keys.push({\n        frame: 30 * 4,\n        value: Math.PI * 2\n    });\n\n    // Adding keys to the animation object\n    animation.setKeys(keys);\n\n    // Then add the animation object to redNoseModel\n    redNoseModel.animations.push(animation);\n\n    // Finally, launch animations on box1, from key 0 to key 60 * 4 with loop activated\n    scene.beginAnimation(redNoseModel, 0, 60 * 4, true);\n\n    // Register a render loop to repeatedly render the scene\n    engine.runRenderLoop(function () {\n        scene.render();\n    });\n});\n\n\n\n\nReferences\n\n\n\n\nBabylon JS Documentation\n\n\n\n\ncontinue to \nnext task >>",
            "title": "512b Babylon"
        },
        {
            "location": "/stories/5/512b_Babylon/#task-512b-create-a-babylonjs-solution-to-visualize-3d-model",
            "text": "Now that we have a proper 3D model of our nose prototype, we can start rendering it in real-time through a Javascript UWP application. To create the application, we use the Visual Studio 2017 Javasctipt UWP template.  In order to load and render our model, we will rely on Babylon JS which is a WebGL based 3d engine.  As Babylon does not support natively loading FBX, we will first need to convert our FBX file to a Bablylon supported format (babylon, GlTF or OBJ).",
            "title": "Task 5.1.2b - Create a BabylonJS solution to visualize 3D Model"
        },
        {
            "location": "/stories/5/512b_Babylon/#prerequisites",
            "text": "This walkthrough assumes that you have:  Windows 10 Creators Update  3D Nose Model from Paint 5.1.1\n* Visual Studio 2017 with the Universal Windows Platform Development Workload to create a Javascript UWP",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/5/512b_Babylon/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/5/512b_Babylon/#convert-the-model-to-obj",
            "text": "To convert the model, we will use the online FBX to OBJ converter, using the FBX we exported in 5.1.1.\n1. Go to:  Online Model Converter \n2. Follow the steps in the tool to convert the FBX to OBJ, and download the OBJ file. The MTL file is not needed.\n3. The problem here is that we don't have the texture, but you can use any png file, just create a new file in pain with a red color and use it through these steps.",
            "title": "Convert the model to OBJ"
        },
        {
            "location": "/stories/5/512b_Babylon/#creating-a-new-project",
            "text": "Launch Visual Studio 2017 using the Windows Start Menu. Once open, click File>New>Project...\n    > Note: If you launch if for the first time, log in with your MSA account.    In the \"Create New Project\" dialog under template, select Javascript>Windows Universal>Blank App, and give the project a proper name like \"BabylonUWP\".     Click Ok to create your project.\n    > Note: You may be asked to turn on the developer mode in the Windows settings in order to create the UWP.    Your project is now ready and it can easily be launched by pressing F5 (for debug mode) or Ctrl+F5 (for normal mode). You should see an application running with a white page containing the text: \"Content goes here!\".",
            "title": "Creating a new project"
        },
        {
            "location": "/stories/5/512b_Babylon/#adding-babylon-js-dependency",
            "text": "It is now time to add content in our UWP.    Add the Babylon.JS dependency to your project (this allows your project to work offline). Right click on the  js  folder, click on  Add -> Existing Item... . Copy this link to your clipboard ( https://preview.babylonjs.com/babylon.js ) and paste it in the  File name  box. Click  Add .      Add the Babylon.JS OBJ Loader dependency to your project (this allows your project to work offline). Similar to the previous step, use this link to add the file to the js folder ( https://preview.babylonjs.com/loaders/babylon.objFileLoader.js )    The solution folder should now look like this:     It is now time to integrate those files in the application. Open the  index.html  file and add the two following script references  before  the main.js one:    <!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>BabylonUWP</title>\n    <link href=\"css/default.css\" rel=\"stylesheet\" />\n</head>\n<body>\n    <div>Content goes here!</div>\n\n    <script src=\"js/babylon.js\"></script>\n    <script src=\"js/babylon.objFileLoader.js\"></script>\n    <script src=\"js/main.js\"></script>\n</body>\n</html>   The project can now be launched in debug by pressing F5 to ensure that the setup is correct. No error should be displayed in the javascript console.",
            "title": "Adding Babylon JS dependency"
        },
        {
            "location": "/stories/5/512b_Babylon/#create-your-first-scene",
            "text": "As the project is ready, we can now create our first 3D scene as explained in the  Basic Tutorial  of Babylon JS.    The  div  element containing the text: \"Content goes here!\" needs to be replaced by a canvas enabling WebGL rendering in Html. Open the  index.html  and replace  <div>Content goes here!</div>  by  <canvas id=\"renderCanvas\"></canvas> .    The  index.html  file should look like this:    <!DOCTYPE html>\n<html>\n<head>\n    <meta charset=\"utf-8\" />\n    <title>BabylonUWP</title>\n    <link href=\"css/default.css\" rel=\"stylesheet\" />\n</head>\n<body>\n    <canvas id=\"renderCanvas\"></canvas>\n\n    <script src=\"js/babylon.js\"></script>\n    <script src=\"js/babylon.objFileLoader.js\"></script>\n    <script src=\"js/main.js\"></script>\n</body>\n</html>   To ensure that the canvas is rendered in full screen, replace the content of the file  css/default.css  by the following one:   html, body {\n    overflow: hidden;\n    width: 100%;\n    height: 100%;\n    margin: 0;\n    padding: 0;\n}\n\n#renderCanvas {\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n}   The setup being done, open the  js/main.js  file and replace its content by the following:   // Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's try our built-in 'box' shape. Params: name, size.\nvar box1 = BABYLON.Mesh.CreateBox(\"box1\", 1);\n\n// Creates a default light and camera.\nscene.createDefaultCameraOrLight(true);\n\n// This attaches the input camera controls to the canvas\nscene.activeCamera.attachControl(canvas, false);\n\n// Register a render loop to repeatedly render the scene\nengine.runRenderLoop(function () {\n    scene.render();\n});    The project can now be launched and displays a cube in 3D !!! The camera can rotate by holding the mouse left click on the application. The zoom level is controlled by the mouse wheel.",
            "title": "Create your first scene"
        },
        {
            "location": "/stories/5/512b_Babylon/#loading-the-3d-nose-model",
            "text": "Create a folder named  assets  at the root of the solution and copy your  redNose.obj  file in this folder.    Instead of creating a sphere, the model needs to be loaded. The content of the  js/main.js  file needs to be updated to:    // Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's load the red nose model.\nBABYLON.SceneLoader.ImportMesh(null, \"assets/\", \"redNose.obj\", scene, function (meshes) {\n    // Keeps track of our model root.\n    var redNoseModel = meshes[0];\n\n    // Creates a default light and camera.\n    scene.createDefaultCameraOrLight(true);\n\n    // This attaches the input camera controls to the canvas\n    scene.activeCamera.attachControl(canvas, false);\n\n    // Register a render loop to repeatedly render the scene\n    engine.runRenderLoop(function () {\n        scene.render();\n    });\n});   By launching the project now,  we can see a beautiful red nose model displayed in a Javascript UWP application.",
            "title": "Loading the 3D Nose model"
        },
        {
            "location": "/stories/5/512b_Babylon/#making-the-nose-rotate",
            "text": "To make this look less static, we will animate the model.   The main.js needs to be adapted to integrate the new animation code:\n    > Note: This codes demonstrates the animation system but you could rely upon the manual animation as well:  Animation Tutorial .   // Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's load the red nose model.\nBABYLON.SceneLoader.ImportMesh(null, \"assets/\", \"redNose.obj\", scene, function (meshes) {\n    // Keeps track of our model root.\n    var redNoseModel = meshes[0];\n\n    // Creates a default light and camera.\n    scene.createDefaultCameraOrLight(true);\n\n    // This attaches the input camera controls to the canvas\n    scene.activeCamera.attachControl(canvas, false);\n\n    // Create a rotation animation at 30 FPS\n    var animation = new BABYLON.Animation(\"rotationAnimation\", \"rotation.y\", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);\n\n    // Add the animation key frames.\n    var keys = [];\n    // At the animation key 0, the value of rotation is \"0\"\n    keys.push({\n        frame: 30 * 0,\n        value: 0\n    });\n\n    // At the animation key at 1 second, the value of scaling is a quarter of turn\n    keys.push({\n        frame: 30 * 1,\n        value: Math.PI / 2\n    });\n\n    // At the animation key at 2 seconds, the value of scaling is a half of turn\n    keys.push({\n        frame: 30 * 2,\n        value: Math.PI\n    });\n\n    // At the animation key at 3 seconds, the value of scaling is 3 quarter of turn\n    keys.push({\n        frame: 30 * 3,\n        value: Math.PI / 2 * 3\n    });\n\n    // At the animation key at 4 seconds, the value of scaling is a full turn\n    keys.push({\n        frame: 30 * 4,\n        value: Math.PI * 2\n    });\n\n    // Adding keys to the animation object\n    animation.setKeys(keys);\n\n    // Then add the animation object to redNoseModel\n    redNoseModel.animations.push(animation);\n\n    // Finally, launch animations on box1, from key 0 to key 60 * 4 with loop activated\n    scene.beginAnimation(redNoseModel, 0, 60 * 4, true);\n\n    // Register a render loop to repeatedly render the scene\n    engine.runRenderLoop(function () {\n        scene.render();\n    });\n});",
            "title": "Making the nose rotate"
        },
        {
            "location": "/stories/5/512b_Babylon/#references",
            "text": "Babylon JS Documentation",
            "title": "References"
        },
        {
            "location": "/stories/5/512b_Babylon/#continue-to-next-task",
            "text": "",
            "title": "continue to next task &gt;&gt;"
        },
        {
            "location": "/stories/5/521_MR/",
            "text": "Task 5.2.1 - Retarget UWP app to Mixed Reality Platform\n\n\nThe keynote is at a VR conference so we need a VR demo showing our Nose Prototypes. Having our 3D UWP app from 5.1.2a we can easily turn this into a VR enabled app.\n\n\nPrerequisites\n\n\nThis walkthrough assumes that you have:\n\n Windows 10 Creators Update\n\n 3D Nose Model from Paint 5.1.1 and 3D UWP from 5.1.2a\n* Unity 5.6 with UWP Plugin for exporting UWP\n\n\nTask\n\n\nUsing Unity 3D to enable Mixed Reality\n\n\nSupporting Mixed Reality in Unity is just a simple toggle on the Build Settings in Unity.\n1. Open the Nose3D project you created in Unity.\n2. Go to \nFile->Build Settings\n and click \nPlayer Settings\n\n3. A new Player Settings property pane appears on the right side of the Unity3D window.\n4. Click \nOther Settings\n to reveal a new set of properties.\n5. Tick the \nVirtual Reality Supported\n checkbox. Windows Holographic should appear automatically.\n\n\n![3D objects tool](images/521_1.png)\n\n\n\n\n\nExport the project again, replacing the Folder you exported to in 5.1.2a.\n\n\nOpen the Nose3D.sln solution and build/deploy/run the UWP, it should now automatically detect that VR is enabled and will run in the connected VR headset.\n\n\n\n\n\n\nNote: Connecting a new VR headset requires the latest Windows 10 build. Windows will automatically detect the headset and launch the Mixed Reality portal. Follow the configuration steps here to set it up correctly.\n\n\n\n\nReferences",
            "title": "521 MR"
        },
        {
            "location": "/stories/5/521_MR/#task-521-retarget-uwp-app-to-mixed-reality-platform",
            "text": "The keynote is at a VR conference so we need a VR demo showing our Nose Prototypes. Having our 3D UWP app from 5.1.2a we can easily turn this into a VR enabled app.",
            "title": "Task 5.2.1 - Retarget UWP app to Mixed Reality Platform"
        },
        {
            "location": "/stories/5/521_MR/#prerequisites",
            "text": "This walkthrough assumes that you have:  Windows 10 Creators Update  3D Nose Model from Paint 5.1.1 and 3D UWP from 5.1.2a\n* Unity 5.6 with UWP Plugin for exporting UWP",
            "title": "Prerequisites"
        },
        {
            "location": "/stories/5/521_MR/#task",
            "text": "",
            "title": "Task"
        },
        {
            "location": "/stories/5/521_MR/#using-unity-3d-to-enable-mixed-reality",
            "text": "Supporting Mixed Reality in Unity is just a simple toggle on the Build Settings in Unity.\n1. Open the Nose3D project you created in Unity.\n2. Go to  File->Build Settings  and click  Player Settings \n3. A new Player Settings property pane appears on the right side of the Unity3D window.\n4. Click  Other Settings  to reveal a new set of properties.\n5. Tick the  Virtual Reality Supported  checkbox. Windows Holographic should appear automatically.  ![3D objects tool](images/521_1.png)   Export the project again, replacing the Folder you exported to in 5.1.2a.  Open the Nose3D.sln solution and build/deploy/run the UWP, it should now automatically detect that VR is enabled and will run in the connected VR headset.    Note: Connecting a new VR headset requires the latest Windows 10 build. Windows will automatically detect the headset and launch the Mixed Reality portal. Follow the configuration steps here to set it up correctly.",
            "title": "Using Unity 3D to enable Mixed Reality"
        },
        {
            "location": "/stories/5/521_MR/#references",
            "text": "",
            "title": "References"
        },
        {
            "location": "/stories/5/story_5/",
            "text": "A great opportunity has developed! We are invited to speak in the keynote of NoseCon 2017! The topic is how 3D and VR is helping us with rapid prototyping. We need to create a keynote demo for NoseCon that renders a Nose Prototype in 3D, or even in VR if we find the time. This is highly confidential. \n\n\n\n\nDeliverable\n - Build a UWP 3D Visualizer\n\n\n5.1.1\n - [Committed] Create the model in Paint3D\n\n\n5.1.2a\n - [Committed] Create a Unity solution to visualize 3D Model (d 5.1.1) or\n\n\n5.1.2b\n - [Committed] Create a BabylonJS solution to visualize 3D Model (d 5.1.1)\n\n\n\n\n\n\nDeliverable\n - Visualize noses in VR\n\n\n5.2.1\n - [Proposed] Re-target UWP app to Mixed Reality Platform (d 5.1.2)",
            "title": "Story 5"
        }
    ]
}