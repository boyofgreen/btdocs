{
    "docs": [
        {
            "location": "/", 
            "text": "Adventure Works Knowzy Backlog\n\n\nThere are four User Stories that we are focusing on for this iteration. Each User Story is split into multiple deliverables that each contains several tasks. You will find two types of tasks:\n\n\n\n\nRequired - we've done our research, you just need to implement the work and learn the technology along the way\n\n\nOptional - we like this idea, but we have not decided on the implementation, it's up to you\n\n\n\n\nUser stories are mostly self contained and can be completed in parallel. However, as you get farther along in a specific user story, you might run into tasks that depend on other User Stories. Therefore, the recommendation is to assign the user stories to members of your team and to tackle them in parallel. \n\n\nIf you are blocked, a representative from the leadership team is always there to help, don't be afraid to reach out.\n\n\nThe source code for our applications is all open source and can be found on \nour github account\n.\n\n\n\n\n\n\nMachine Setup Instructions\n\n\n\n\n\n\nUser Story\n - The shipping department has a fast, responsive, and powerful application for managing day to day duties\n\n\n\n\nDeliverable\n - Make app more responsive\n\n\n1.1.1 [Required] - Build a responsive Web App\n\n\n1.1.2 [Required] - Generate Progressive Web App (d. 1.1.1)\n\n\n1.1.3 [Required] - Update Web App to PWA (d. 1.1.1)\n\n\n1.1.4 [Required] - Test Your App (d. 1.1.1)\n\n\n\n\n\n\nDeliverable\n - Add Native functionality\n\n\n1.2.1 [Required] - Add Live Tile (d. 1.1.1) \n\n\n1.2.2 [Optional] - Add Share and Secondary Pinning (d. 1.1.2)\n\n\n1.2.3 [Optional] - Make PWA Linkable (d. 1.1.2)\n\n\n1.2.4 [Optional] - Add In-Memory Caching\n\n\n\n\n\n\n\n\n\n\n\n\nUser Story\n - The product department has a modern, secure and forward-looking platform for managing product development life cycle\n\n\n\n\nDeliverable\n - Enable integration of UWP APIs\n\n\n2.1.1 [Required] - Add Desktop Bridge support in Visual Studio\n\n\n2.1.2 [Required] - Debugging a Windows Desktop Bridge App (d. 2.1.1)\n\n\n2.1.3 [Required] - Adding UWP APIs to a Desktop Bridge App (d. 2.1.2)\n        \n\n\n2.1.4 [Required] - Integrate Windows Hello authentication (d. 2.1.3)\n\n\n\n\n\n\nDeliverable\n - Add UWP XAML support\n\n\n2.2.1 [Required] - Create a new XAML view as part of app package (d. 2.1.1)\n\n\n2.2.2 [Required] - Add support for other apps to share images and create new items (d. 2.1.1)\n\n\n2.2.3 [Required] - Create a new UWP app that integrates with App Services (d. 2.1.1)\n\n\n\n\n\n\nDeliverable\n - Build enhanced UWP experience (d. 2.2.*)\n\n\n2.3.1 [Optional] - Add support for ink (d. 2.2.*)\n\n\n2.3.2 [Optional] - Add complete support for Windows Hello Authentication (d. 2.1.3)\n\n\n2.3.3 [Optional] - Add support for more UWP features (d. 2.2.*)\n\n\n\n\n\n\n\n\n\n\n\n\nUser Story\n - Consumers have a fun mobile experience \n\n\n\n\nDeliverable\n - Create a UWP and Android mobile app\n\n\n3.1.1 [Required] - Create a Xamarin.Forms app with shared UI\n\n\n3.1.2 [Required] - Integrate native camera to capture image for each platform (d. 3.1.1)\n\n\n3.1.3 [Required] - Add InkCanvas support for UWP (d. 3.1.2)\n\n\n\n\n\n\nDeliverable\n - Add intelligence to the mobile app\n\n\n3.2.1 [Required] - Set up Cognitive Services Custom Vision Service\n\n\n3.2.2 [Required] - Set up Cognitive Services Emotion Service (d. 3.2.1)\n\n\n3.2.3 [Required] - Update Xamarin App to call Cognitive Services APIs (d. 3.2.2)\n\n\n\n\n\n\nDeliverable\n - Create a fun social experience\n\n\n3.3.1 [Optional] - Support sharing images to Social Networks (d. 3.2.3)\n\n\n3.3.2 [Optional] - Support cross device scenarios (Project Rome) (d. 3.3.1)\n\n\n\n\n\n\nDeliverable\n - Add automatic image analysis\n\n\n3.4.1 [Optional] - Set up Cognitive Services for image face analysis in Azure (d. 323)\n\n\n3.4.2 [Optional] - Create an Azure Function to analyze an image and return nose location to automatically position in app (d. 3.4.1)\n\n\n\n\n\n\nDeliverable\n - Set up Continuous Integration and Deployment\n\n\n3.5.1 [Optional] - Set up Continuous Integration and Deployment for the Windows App using Visual Studio Mobile Center\n\n\n3.5.2 [Optional] - Set up Continuous Integration and Deployment for the Android App using Visual Studio Mobile Center\n\n\n3.5.3 [Optional] - Add Custom Event Logging using Visual Studio Mobile Center\n\n\n\n\n\n\nDeliverable\n - Create a chat bot for support and for order status management \n\n\n3.6.1 [Optional] - Create a bot using the Microsoft Bot Framework\n\n\n\n\n\n\n\n\n\n\n\n\nUser Story\n - All platform services are integrated in one platform\n\n\n\n\nDeliverable\n - Unify and Publish all services\n\n\n4.1.1 - [Required] Create a shared CosmosDB to store all data\n\n\n4.1.2 - [Required] Create API endpoint for shipping services (d. 4.1.1)\n\n\n4.1.3 - [Required] Create API endpoint for product services (d. 4.1.1)\n\n\n4.1.4 - [Required] Create Docker images (d. 4.1.2, 4.1.3)\n\n\n4.1.5 - [Required] Configure Kubernetes and publish to Azure (d. 4.1.4)\n\n\n4.1.6 - [Optional] Integrate Website and APIs (d. 4.1.5)\n\n\n\n\n\n\nDeliverable\n - Set up Continuous Delivery\n\n\n4.2.1 - [Optional] Set up Visual Studio Team Services\n\n\n4.2.2 - [Optional] Continuous Delivery to Kubernetes using VSTS (d. 4.1.5, 4.2.0)\n\n\n\n\n\n\nDeliverable\n - Set up Telemetry\n\n\n4.3.1 - [Optional] Set up telemetry for the web app and APIs\n\n\n\n\n\n\n\n\n\n\n\n\nGood luck!", 
            "title": "Home"
        }, 
        {
            "location": "/#adventure-works-knowzy-backlog", 
            "text": "There are four User Stories that we are focusing on for this iteration. Each User Story is split into multiple deliverables that each contains several tasks. You will find two types of tasks:   Required - we've done our research, you just need to implement the work and learn the technology along the way  Optional - we like this idea, but we have not decided on the implementation, it's up to you   User stories are mostly self contained and can be completed in parallel. However, as you get farther along in a specific user story, you might run into tasks that depend on other User Stories. Therefore, the recommendation is to assign the user stories to members of your team and to tackle them in parallel.   If you are blocked, a representative from the leadership team is always there to help, don't be afraid to reach out.  The source code for our applications is all open source and can be found on  our github account .    Machine Setup Instructions    User Story  - The shipping department has a fast, responsive, and powerful application for managing day to day duties   Deliverable  - Make app more responsive  1.1.1 [Required] - Build a responsive Web App  1.1.2 [Required] - Generate Progressive Web App (d. 1.1.1)  1.1.3 [Required] - Update Web App to PWA (d. 1.1.1)  1.1.4 [Required] - Test Your App (d. 1.1.1)    Deliverable  - Add Native functionality  1.2.1 [Required] - Add Live Tile (d. 1.1.1)   1.2.2 [Optional] - Add Share and Secondary Pinning (d. 1.1.2)  1.2.3 [Optional] - Make PWA Linkable (d. 1.1.2)  1.2.4 [Optional] - Add In-Memory Caching       User Story  - The product department has a modern, secure and forward-looking platform for managing product development life cycle   Deliverable  - Enable integration of UWP APIs  2.1.1 [Required] - Add Desktop Bridge support in Visual Studio  2.1.2 [Required] - Debugging a Windows Desktop Bridge App (d. 2.1.1)  2.1.3 [Required] - Adding UWP APIs to a Desktop Bridge App (d. 2.1.2)           2.1.4 [Required] - Integrate Windows Hello authentication (d. 2.1.3)    Deliverable  - Add UWP XAML support  2.2.1 [Required] - Create a new XAML view as part of app package (d. 2.1.1)  2.2.2 [Required] - Add support for other apps to share images and create new items (d. 2.1.1)  2.2.3 [Required] - Create a new UWP app that integrates with App Services (d. 2.1.1)    Deliverable  - Build enhanced UWP experience (d. 2.2.*)  2.3.1 [Optional] - Add support for ink (d. 2.2.*)  2.3.2 [Optional] - Add complete support for Windows Hello Authentication (d. 2.1.3)  2.3.3 [Optional] - Add support for more UWP features (d. 2.2.*)       User Story  - Consumers have a fun mobile experience    Deliverable  - Create a UWP and Android mobile app  3.1.1 [Required] - Create a Xamarin.Forms app with shared UI  3.1.2 [Required] - Integrate native camera to capture image for each platform (d. 3.1.1)  3.1.3 [Required] - Add InkCanvas support for UWP (d. 3.1.2)    Deliverable  - Add intelligence to the mobile app  3.2.1 [Required] - Set up Cognitive Services Custom Vision Service  3.2.2 [Required] - Set up Cognitive Services Emotion Service (d. 3.2.1)  3.2.3 [Required] - Update Xamarin App to call Cognitive Services APIs (d. 3.2.2)    Deliverable  - Create a fun social experience  3.3.1 [Optional] - Support sharing images to Social Networks (d. 3.2.3)  3.3.2 [Optional] - Support cross device scenarios (Project Rome) (d. 3.3.1)    Deliverable  - Add automatic image analysis  3.4.1 [Optional] - Set up Cognitive Services for image face analysis in Azure (d. 323)  3.4.2 [Optional] - Create an Azure Function to analyze an image and return nose location to automatically position in app (d. 3.4.1)    Deliverable  - Set up Continuous Integration and Deployment  3.5.1 [Optional] - Set up Continuous Integration and Deployment for the Windows App using Visual Studio Mobile Center  3.5.2 [Optional] - Set up Continuous Integration and Deployment for the Android App using Visual Studio Mobile Center  3.5.3 [Optional] - Add Custom Event Logging using Visual Studio Mobile Center    Deliverable  - Create a chat bot for support and for order status management   3.6.1 [Optional] - Create a bot using the Microsoft Bot Framework       User Story  - All platform services are integrated in one platform   Deliverable  - Unify and Publish all services  4.1.1 - [Required] Create a shared CosmosDB to store all data  4.1.2 - [Required] Create API endpoint for shipping services (d. 4.1.1)  4.1.3 - [Required] Create API endpoint for product services (d. 4.1.1)  4.1.4 - [Required] Create Docker images (d. 4.1.2, 4.1.3)  4.1.5 - [Required] Configure Kubernetes and publish to Azure (d. 4.1.4)  4.1.6 - [Optional] Integrate Website and APIs (d. 4.1.5)    Deliverable  - Set up Continuous Delivery  4.2.1 - [Optional] Set up Visual Studio Team Services  4.2.2 - [Optional] Continuous Delivery to Kubernetes using VSTS (d. 4.1.5, 4.2.0)    Deliverable  - Set up Telemetry  4.3.1 - [Optional] Set up telemetry for the web app and APIs       Good luck!", 
            "title": "Adventure Works Knowzy Backlog"
        }, 
        {
            "location": "/references/", 
            "text": "Build Tour 2017 References\n\n\n\n\nNote: This is a live page that will be updated during the Build Tour. More content coming later this month.\n\n\n\n\nKeynote\n\n\n\n\nBring your app to the Windows Store\n\n\nModernize your app with UWP\n\n\nXAML Standard and .NET Standard 2.0\n\n\nMicrosoft Graph\n\n\nMicrosoft Azure\n\n\nFluent Design System\n\n\nMixed Reality\n\n\n\n\nProgressive Web Apps\n\n\n\n\nPWABuilder Tool\n\n\nPWA for Education Blog Post\n\n\nPWA Recorded Session from Build 2017\n\n\n\n\nDesktop Bridge\n\n\n\n\nDesktop Bridge\n\n\nFeedback\n\n\nSamples\n\n\nMicrosoft Virtual Academy Tutorials\n\n\n\n\nXamarin\n\n\n\n\nXamarin Live Player\n \n\n\nVisual Studio Mobile Center\n  \n\n\nXamarin Session demos: \nTasky\n, \nAzure Storage\n, \nEmbedded Forms\n \n\n\nWhat's new in Xamarin Forms, Build 2017\n \n\n\nVisual Studio Mobile Center, Build 2017\n\n\n\n\nContainers\n\n\n\n\nContainers\n\n\nMicrosoft Docker Hub\n\n\nVisual Studio Code\n\n\nVS Code Docker Extension\n\n\n\n\nWhat's New in AI\n\n\n\n\nMicrosoft AI\n\n\nCognitive Services\n\n\nCustom Vision Service\n\n\nCustom Speech Service\n\n\nAdaptive Cards\n\n\nBot Framework\n\n\n\n\nServerless in Azure\n\n\n\n\nTry Functions and Logic App\n\n\nAzure Function Community", 
            "title": "References"
        }, 
        {
            "location": "/references/#build-tour-2017-references", 
            "text": "Note: This is a live page that will be updated during the Build Tour. More content coming later this month.", 
            "title": "Build Tour 2017 References"
        }, 
        {
            "location": "/references/#keynote", 
            "text": "Bring your app to the Windows Store  Modernize your app with UWP  XAML Standard and .NET Standard 2.0  Microsoft Graph  Microsoft Azure  Fluent Design System  Mixed Reality", 
            "title": "Keynote"
        }, 
        {
            "location": "/references/#progressive-web-apps", 
            "text": "PWABuilder Tool  PWA for Education Blog Post  PWA Recorded Session from Build 2017", 
            "title": "Progressive Web Apps"
        }, 
        {
            "location": "/references/#desktop-bridge", 
            "text": "Desktop Bridge  Feedback  Samples  Microsoft Virtual Academy Tutorials", 
            "title": "Desktop Bridge"
        }, 
        {
            "location": "/references/#xamarin", 
            "text": "Xamarin Live Player    Visual Studio Mobile Center     Xamarin Session demos:  Tasky ,  Azure Storage ,  Embedded Forms    What's new in Xamarin Forms, Build 2017    Visual Studio Mobile Center, Build 2017", 
            "title": "Xamarin"
        }, 
        {
            "location": "/references/#containers", 
            "text": "Containers  Microsoft Docker Hub  Visual Studio Code  VS Code Docker Extension", 
            "title": "Containers"
        }, 
        {
            "location": "/references/#whats-new-in-ai", 
            "text": "Microsoft AI  Cognitive Services  Custom Vision Service  Custom Speech Service  Adaptive Cards  Bot Framework", 
            "title": "What's New in AI"
        }, 
        {
            "location": "/references/#serverless-in-azure", 
            "text": "Try Functions and Logic App  Azure Function Community", 
            "title": "Serverless in Azure"
        }, 
        {
            "location": "/stories/0/0_Setup/", 
            "text": "Task 0 - Machine Setup Instructions\n\n\nBefore you get started let's make sure your machine has everything installed to be able to complete all tasks for the workshops. Please take some time to go through these steps to save time later during the day.\n\n\n\n\n\n\nInstall \nThe Hack Checklist\n from the Windows Store.  Run the tool to make sure you have all components installed.\n\n\n\n\n\n\nIf you are missing components \nask one of the proctors for their USB key\n to install the missing components. We have Visual Studio 2017 Community edition, Unity tools, Docker and more on the USB key. \n\n\nDon't try to download from the internet, the network connection is really slow and you are wasting some time downloading instead of having fun\n\n\n\n\n\n\nGo to \nour backlog\n and have some fun", 
            "title": "0 Setup"
        }, 
        {
            "location": "/stories/0/0_Setup/#task-0-machine-setup-instructions", 
            "text": "Before you get started let's make sure your machine has everything installed to be able to complete all tasks for the workshops. Please take some time to go through these steps to save time later during the day.    Install  The Hack Checklist  from the Windows Store.  Run the tool to make sure you have all components installed.    If you are missing components  ask one of the proctors for their USB key  to install the missing components. We have Visual Studio 2017 Community edition, Unity tools, Docker and more on the USB key.", 
            "title": "Task 0 - Machine Setup Instructions"
        }, 
        {
            "location": "/stories/0/0_Setup/#dont-try-to-download-from-the-internet-the-network-connection-is-really-slow-and-you-are-wasting-some-time-downloading-instead-of-having-fun", 
            "text": "Go to  our backlog  and have some fun", 
            "title": "Don't try to download from the internet, the network connection is really slow and you are wasting some time downloading instead of having fun"
        }, 
        {
            "location": "/stories/1/111_BuildWebApp/", 
            "text": "Task 1.1.1 - Build a Responsive Web App\n\n\nPrerequisites\n\n\nYou will need \nVisual Studio 2017\n.\n\n\nBegin by downloading the codebase for the webapp, go to the git repo \nhttps://github.com/Knowzy/KnowzyInternalApps\n and clone or download the content onto your local computer.\n\n\nTask\n\n\nMake your website responsive.\n\n\nMost of the work has already been done to make sure that your site works well across different devices, but you will need to make a few adjustments to the code base to ensure that it flows properly for screens of all sizes.  You should also make sure that the webapp works across platforms, since some of the Knowzy contractors carry Android tablets instead of Windows 10 devices.\n\n\nYou should have the code repo on your local device. Open the folder \n\\src\\Knowzy_Shipping_WebApp\n and run your web site locally by double-clicking the \"Microsoft.Knowzy\" Visual Studio file to see the webapp project that you are starting with.\n\n\n\n\n\n\n\n\n\nOpen up your site.css file at the following path:\n\n\n\\wwwroot\\css\\site.css\n\n\n\nand find the following declaration toward the top of the page:\n\n\n.container-main {\n    width: 800px;\n    padding-right: 15px;\n    padding-left: 15px;\n    margin: 0 auto;\n}\n\n\n\n\n\n\n\nAdd a declaration for the \"container-main\" class inside of a media query. Media queries resize the page properly for different screen sizes. You will want to create media queries with style declarations for the screen sizes of 320px, 768px, 992px, and 1200px like below:\n\n\n@media all and (min-width:320px) {\n    .container-main {\n        width: 100%;\n    }\n}\n\n@media all and (min-width:768px) {\n    .container-main {\n        width: 750px;\n    }\n}\n\n@media all and (min-width:992px) {\n    .container-main {\n        width: 970px;\n    }\n}\n\n@media all and (min-width:1200px) {\n    .container-main {\n        width: 1170px;\n    }\n}\n\n\n\nBe sure to add these rules \nbelow\n the \"container-main\" rule, so the media queries will override the width of the main rule.\n\n\n\n\n\n\nView your web app in a browser (you can do this  by hitting F5 in visual studio or clicking on the start button), and adjust the width of your window to test responsiveness of the design.  If you have a tablet device, you can change the orientation of your device to make sure that the page response properly.  \n\n\n\n\n\n\n\n\n\nYour app is now ready to be viewed on devices with different screen sizes and orientations.\n\n\nDeploy your ASP.net App Changes\n\n\nNow that you have these powerful new features running locally, you can publish them to your website on Azure.\n\n\n\n\n\n\nIn Visual Studio select the \"Microsoft.Knowzy.WebApp\" in the solution explorer, then choose Build \n Publish... \n\n\nNOTE:\n Some configurations of Visual Studio may have the \"publish\" option as its own menu.\n\n\n\n\n\n\n\n\nChoose \"Microsoft Azure App Service\" from the selection screen\n\n\n\n\n\n\n\n\nSign into your Azure account to create a new Azure App Service. If you do not have an Azure subscription, please ask one of the proctors for one!\n\n\nNOTE:\n We recommend that you use the default Web App Name to avoid conflicts. You may also have to press \"Create\" more than once to confirm the creation of the App Service, the Resource Group, and the App Service Plan.\n\n\n\n\n\n\n\n\nHit \"Create\" and wait for your web app to finish deploying.\n\n\n\n\n\n\nKeep track of the \"Site URL\" after creating your web app; you'll want to use this later.\n\n\n\n\n\n\n\n\nReferences\n\n\n\n\nKnowzy App GitHub Repo\n\n\n\n\nContinue to \nnext task", 
            "title": "111 BuildWebApp"
        }, 
        {
            "location": "/stories/1/111_BuildWebApp/#task-111-build-a-responsive-web-app", 
            "text": "", 
            "title": "Task 1.1.1 - Build a Responsive Web App"
        }, 
        {
            "location": "/stories/1/111_BuildWebApp/#prerequisites", 
            "text": "You will need  Visual Studio 2017 .  Begin by downloading the codebase for the webapp, go to the git repo  https://github.com/Knowzy/KnowzyInternalApps  and clone or download the content onto your local computer.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/1/111_BuildWebApp/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/1/111_BuildWebApp/#make-your-website-responsive", 
            "text": "Most of the work has already been done to make sure that your site works well across different devices, but you will need to make a few adjustments to the code base to ensure that it flows properly for screens of all sizes.  You should also make sure that the webapp works across platforms, since some of the Knowzy contractors carry Android tablets instead of Windows 10 devices.  You should have the code repo on your local device. Open the folder  \\src\\Knowzy_Shipping_WebApp  and run your web site locally by double-clicking the \"Microsoft.Knowzy\" Visual Studio file to see the webapp project that you are starting with.     Open up your site.css file at the following path:  \\wwwroot\\css\\site.css  and find the following declaration toward the top of the page:  .container-main {\n    width: 800px;\n    padding-right: 15px;\n    padding-left: 15px;\n    margin: 0 auto;\n}    Add a declaration for the \"container-main\" class inside of a media query. Media queries resize the page properly for different screen sizes. You will want to create media queries with style declarations for the screen sizes of 320px, 768px, 992px, and 1200px like below:  @media all and (min-width:320px) {\n    .container-main {\n        width: 100%;\n    }\n}\n\n@media all and (min-width:768px) {\n    .container-main {\n        width: 750px;\n    }\n}\n\n@media all and (min-width:992px) {\n    .container-main {\n        width: 970px;\n    }\n}\n\n@media all and (min-width:1200px) {\n    .container-main {\n        width: 1170px;\n    }\n}  Be sure to add these rules  below  the \"container-main\" rule, so the media queries will override the width of the main rule.    View your web app in a browser (you can do this  by hitting F5 in visual studio or clicking on the start button), and adjust the width of your window to test responsiveness of the design.  If you have a tablet device, you can change the orientation of your device to make sure that the page response properly.       Your app is now ready to be viewed on devices with different screen sizes and orientations.", 
            "title": "Make your website responsive."
        }, 
        {
            "location": "/stories/1/111_BuildWebApp/#deploy-your-aspnet-app-changes", 
            "text": "Now that you have these powerful new features running locally, you can publish them to your website on Azure.    In Visual Studio select the \"Microsoft.Knowzy.WebApp\" in the solution explorer, then choose Build   Publish...   NOTE:  Some configurations of Visual Studio may have the \"publish\" option as its own menu.     Choose \"Microsoft Azure App Service\" from the selection screen     Sign into your Azure account to create a new Azure App Service. If you do not have an Azure subscription, please ask one of the proctors for one!  NOTE:  We recommend that you use the default Web App Name to avoid conflicts. You may also have to press \"Create\" more than once to confirm the creation of the App Service, the Resource Group, and the App Service Plan.     Hit \"Create\" and wait for your web app to finish deploying.    Keep track of the \"Site URL\" after creating your web app; you'll want to use this later.", 
            "title": "Deploy your ASP.net App Changes"
        }, 
        {
            "location": "/stories/1/111_BuildWebApp/#references", 
            "text": "Knowzy App GitHub Repo", 
            "title": "References"
        }, 
        {
            "location": "/stories/1/111_BuildWebApp/#continue-to-next-task", 
            "text": "", 
            "title": "Continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/", 
            "text": "Task 1.1.2 - Generate Progressive Web App\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.1.1\n and the prerequisites found there.\n\n\nTask\n\n\nBuild the Web App Manifest\n\n\nThe first step is to build the Manifest for your application using the \npwabuilder.com\n web site. The builder will search in the home page of your site looking for information about the app in specific meta tags. For more information, read \nWhat is a Manifest\n.\n\n\nProvide a URL\n\n\n\n\nOpen a browser and navigate to \nhttp://preview.pwabuilder.com\n.\n\n\nClick on the \nGet Started\n button. \n\n\n\n\nIn the URL textbox, enter the https version of your URL of your site and click on \nGet Started\n again. \n\n\n\n\nNote\n Your website URL will likely default to the http version in the browser but all azure websites also have a valid https certificate so https can be used on any azure website.\n\n\n\n\n \n\n\n\n\n\n\nGenerate Manifest\n\n\nThe builder will search in the home page of your site looking for an existing manifest. If not, it will gather information about the app in specific meta tags or propose default values for the manifest properties. It will also show any warnings or suggestions to address potential issues in the collected metadata. Be sure you address any warnings before you move on. \n\n\n \n\n\nAdd Images\n\n\nThe builder site also checks whether the manifest has defined the expected icon sizes for the different platforms (Windows, Android, iOS) and helps to generate the missing sizes. You can also generate missing image sizes for other platforms using the \nPWA Image Generator\n. \n\n\n\n\n\n\nFor our side, we don't have any image defined in the manifest so we'll proceed uploading an image with our app logo. To do this, click on the \nUpload an image\u2026\n link at the left pane. \n\n\n\n\n\n\nSave the below Knowzy logo to your PC by right clicking and \"save image as\".\n\n\n \n\n\n\n\n\n\nBrowse to the location of the image you downloaded and if you want to generate the missing sizes, make sure the \nGenerate missing images from this image\n checkbox is marked. \n\n\n\n\nNote:\n The \nUpload image\n option will generate the required image sizes for Windows 10, and suggested images for other platforms.\n\n\n\n\n \n\n\n\n\n\n\nClick \nSubmit\n. In our example, the missing image sizes are automatically generated and added to the manifest.\n\n\n \n\n\n\n\n\n\nClick \"download manifest\" to get a copy of this manifest to add to your web site (how this is done will be explained in the next step).\n\n\n\n\n\n\nChoose a Service Worker\n\n\nDuring this step you will choose functionalities you want to add to your app. The builder will include code to use sample service workers implementing those features from a repository. \nLearn more about service workers\n.\n There are a number of service workers to choose from on this page, but Knowzy is looking for a way to make sure it's field agents can access the app data when they have poor or no network connection.  For this functionality we'll choose the \"Offline copy of pages\" service worker.\n\n\n\n\n\n\nSelect the service worker you want to include in your application.\n\n\n \n\n\n\n\n\n\nDownload the service worker package, including the code for your website and the service worker code. (You can also just copy and paste the code directly from the site).  You'll be downloading two different JavaScript files.  The first is the registration code, in which you will be instructed on how to add the code to your site in the next section, and the service worker itself.  \n\n\n\n\n\n\nReferences\n\n\n\n\n\n\nWhat is a Service Worker?\n\n\n\n\n\n\nPWA Builder\n\n\n\n\n\n\nContinue to \nnext task", 
            "title": "112 GeneratePWA"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/#task-112-generate-progressive-web-app", 
            "text": "", 
            "title": "Task 1.1.2 - Generate Progressive Web App"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/#prerequisites", 
            "text": "This task has a dependency on  Task 1.1.1  and the prerequisites found there.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/#build-the-web-app-manifest", 
            "text": "The first step is to build the Manifest for your application using the  pwabuilder.com  web site. The builder will search in the home page of your site looking for information about the app in specific meta tags. For more information, read  What is a Manifest .", 
            "title": "Build the Web App Manifest"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/#provide-a-url", 
            "text": "Open a browser and navigate to  http://preview.pwabuilder.com .  Click on the  Get Started  button.    In the URL textbox, enter the https version of your URL of your site and click on  Get Started  again.    Note  Your website URL will likely default to the http version in the browser but all azure websites also have a valid https certificate so https can be used on any azure website.", 
            "title": "Provide a URL"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/#generate-manifest", 
            "text": "The builder will search in the home page of your site looking for an existing manifest. If not, it will gather information about the app in specific meta tags or propose default values for the manifest properties. It will also show any warnings or suggestions to address potential issues in the collected metadata. Be sure you address any warnings before you move on.", 
            "title": "Generate Manifest"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/#add-images", 
            "text": "The builder site also checks whether the manifest has defined the expected icon sizes for the different platforms (Windows, Android, iOS) and helps to generate the missing sizes. You can also generate missing image sizes for other platforms using the  PWA Image Generator .     For our side, we don't have any image defined in the manifest so we'll proceed uploading an image with our app logo. To do this, click on the  Upload an image\u2026  link at the left pane.     Save the below Knowzy logo to your PC by right clicking and \"save image as\".       Browse to the location of the image you downloaded and if you want to generate the missing sizes, make sure the  Generate missing images from this image  checkbox is marked.    Note:  The  Upload image  option will generate the required image sizes for Windows 10, and suggested images for other platforms.        Click  Submit . In our example, the missing image sizes are automatically generated and added to the manifest.       Click \"download manifest\" to get a copy of this manifest to add to your web site (how this is done will be explained in the next step).", 
            "title": "Add Images"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/#choose-a-service-worker", 
            "text": "During this step you will choose functionalities you want to add to your app. The builder will include code to use sample service workers implementing those features from a repository.  Learn more about service workers .  There are a number of service workers to choose from on this page, but Knowzy is looking for a way to make sure it's field agents can access the app data when they have poor or no network connection.  For this functionality we'll choose the \"Offline copy of pages\" service worker.    Select the service worker you want to include in your application.       Download the service worker package, including the code for your website and the service worker code. (You can also just copy and paste the code directly from the site).  You'll be downloading two different JavaScript files.  The first is the registration code, in which you will be instructed on how to add the code to your site in the next section, and the service worker itself.", 
            "title": "Choose a Service Worker"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/#references", 
            "text": "What is a Service Worker?    PWA Builder", 
            "title": "References"
        }, 
        {
            "location": "/stories/1/112_GeneratePWA/#continue-to-next-task", 
            "text": "", 
            "title": "Continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/1/113_ConfigureSW/", 
            "text": "Task 1.1.3 - Update your Web App with PWA features\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.1.2\n and all of it's prerequisites.\n\n\nTask\n\n\nAdd Web App Manifest to your site\n\n\nThe first thing you will need to do is pull the \"manifest.json\" file and the \"images\" folder that you obtained from the zip file in the previous step.\n\n\n\n\n\n\nAdd the manifest.json and the \"images\" folder to the root path of your site (wwwroot).  Remember, if you change the path of your \"images\" folder, you need to update the json in your manifest file to reflect your changes. The easiest way to add new content to a project is to drag and drop the contents from the file explorer into the solutions explorer of your project.\n\n\n\n\n\n\n\n\n\nReference the manifest in your page with a link tag:\n\n\nlink rel=\"manifest\" href=\"manifest.json\"\n/link\n\n\n\n\nThis can be done by opening the \nViews\\Shippings\\Index.cshtml\n page in your site, and adding the following to the top of the document:\n\n\n@section HeadExtension{ \n\nlink rel=\"manifest\" href=\"manifest.json\" /\n\n}\n\n\n\n\n\n\n\nAdd Service Worker code to your site\n\n\nYour Service Worker needs to be added to your site to begin working.  \n\n\n\n\n\n\nCopy the \"pwabuilder-sw.js\" file from the zip you downloaded on the Service Worker page of the PWA Builder website and add it to your js folder in wwwroot  (not in a folder) like so:\n\n\n\n\n\n\n\n\nOpen up the landing page of your app (index.cshtml) and create a new script tag in the head from within the same HeadExtension section like so:\n\n\n@section HeadExtension{ \n\nlink rel=\"manifest\" href=\"manifest.json\" /\n\n\nscript\n/script\n\n}\n\n\n\nYou will want to place this at the top of your document.\n\n\n\n\n\n\nAdd the following registration code inside the new script tag:\n\n\n//This is the service worker with the combined offline experience (Offline page + Offline copy of pages)\nif(navigator.serviceWorker) {\n  //Add this below content to your HTML page, or add the js file to your page at the very top to register service worker\n  if (navigator.serviceWorker.controller) {\n    console.log('[PWA Builder] active service worker found, no need to register')\n  } else {\n\n    //Register the ServiceWorker\n    navigator.serviceWorker.register('pwabuilder-sw.js', {\n      scope: './'\n    }).then(function(reg) {\n      console.log('Service worker has been registered for scope:'+ reg.scope);\n    });\n  }\n\n\n\n}\n\n\n\n\n\n\n\n\n\n\n\n\nRe-Publish Changes\n\n\nNow that you have these powerful new features running locally, you can publish them to your website to be consumed as a PWA.\n\n\n\n\n\n\nIn Visual studio choose Project \n Publish...\n\n\n\n\n\n\nChoose \"Microsoft Azure App Service\" from the selection screen.\n\n\n\n\nNOTE\n if your Visual Studio project is still debugging your Azure server or your local server, you may need to halt the server before re-publishing.\n\n\n\n\n\n\n\n\n\n\nChoose \"deploy\"\n\n\n\n\n\n\nReferences\n\n\n\n\nPWA Builder\n\n\n\n\nContinue to \nnext task", 
            "title": "113 ConfigureSW"
        }, 
        {
            "location": "/stories/1/113_ConfigureSW/#task-113-update-your-web-app-with-pwa-features", 
            "text": "", 
            "title": "Task 1.1.3 - Update your Web App with PWA features"
        }, 
        {
            "location": "/stories/1/113_ConfigureSW/#prerequisites", 
            "text": "This task has a dependency on  Task 1.1.2  and all of it's prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/1/113_ConfigureSW/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/1/113_ConfigureSW/#add-web-app-manifest-to-your-site", 
            "text": "The first thing you will need to do is pull the \"manifest.json\" file and the \"images\" folder that you obtained from the zip file in the previous step.    Add the manifest.json and the \"images\" folder to the root path of your site (wwwroot).  Remember, if you change the path of your \"images\" folder, you need to update the json in your manifest file to reflect your changes. The easiest way to add new content to a project is to drag and drop the contents from the file explorer into the solutions explorer of your project.     Reference the manifest in your page with a link tag:  link rel=\"manifest\" href=\"manifest.json\" /link   This can be done by opening the  Views\\Shippings\\Index.cshtml  page in your site, and adding the following to the top of the document:  @section HeadExtension{  link rel=\"manifest\" href=\"manifest.json\" / \n}", 
            "title": "Add Web App Manifest to your site"
        }, 
        {
            "location": "/stories/1/113_ConfigureSW/#add-service-worker-code-to-your-site", 
            "text": "Your Service Worker needs to be added to your site to begin working.      Copy the \"pwabuilder-sw.js\" file from the zip you downloaded on the Service Worker page of the PWA Builder website and add it to your js folder in wwwroot  (not in a folder) like so:     Open up the landing page of your app (index.cshtml) and create a new script tag in the head from within the same HeadExtension section like so:  @section HeadExtension{  link rel=\"manifest\" href=\"manifest.json\" /  script /script \n}  You will want to place this at the top of your document.    Add the following registration code inside the new script tag:  //This is the service worker with the combined offline experience (Offline page + Offline copy of pages)\nif(navigator.serviceWorker) {\n  //Add this below content to your HTML page, or add the js file to your page at the very top to register service worker\n  if (navigator.serviceWorker.controller) {\n    console.log('[PWA Builder] active service worker found, no need to register')\n  } else {\n\n    //Register the ServiceWorker\n    navigator.serviceWorker.register('pwabuilder-sw.js', {\n      scope: './'\n    }).then(function(reg) {\n      console.log('Service worker has been registered for scope:'+ reg.scope);\n    });\n  }  }", 
            "title": "Add Service Worker code to your site"
        }, 
        {
            "location": "/stories/1/113_ConfigureSW/#re-publish-changes", 
            "text": "Now that you have these powerful new features running locally, you can publish them to your website to be consumed as a PWA.    In Visual studio choose Project   Publish...    Choose \"Microsoft Azure App Service\" from the selection screen.   NOTE  if your Visual Studio project is still debugging your Azure server or your local server, you may need to halt the server before re-publishing.      Choose \"deploy\"", 
            "title": "Re-Publish Changes"
        }, 
        {
            "location": "/stories/1/113_ConfigureSW/#references", 
            "text": "PWA Builder", 
            "title": "References"
        }, 
        {
            "location": "/stories/1/113_ConfigureSW/#continue-to-next-task", 
            "text": "", 
            "title": "Continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/1/114_Test_App/", 
            "text": "Task 1.1.4 - Install App Locally for Testing\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.1.3\n and all of it's prerequisites.\n\n\nTask\n\n\nTest the App in Browsers\n\n\nFirst, make sure that your PWA works well in the browser.  One of the main principles of PWAs is that the app must be \"Progressive\", meaning that the app should work in any environment. Once the app is confirmed to load as a basic web site, then begin taking advantage of advanced features (such as service workers and app manifest) when they are available.  In normal circumstances, you would want to test your app in the array of browsers used by your user. To get you started, we have the newest version of Edge (with service worker support) available to you for free on BrowserStack.  \n\n\n\n\n\n\nAs of today, testing Service Workers can only be tested in public builds of the latest versions of Chrome and Firefox. To test Service Worker code, open the latest version of Chrome on your computer.\n\n\n\n\n\n\nTo test the service worker, simply visit a number of pages with the service worker attached to your app. Each page you visit will be added to the cache (don't worry the service worker will always keep itself up to date).  You can then go offline and see each of those pages still work fine without a connection.  If you are using BrowserStack and can't go offline, simply open up the F12 tooling in the browser and you can validate that the service worker is caching it's content via the console logs.\n\n\n\n\n\n\n\n\n\n\n\nNote: Service Workers are also available in latest Windows Insider builds\n\n\n\n\nInstall Windows Store PWA locally\n\n\nNext you will want to test in the local PWA environment.  To do this, we  will use more tools from PWABuilder.com.\n\n\n\n\n\n\nIn the browser, open \npreview.pwabuilder.com/generator\n.\n\n\n\n\n\n\nEnter your site URL and click \"Get Started\".  If you have your manifest properly linked to your page, you should see the data from your manifest (including images) show up in the builder.\n\n\n\n\n\n\nClick on the 3rd tab called \"Publish PWA\".  This time you will click on the \"Download\" button under \"Windows\" to get the source code.\n\n\n\n\n\n\nInside the zip, decompress it and navigate to \n\\PWA\\Store packages\\windows10\n. Right click on the \"test_install\" script and choose \"run powershell script\".\n\n\n\n\n\n\nFollow the prompts to \"side load the application\".\n\n\n\n\n\n\nOpen the app from your start screen / start menu.  You are now experiencing your PWA on Windows 10!\n\n\n\n\n\n\nF12 with Windows Store PWA\n\n\nYour app is sideloaded on your machine, which means it is in debug mode.  While PWAs are in debug mode on Windows 10, you have access to the same F12 tools you do while in the Edge browser.  With the app in the forefront on your screen, hit the \"F12\" button on your keyboard and the tools should open.\n\n\nReferences\n\n\n\n\n\n\nPWA Builder\n\n\n\n\n\n\nBrowserStack\n\n\n\n\n\n\nContinue to \nnext task", 
            "title": "114 Test App"
        }, 
        {
            "location": "/stories/1/114_Test_App/#task-114-install-app-locally-for-testing", 
            "text": "", 
            "title": "Task 1.1.4 - Install App Locally for Testing"
        }, 
        {
            "location": "/stories/1/114_Test_App/#prerequisites", 
            "text": "This task has a dependency on  Task 1.1.3  and all of it's prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/1/114_Test_App/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/1/114_Test_App/#test-the-app-in-browsers", 
            "text": "First, make sure that your PWA works well in the browser.  One of the main principles of PWAs is that the app must be \"Progressive\", meaning that the app should work in any environment. Once the app is confirmed to load as a basic web site, then begin taking advantage of advanced features (such as service workers and app manifest) when they are available.  In normal circumstances, you would want to test your app in the array of browsers used by your user. To get you started, we have the newest version of Edge (with service worker support) available to you for free on BrowserStack.      As of today, testing Service Workers can only be tested in public builds of the latest versions of Chrome and Firefox. To test Service Worker code, open the latest version of Chrome on your computer.    To test the service worker, simply visit a number of pages with the service worker attached to your app. Each page you visit will be added to the cache (don't worry the service worker will always keep itself up to date).  You can then go offline and see each of those pages still work fine without a connection.  If you are using BrowserStack and can't go offline, simply open up the F12 tooling in the browser and you can validate that the service worker is caching it's content via the console logs.      Note: Service Workers are also available in latest Windows Insider builds", 
            "title": "Test the App in Browsers"
        }, 
        {
            "location": "/stories/1/114_Test_App/#install-windows-store-pwa-locally", 
            "text": "Next you will want to test in the local PWA environment.  To do this, we  will use more tools from PWABuilder.com.    In the browser, open  preview.pwabuilder.com/generator .    Enter your site URL and click \"Get Started\".  If you have your manifest properly linked to your page, you should see the data from your manifest (including images) show up in the builder.    Click on the 3rd tab called \"Publish PWA\".  This time you will click on the \"Download\" button under \"Windows\" to get the source code.    Inside the zip, decompress it and navigate to  \\PWA\\Store packages\\windows10 . Right click on the \"test_install\" script and choose \"run powershell script\".    Follow the prompts to \"side load the application\".    Open the app from your start screen / start menu.  You are now experiencing your PWA on Windows 10!", 
            "title": "Install Windows Store PWA locally"
        }, 
        {
            "location": "/stories/1/114_Test_App/#f12-with-windows-store-pwa", 
            "text": "Your app is sideloaded on your machine, which means it is in debug mode.  While PWAs are in debug mode on Windows 10, you have access to the same F12 tools you do while in the Edge browser.  With the app in the forefront on your screen, hit the \"F12\" button on your keyboard and the tools should open.", 
            "title": "F12 with Windows Store PWA"
        }, 
        {
            "location": "/stories/1/114_Test_App/#references", 
            "text": "PWA Builder    BrowserStack", 
            "title": "References"
        }, 
        {
            "location": "/stories/1/114_Test_App/#continue-to-next-task", 
            "text": "", 
            "title": "Continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/1/121_Add_WIndows_Feature/", 
            "text": "Task 1.2.1 - Add Windows 10 feature\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.1.4\n and all of it's prerequisites.\n\n\nTask\n\n\nAdd a Windows feature to your web content.\n\n\nOne of the coolest things about PWAs on Windows 10 is the technical advantages you get over just running in the browser:\n\n\n\n\nStandalone Window\n\n\nIndependent from browser process (Less overhead / Isolated cache)\n\n\nNearly unlimited storage (indexed DB, localStorage, etc.)\n\n\nOffline \n background processes\n\n\nAccess to Windows Runtime (WinRT) APIs via JavaScript (Calendar / Cortana / Address Book / etc)\n\n\n\n\nFeature detect for Windows Store APIs\n\n\nIn order to utilize a Windows UWP API, you will want to implement a pattern called \"feature detection\".  This allows you to write JavaScript on your page that will only be executed in the context where the APIs are available.  In this case, it will only execute while inside a Windows PWA.\n\n\nFeature detection can be as simple as looking for the Windows object as below:\n\n\nif(window.Windows){\n/*execute code that calls WIndows APIs */\n}\n\n\n\n\n\nKeep in mind that not all Windows APIs are available on all Windows 10 devices.  Think about the fact that a Windows Phone has a \"dialer\" for making phone calls, so it has unique APIs that are not available on other device types.  Another example is the \"Surface Dial\" that can be paired to many Windows devices, but not the Xbox, so the \"radial dial\" APIs are not present on the Xbox.  For more specific feature detection, you will want to feature detect the API family as well like below:\n\n\n\nif(window.Windows \n Windows.UI.Core.SystemNavigationManager){\n/*execute code that calls WIndows APIs */\n}\n\n\n\n\n\nAdd code to customize your PWA App container\n\n\nStart out by adding some code that adds a message to the tile in the start menu.  This code can be run from any page, but you will likely want to place it on index.cshtml, so that it runs as soon as the app is opened. \n\n\n\n\n\n\nOpen \nShipping\\index.cshtml\n in Visual Studio and add a script tag at the bottom of the page.\n\n\n\n\n\n\nAdd the following feature detection inside the script tag:\n\n\nif(window.Windows \n Windows.UI.Notifications){\n/*execute code that calls WIndows APIs */\n}\n\n\n\n\n\n\n\nInside the feature detection, add the following code to load the live tile:\n\n\nvar tileContent = new Windows.Data.Xml.Dom.XmlDocument();\n\nvar tile = tileContent.createElement(\"tile\");\ntileContent.appendChild(tile);\n\nvar visual = tileContent.createElement(\"visual\");\ntile.appendChild(visual);\n\nvar bindingMedium = tileContent.createElement(\"binding\");\nbindingMedium.setAttribute(\"template\", \"TileMedium\");\nvisual.appendChild(bindingMedium);\n\nvar peekImage = tileContent.createElement(\"image\");\npeekImage.setAttribute(\"placement\", \"peek\");\npeekImage.setAttribute(\"src\", \"https://unsplash.it/150/150/?random\");\npeekImage.setAttribute(\"alt\", \"Welcome to Knowsie!\");\nbindingMedium.appendChild(peekImage);\n\nvar text = tileContent.createElement(\"text\");\ntext.setAttribute(\"hint-wrap\", \"true\");\ntext.innerText = \"Demo Message\";\nbindingMedium.appendChild(text);\n\n//fire the notification\n\nvar notifications = Windows.UI.Notifications;\nvar tileNotification = new notifications.TileNotification(tileContent);\nnotifications.TileUpdateManager.createTileUpdaterForApplication().update(tileNotification);\n\n\n\n\n\n\n\nTest your changes\n\n\nTo test the changes you have just made, follow the instructions in section 1.1.3 for deploying your web app, then re-deploy your changes.  One of the great things about a PWA is that you don't need to redeploy your app to see the changes, you just need to deploy to the web server.  You should be able to run your app again and see your live tile code take effect (pin your app's tile to the start menu to see).  If you don't see it immediately, it may be because of the great caching you have in your app. If this happens, you can force a cache clear by uninstalling your PWA, then installing it again from the script you downloaded from PWABuilder.com.\n\n\n\n\nNOTE\n if your Visual Studio session is still debugging your Azure instance, you may need to halt your debugger before you test locally again.\n\n\nContinue to \nnext task", 
            "title": "121 Add WIndows Feature"
        }, 
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#task-121-add-windows-10-feature", 
            "text": "", 
            "title": "Task 1.2.1 - Add Windows 10 feature"
        }, 
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#prerequisites", 
            "text": "This task has a dependency on  Task 1.1.4  and all of it's prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#add-a-windows-feature-to-your-web-content", 
            "text": "One of the coolest things about PWAs on Windows 10 is the technical advantages you get over just running in the browser:   Standalone Window  Independent from browser process (Less overhead / Isolated cache)  Nearly unlimited storage (indexed DB, localStorage, etc.)  Offline   background processes  Access to Windows Runtime (WinRT) APIs via JavaScript (Calendar / Cortana / Address Book / etc)", 
            "title": "Add a Windows feature to your web content."
        }, 
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#feature-detect-for-windows-store-apis", 
            "text": "In order to utilize a Windows UWP API, you will want to implement a pattern called \"feature detection\".  This allows you to write JavaScript on your page that will only be executed in the context where the APIs are available.  In this case, it will only execute while inside a Windows PWA.  Feature detection can be as simple as looking for the Windows object as below:  if(window.Windows){\n/*execute code that calls WIndows APIs */\n}  Keep in mind that not all Windows APIs are available on all Windows 10 devices.  Think about the fact that a Windows Phone has a \"dialer\" for making phone calls, so it has unique APIs that are not available on other device types.  Another example is the \"Surface Dial\" that can be paired to many Windows devices, but not the Xbox, so the \"radial dial\" APIs are not present on the Xbox.  For more specific feature detection, you will want to feature detect the API family as well like below:  \nif(window.Windows   Windows.UI.Core.SystemNavigationManager){\n/*execute code that calls WIndows APIs */\n}", 
            "title": "Feature detect for Windows Store APIs"
        }, 
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#add-code-to-customize-your-pwa-app-container", 
            "text": "Start out by adding some code that adds a message to the tile in the start menu.  This code can be run from any page, but you will likely want to place it on index.cshtml, so that it runs as soon as the app is opened.     Open  Shipping\\index.cshtml  in Visual Studio and add a script tag at the bottom of the page.    Add the following feature detection inside the script tag:  if(window.Windows   Windows.UI.Notifications){\n/*execute code that calls WIndows APIs */\n}    Inside the feature detection, add the following code to load the live tile:  var tileContent = new Windows.Data.Xml.Dom.XmlDocument();\n\nvar tile = tileContent.createElement(\"tile\");\ntileContent.appendChild(tile);\n\nvar visual = tileContent.createElement(\"visual\");\ntile.appendChild(visual);\n\nvar bindingMedium = tileContent.createElement(\"binding\");\nbindingMedium.setAttribute(\"template\", \"TileMedium\");\nvisual.appendChild(bindingMedium);\n\nvar peekImage = tileContent.createElement(\"image\");\npeekImage.setAttribute(\"placement\", \"peek\");\npeekImage.setAttribute(\"src\", \"https://unsplash.it/150/150/?random\");\npeekImage.setAttribute(\"alt\", \"Welcome to Knowsie!\");\nbindingMedium.appendChild(peekImage);\n\nvar text = tileContent.createElement(\"text\");\ntext.setAttribute(\"hint-wrap\", \"true\");\ntext.innerText = \"Demo Message\";\nbindingMedium.appendChild(text);\n\n//fire the notification\n\nvar notifications = Windows.UI.Notifications;\nvar tileNotification = new notifications.TileNotification(tileContent);\nnotifications.TileUpdateManager.createTileUpdaterForApplication().update(tileNotification);", 
            "title": "Add code to customize your PWA App container"
        }, 
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#test-your-changes", 
            "text": "To test the changes you have just made, follow the instructions in section 1.1.3 for deploying your web app, then re-deploy your changes.  One of the great things about a PWA is that you don't need to redeploy your app to see the changes, you just need to deploy to the web server.  You should be able to run your app again and see your live tile code take effect (pin your app's tile to the start menu to see).  If you don't see it immediately, it may be because of the great caching you have in your app. If this happens, you can force a cache clear by uninstalling your PWA, then installing it again from the script you downloaded from PWABuilder.com.   NOTE  if your Visual Studio session is still debugging your Azure instance, you may need to halt your debugger before you test locally again.", 
            "title": "Test your changes"
        }, 
        {
            "location": "/stories/1/121_Add_WIndows_Feature/#continue-to-next-task", 
            "text": "", 
            "title": "Continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/1/122_BONUS-RenoFeatures/", 
            "text": "Add Secondary Pinning and Native Share to App (1.2.2)\n\n\nThis task has a dependency on \nTask 1.2.1\n and all of it's prerequisites.\n\n\nTask\n\n\n\n\n\n\nNavigate to \nReno.js library documentation\n and follow the instructions in the README\n\n\n\n\n\n\nConfigure the features if necessary. \n\n\n\n\n\n\nRedeploy site.\n\n\n\n\n\n\nReinstall your local app (right click PowerShell script included in pwabuilder.com download).\n\n\n\n\n\n\nReferences\n\n\n\n\nProject Reno on GitHub\n\n\n\n\nContinue to \nnext task", 
            "title": "122 BONUS RenoFeatures"
        }, 
        {
            "location": "/stories/1/122_BONUS-RenoFeatures/#add-secondary-pinning-and-native-share-to-app-122", 
            "text": "This task has a dependency on  Task 1.2.1  and all of it's prerequisites.", 
            "title": "Add Secondary Pinning and Native Share to App (1.2.2)"
        }, 
        {
            "location": "/stories/1/122_BONUS-RenoFeatures/#task", 
            "text": "Navigate to  Reno.js library documentation  and follow the instructions in the README    Configure the features if necessary.     Redeploy site.    Reinstall your local app (right click PowerShell script included in pwabuilder.com download).", 
            "title": "Task"
        }, 
        {
            "location": "/stories/1/122_BONUS-RenoFeatures/#references", 
            "text": "Project Reno on GitHub", 
            "title": "References"
        }, 
        {
            "location": "/stories/1/122_BONUS-RenoFeatures/#continue-to-next-task", 
            "text": "", 
            "title": "Continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/1/123_BONUS-APP-Links/", 
            "text": "# Add App linking to PWA (1.2.3)\n\n\nThis task has a dependency on \nTask 1.2.1\n and all of it's prerequisites.\n\n\nTask\n\n\nIn this BONUS task, you want to configure your PWA to handle all requests that are send to your domain URL.  For example you should be able to create a link in a file or email that navigates to \nhttps://YOURSITENAME.azruewebsites.net/receiving\n and have that open the receiving section of your PWA, instead of your website.   This is a stretch goal. It takes a bit of manual configuration to work.\n\n\n\n\n\n\nUpdate your local manifest.json (what you downloaded from pwabuilder.com).\n\n\n\n\n\n\nAdd JSON object to web site.\n\n\n\n\n\n\nAdd activation object to website.\n\n\n\n\n\n\nRedeploy site.\n\n\n\n\n\n\nReinstall your local app.\n\n\n\n\n\n\nTip:\n Make sure your ASP.NET MVC site can serve up the windows-app-web-link file.  A simple way to do this for testing is to enable known file types to be served - modify your StartUp.cs / Configure method to look as follows:\n\n\n    app.UseStaticFiles(new StaticFileOptions()\n    {\n       ServeUnknownFileTypes = true,\n       DefaultContentType = \"text/plain\"\n    });\n\n    app.UseStaticFiles();\n\n    app.UseMvc(routes =\n\n    {\n    ...\n\n\n\nTip:\n In the generated windows10 package, you can either develop via the source\\App.jsproj project in Visual Studio, or you can use your favorite editor with the manifest\\appxmanifest.xml file and use the test_install.ps1 script to deploy. \n\n\nTip:\n Remember that Apps for Websites is a Windows 10 Anniversary Update feature.\n\n\nIf using Visual Studio, make sure your Project Properties Target version is at least \"10.0.14393\".\n\n\nIf using the appxmanifest.xml, make sure your MaxVersionTested property has a version number of at least \"10.0.14393\".\n\n\nReferences\n\n\nhttps://docs.microsoft.com/en-us/windows/uwp/launch-resume/web-to-app-linking\n \n Note code samples in c#, but manifest changes are the same \n\n\nhttps://blogs.windows.com/buildingapps/2016/03/07/hosted-web-apps-go-beyond-the-app/#JoWUjrHvp5wDFPt1.97\n \n Note this shows you how to do a javascript activation object to navigate your app to the URL that launched it \n\n\nContinue to \nnext task", 
            "title": "123 BONUS APP Links"
        }, 
        {
            "location": "/stories/1/123_BONUS-APP-Links/#task", 
            "text": "In this BONUS task, you want to configure your PWA to handle all requests that are send to your domain URL.  For example you should be able to create a link in a file or email that navigates to  https://YOURSITENAME.azruewebsites.net/receiving  and have that open the receiving section of your PWA, instead of your website.   This is a stretch goal. It takes a bit of manual configuration to work.    Update your local manifest.json (what you downloaded from pwabuilder.com).    Add JSON object to web site.    Add activation object to website.    Redeploy site.    Reinstall your local app.    Tip:  Make sure your ASP.NET MVC site can serve up the windows-app-web-link file.  A simple way to do this for testing is to enable known file types to be served - modify your StartUp.cs / Configure method to look as follows:      app.UseStaticFiles(new StaticFileOptions()\n    {\n       ServeUnknownFileTypes = true,\n       DefaultContentType = \"text/plain\"\n    });\n\n    app.UseStaticFiles();\n\n    app.UseMvc(routes = \n    {\n    ...  Tip:  In the generated windows10 package, you can either develop via the source\\App.jsproj project in Visual Studio, or you can use your favorite editor with the manifest\\appxmanifest.xml file and use the test_install.ps1 script to deploy.   Tip:  Remember that Apps for Websites is a Windows 10 Anniversary Update feature.  If using Visual Studio, make sure your Project Properties Target version is at least \"10.0.14393\".  If using the appxmanifest.xml, make sure your MaxVersionTested property has a version number of at least \"10.0.14393\".", 
            "title": "Task"
        }, 
        {
            "location": "/stories/1/123_BONUS-APP-Links/#references", 
            "text": "https://docs.microsoft.com/en-us/windows/uwp/launch-resume/web-to-app-linking    Note code samples in c#, but manifest changes are the same   https://blogs.windows.com/buildingapps/2016/03/07/hosted-web-apps-go-beyond-the-app/#JoWUjrHvp5wDFPt1.97    Note this shows you how to do a javascript activation object to navigate your app to the URL that launched it", 
            "title": "References"
        }, 
        {
            "location": "/stories/1/123_BONUS-APP-Links/#continue-to-next-task", 
            "text": "", 
            "title": "Continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/", 
            "text": "Task 1.2.4 - Add In-Memory Caching\n\n\nNow that you have a running PWA, we'd like you to improve the speed and performance of the Web App.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.2.1\n and all of it's prerequisites.\n\n\nTask\n\n\n\n\nThe website currently loads its data from static JSON files in its \nwwwroot\\Data\n folder. Speed up the performance of your website by caching values that are being used by controllers on your website. For example, after enabling caching, update the \nGenerateDropdowns\n method in \nReceivingsController.cs\n to cache the results.\n\n\nUpdate the local JSON files while you are running and notice the data does not update when you refresh.\n\n\nExperiment with different cache sliding expirations to see what happens when you use a more or less frequent expiration and change the local data.\n\n\nOnce the tasks in Section 4 are done, the site will have been updated by your team to get the data from the Shipping and Orders APIs. You can use the caching features to cache the data from the API, and include code to invalidate your cached data from the API after expiration.\n\n\n\n\nComments\n\n\n@ 3:37am\n\n\nI found \nthis guide\n that explains how in-memory caching works with ASP.NET Core.", 
            "title": "124 BONUS InMemoryCaching"
        }, 
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/#task-124-add-in-memory-caching", 
            "text": "Now that you have a running PWA, we'd like you to improve the speed and performance of the Web App.", 
            "title": "Task 1.2.4 - Add In-Memory Caching"
        }, 
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/#prerequisites", 
            "text": "This task has a dependency on  Task 1.2.1  and all of it's prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/#task", 
            "text": "The website currently loads its data from static JSON files in its  wwwroot\\Data  folder. Speed up the performance of your website by caching values that are being used by controllers on your website. For example, after enabling caching, update the  GenerateDropdowns  method in  ReceivingsController.cs  to cache the results.  Update the local JSON files while you are running and notice the data does not update when you refresh.  Experiment with different cache sliding expirations to see what happens when you use a more or less frequent expiration and change the local data.  Once the tasks in Section 4 are done, the site will have been updated by your team to get the data from the Shipping and Orders APIs. You can use the caching features to cache the data from the API, and include code to invalidate your cached data from the API after expiration.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/1/124_BONUS_InMemoryCaching/#337am", 
            "text": "I found  this guide  that explains how in-memory caching works with ASP.NET Core.", 
            "title": "@ 3:37am"
        }, 
        {
            "location": "/stories/1/NII126_cortana-Links/", 
            "text": "Task 1.2.3 - Add Cortana Voice Commands\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 1.2.1\n and all of it's prerequisites\n\n\nTask\n\n\n\n\nCreate VCD file to listen for app commands\n\n\nAdd VCD to web site\n\n\nCreate activation object to handle cortana commands\n\n\nreinstall your local app (rerun script downloaded from pwabuilder.com)\n\n\n\n\nReferences\n\n\nhttps://blogs.windows.com/buildingapps/2016/03/01/building-a-media-centric-hosted-web-app/", 
            "title": "NII126 cortana Links"
        }, 
        {
            "location": "/stories/1/NII126_cortana-Links/#task-123-add-cortana-voice-commands", 
            "text": "", 
            "title": "Task 1.2.3 - Add Cortana Voice Commands"
        }, 
        {
            "location": "/stories/1/NII126_cortana-Links/#prerequisites", 
            "text": "This task has a dependency on  Task 1.2.1  and all of it's prerequisites", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/1/NII126_cortana-Links/#task", 
            "text": "Create VCD file to listen for app commands  Add VCD to web site  Create activation object to handle cortana commands  reinstall your local app (rerun script downloaded from pwabuilder.com)", 
            "title": "Task"
        }, 
        {
            "location": "/stories/1/NII126_cortana-Links/#references", 
            "text": "https://blogs.windows.com/buildingapps/2016/03/01/building-a-media-centric-hosted-web-app/", 
            "title": "References"
        }, 
        {
            "location": "/stories/2/211_Centennial/", 
            "text": "Task 2.1.1 - Add Desktop Bridge support using Visual Studio 2017\n\n\nThis task will guide you through the process of converting an existing Win32 desktop app to a Desktop Bridge UWP app using Visual Studio 2017.\nThere are a lot of steps to correctly set up Visual Studio 2017 to build and package your Win32 app as a UWP app. Each update of Visual Studio 2017 had made this process easier.\nFuture updates to Visual Studio 2017 will most likely add Desktop Bridge project templates that will automate this process. Until then, please follow these steps carefully.\n\n\nPrerequisites\n\n\n\n\n\n\nBasic knowledge of C# development\n\n\n\n\n\n\nBasic knowledge of client development with the .NET framework\n\n\n\n\n\n\nBasic knowledge of Windows 10 and the Universal Windows Platform\n\n\n\n\n\n\nA computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, your PC must be running Windows 10 Pro or Windows 10 Enterprise (Windows 10 Home doesn't include the required Containers feature).\n\n\n\n\n\n\nVisual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition of Visual Studio 2017 is supported, including the free \nVisual Studio 2017 Community\n\n\n\n\n\n\nGo to the Git repo at \nhttps://github.com/Knowzy/KnowzyInternalApps\n and clone or download the content onto your local computer.\n\n\n\n\n\n\nTask: Add Desktop Bridge support in Visual Studio\n\n\nThis task covers the following steps: \n\n\n\n\n\n\nOpen the existing Knowzy Win32 solution with Visual Studio 2017\n\n\n\n\n\n\nAdd a UWP project and add a project dependency to the existing WPF project\n\n\n\n\n\n\nAdd the Microsoft.Knowzy.WPF binaries to the UWP project\n\n\n\n\n\n\nEdit the Microsoft.Knowzy.UWP package manifest to enable the Desktop Bridge extensions\n\n\n\n\n\n\nDeploy and run your converted Win32 App\n\n\n\n\n\n\nStep 1: Open the existing Knowzy Win32 solution with Visual Studio 2017\n\n\nWe will be converting an existing WPF application from Win32 to UWP. To get started, use Visual Studio 2017 to open \nMicrosoft.Knowzy.WPF.sln\n in the \nsrc\\Knowzy_Engineering_Win32App\n folder.\n\n\nSet the Microsoft.Knowzy.WPF project as the startup project. Press F5 to build and run the project. Feel free to try out the application and then quit the application and return to Visual Studio.\n\n\nStep 2: Add a UWP project and add a project dependency to the existing WPF project\n\n\nWe will be using an empty UWP Visual Studio project to package our WPF app into a UWP app.\n\n\nTo create a Desktop Bridge package, first add a C# Windows Universal Blank App project to the your solution.\n\n\n\n\n\n\nIn Solution Explorer, right-click the \nsrc\n folder and select \nAdd | New Project...\n\n\n\n\n\n\n\n\nIn the left pane of the \nAdd New Project\n window, select the \nVisual C# | Windows Universal | Blank App (Universal Windows)\n project template.\n\n\n\n\n\n\nIn the \nName\n box, enter \nMicrosoft.Knowzy.UWP\n.\n\n\n\n\n\n\nIn the \nLocation\n box, verify that you're saving the project to the \nKnowzy_Engineering_Win32App\\src\n folder, and then click \nOK\n.\n\n\n\n\n\n\n\n\nIn the \nNew Universal Windows Project\n window, verify that \nMinimum Version\n is set to \nWindows 10 Anniversary Update (10.0; Build 14393)\n or higher.\n\n\n\n\nNote: Desktop Bridge apps require Windows 10 SDK 14393 or higher. If you only have the Windows 10 SDK 15063 installed on    your PC, use \nWindows 10 Creators Update (10.0; Build 15063)\n for the \nMinimum Version\n. You don't need to install the Windows 10 SDK 14393 to complete these tasks.\n\n\n\n\n\n\nYour solution should now contain the following projects.\n\n\n\n\n\n\n\n\nAdd a project dependency to Microsoft.Knowzy.WPF\n\n\n\n\n\n\nIn Solution Explorer, right-click the \nMicrosoft.Knowzy.UWP (Universal Windows)\n project.\n\n\n\n\n\n\nSelect \nBuild Dependencies | Project Dependencies...\"\n\n\n\n\n\n\n\n\nIn the \nDepends on\n section of the \nProject Dependencies\n window, select the \nMicrosoft.Knowzy.WPF\n check box, and then click \nOK\n.\n\n\n\n\n\n\n\n\nPress F7 (or whatever your Build Solution shortcut key is) to build the solution.\n\n\n\n\n\n\nTo see what the empty C# UWP app looks like\n\n\n\n\n\n\nIn Solution Explorer, right-click the \nMicrosoft.Knowzy.UWP (Universal Windows)\n project and select \nDebug | Start new instance\n to run the UWP app.\n\n\n\n\n\n\nAn empty UWP app window will appear.\n\n\n\n\n\n\nClose the window to return to Visual Studio 2017.\n\n\n\n\n\n\nStep 3: Add the Microsoft.Knowzy.WPF binaries to the UWP Project\n\n\nTo convert the Microsoft.Knowzy.WPF app to a Desktop Bridge UWP app, you will need to add all the Win32 binaries created by the Microsoft.Knowzy.WPF app to the Microsoft.Knowzy.UWP app. You will copy them to a folder called \ndesktop\n (this exact name is not required; you can use any name you like), and then package them with the UWP app.\n\n\nWe will automate the Microsoft.Knowzy.WPF project to copy these files after each build, improving the development workflow. We are going to edit the project file Microsoft.Knowzy.WPF.csproj\nto include an AfterBuild target that will copy all the Win32 output files to the \ndesktop\n folder in the Microsoft.Knowzy.UWP project as follows:\n\n\nTarget Name=\"AfterBuild\"\n\n  \nPropertyGroup\n\n    \nTargetUWP\n..\\Microsoft.Knowzy.UWP\\desktop\\\n/TargetUWP\n\n  \n/PropertyGroup\n\n  \nItemGroup\n\n    \nDesktopBinaries Include=\"$(TargetDir)\\**\\*.*\" /\n\n    \nExcludeFilters Include=\"$(TargetDir)\\**\\*.winmd\" /\n\n  \n/ItemGroup\n\n  \nItemGroup\n\n    \nDesktopBinaries Include=\"$(TargetDir)\\**\\*.*\" /\n\n  \n/ItemGroup\n\n  \nItemGroup\n\n    \nDesktopBinaries Remove=\"@(ExcludeFilters)\" /\n\n  \n/ItemGroup\n\n  \nCopy SourceFiles=\"@(DesktopBinaries)\" DestinationFiles=\"@(DesktopBinaries-\n'$(TargetUWP)\\%(RecursiveDir)%(Filename)%(Extension)')\" /\n\n\n/Target\n\n\n\n\nThis rather complicated bit of XML completes several important tasks:\n\n\n\n\n\n\nThe TargetUWP line specifies where to copy the Win32 binaries. In this example, the binaries will be copied to the \ndesktop\n folder in the \nMicrosoft.Knowzy.UWP\n project folder.\n\n\n\n\n\n\nThe ExcludeFilters line specifies that any .winmd files in the \nMicrosoft.Knowzy.WPF\n output folder will not be copied to the output directory.\n\n\n\n\n\n\nThe DesktopBinaries lines specify that all of the DLL dependencies of the Microsoft.Knowzy.WPF EXE (including the ones from the NuGet packages) will be copied to the output directory.\n\n\n\n\n\n\nThe Copy SourceFiles line specifies that the directory structure will be preserved when the files are copied.\n\n\n\n\n\n\nTo automate copying the WPF binaries, edit the XML of the Microsoft.Knowzy.WPF.csproj\n\n\n\n\n\n\nIn Visual Studio, right-click the \nMicrosoft.Knowzy.WPF\n project and select \nUnload project\n.\n\n\n\n\n\n\n\n\nRight-click the \nMicrosoft.Knowzy.WPF\n project and select \nEdit Microsoft.Knowzy.WPF.csproj\n.\n\n\n\n\n\n\n\n\nScroll to the end of the XML file and paste the above XML code to the end of the file \nbefore the final project tag\n.\n\n\n\n\n\n\nSave your changes and then reload Microsoft.Knowzy.WPF.\n\n\n\n\n\n\n\n\nRebuild the solution so the Microsoft.Knowzy.WPF project binaries will be copied to the \nMicrosoft.Knowzy.UWP/desktop\n folder.\n\n\n\n\n\n\nNow that the Win32 binaries are copied to the \ndesktop\n folder in the Microsoft.Knowzy.UWP project after the build, we need to add the binaries to the UWP project so they will be packaged with the UWP app.\n\n\nWe will automate this process, similar to how we automated copying the files, as follows:\n\n\nItemGroup\n\n  \nContent Include=\"desktop\\**\\*.*\"\n\n    \nLink\ndesktop\\%(RecursiveDir)%(FileName)%(Extension)\n/Link\n\n    \nCopyToOutputDirectory\nPreserveNewest\n/CopyToOutputDirectory\n\n  \n/Content\n\n\n/ItemGroup\n\n\n\n\nThis segment of XML completes several important tasks:\n\n\n\n\n\n\nThe Content Include line specifies that all of the files in the \ndesktop\n folder will be packaged with the UWP app\n\n\n\n\n\n\nThe Link line specifies that the files will be copied to the AppX, preserving their directory structure\n\n\n\n\n\n\nTo automate adding the WPF binaries to the UWP project, edit the XML of the Microsoft.Knowzy.UWP.csproj\n\n\n\n\n\n\nIn Visual Studio, right-click the \nMicrosoft.Knowzy.UWP\n project and select \nUnload project\n.\n\n\n\n\n\n\nRight-click the \nMicrosoft.Knowzy.UWP\n project and select \nEdit Microsoft.Knowzy.UWP.csproj\n.\n\n\n\n\n\n\nScroll to the end of the XML file and paste the above XML code to the end of the file \nbefore the final project tag\n.\n\n\n\n\n\n\nSave your changes and then reload Microsoft.Knowzy.UWP.\n\n\n\n\n\n\nRebuild the solution so the Microsoft.Knowzy.WPF project binaries will be added to the UWP project and packaged with the UWP app.\n\n\n\n\n\n\nVerify that the src\\Microsoft.Knowzy.UWP folder contains a \ndesktop\n folder. If the folder is missing, close and reopen \nMicrosoft.Knowzy.WPF.sln\n.\n\n\n\n\n\n\nYou should be able to run the \nsrc\\Microsoft.Knowzy.UWP\\desktop\\Microsoft.Knowzy.WPF.exe\n app by navigating to the folder and double-clicking  \nMicrosoft.Knowzy.WPF.exe\n. This will test that all of the dependencies for Microsoft.Knowzy.WPF.exe were copied correctly to the \ndesktop\n folder.\n\n\n\n\nStep 4: Edit the Microsoft.Knowzy.UWP package manifest to enable the Desktop Bridge extensions\n\n\nThe Microsoft.Knowzy.UWP project contains a file called \nPackage.appxmanifest\n that describes how to package your UWP app and its dependencies for the Windows Store.\n\n\nThe package manifest is an XML document that contains the info the system needs to deploy, display, or update a Windows app. This info includes package identity, package dependencies, required capabilities, visual elements, and extensibility points. Every UWP app package must include one package manifest.\n\n\nWe need to edit this file so it includes the information needed to run our Win32 WPF app as a UWP app.\n\n\nTo edit the \nPackage.appxmanifest\n XML file, right-click the file in the \nMicrosoft.Knowzy.UWP\n project, and then select \nView Code\n.\n\n\n\n\nWe will now edit the XML to add the Desktop Bridge extensions. This will enable your Win32 app to run as a UWP app.\n\n\n\n\n\n\nReplace the line (near line 7):\n\n\nIgnorableNamespaces=\"uap mp\"\n\n\n\n\nwith\n\n\nxmlns:rescap=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities\"\nxmlns:desktop=\"http://schemas.microsoft.com/appx/manifest/desktop/windows10\"\nxmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"\nIgnorableNamespaces=\"uap mp rescap desktop\"\n\n\n\n\nAdding these namespaces will allow us to add the Desktop Bridge extensions to our app.\n\n\n\n\n\n\nWe need to describe to Windows 10 that our app is a Desktop Bridge app. We also need to specify a minimum version of 13493.\nReplace the line (near line 25):\n\n\nTargetDeviceFamily Name=\"Windows.Universal\" MinVersion=\"10.0.0.0\" MaxVersionTested=\"10.0.0.0\" /\n\n\n\n\nwith\n\n\nTargetDeviceFamily Name=\"Windows.Desktop\" MinVersion=\"10.0.14393.0\" MaxVersionTested=\"10.0.14393.0\" /\n\n\n\n\n\n\n\n\nWe need to tell Windows 10 that our app is a Desktop Bridge app and needs to run as a Full Trust application. This\ncapability grants Desktop app capabilities to our UWP app. Add the following capability to the Capabilities section (near line 49)\n\n\nrescap:Capability Name=\"runFullTrust\" /\n\n\n\n\n\n\n\n\nWe also need to specify that we are a Full Trust application in the Application tag. This tag also points to our WPF EXE as executable for out app.\n\n\n\n\n\n\nModify the Application tag to the following (near line 34):\n\n\nApplication Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\"\n\n\n\n\n\n\n\n\nYour package.appxmanifest should now look something like:\n\n\n?xml version=\"1.0\" encoding=\"utf-8\"?\n\n\n\nPackage\n  xmlns=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\"\n  xmlns:mp=\"http://schemas.microsoft.com/appx/2014/phone/manifest\"\n  xmlns:uap=\"http://schemas.microsoft.com/appx/manifest/uap/windows10\"\n  xmlns:rescap=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities\"\n  xmlns:desktop=\"http://schemas.microsoft.com/appx/manifest/desktop/windows10\"\n  xmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"\n  IgnorableNamespaces=\"uap mp rescap desktop\"\n\n\n  \nIdentity\n    Name=\"9aed127a-4cd4-4b87-a6a6-4b63499a73cb\"\n    Publisher=\"CN=stammen\"\n    Version=\"1.0.0.0\" /\n\n\n  \nmp:PhoneIdentity PhoneProductId=\"9aed127a-4cd4-4b87-a6a6-4b63499a73cb\" PhonePublisherId=\"00000000-0000-0000-0000-000000000000\"/\n\n\n  \nProperties\n\n    \nDisplayName\nMicrosoft.Knowzy.UWP\n/DisplayName\n\n    \nPublisherDisplayName\nstammen\n/PublisherDisplayName\n\n    \nLogo\nAssets\\StoreLogo.png\n/Logo\n\n  \n/Properties\n\n\n  \nDependencies\n\n    \nTargetDeviceFamily Name=\"Windows.Desktop\" MinVersion=\"10.0.14393.0\" MaxVersionTested=\"10.0.14393.0\" /\n\n  \n/Dependencies\n\n\n  \nResources\n\n    \nResource Language=\"x-generate\"/\n\n  \n/Resources\n\n\n  \nApplications\n\n    \nApplication Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\"\n\n      \nuap:VisualElements\n        DisplayName=\"Microsoft.Knowzy.UWP\"\n        Square150x150Logo=\"Assets\\Square150x150Logo.png\"\n        Square44x44Logo=\"Assets\\Square44x44Logo.png\"\n        Description=\"Microsoft.Knowzy.UWP\"\n        BackgroundColor=\"transparent\"\n\n        \nuap:DefaultTile Wide310x150Logo=\"Assets\\Wide310x150Logo.png\"/\n\n        \nuap:SplashScreen Image=\"Assets\\SplashScreen.png\" /\n\n      \n/uap:VisualElements\n\n    \n/Application\n\n  \n/Applications\n\n\n  \nCapabilities\n\n    \nCapability Name=\"internetClient\" /\n\n    \nrescap:Capability Name=\"runFullTrust\" /\n\n  \n/Capabilities\n\n\n/Package\n\n\n\n\n\n\nNote: Your Publisher, PublisherDisplayName, and other app id properties will be different.\n\n\n\n\nStep 5: Deploy and run your converted Win32 App\n\n\nYour converted Win32 app is now ready to be deployed and run as a UWP app on your computer.\n\n\n\n\nNote: If your Solution configuration is \nDebug | Any CPU\n, you will need to enable both the Build and Deploy setting of the Microsoft.Knowzy.UWP app using the Configuration Manager.\n\n\n\n\n\n\nMake sure that the \nBuild\n and \nDeploy\n check boxes are selected for the  Microsoft.Knowzy.UWP project.\n\n\n\n\n\n\n\n\nBuild the solution to make sure there are no errors.\n\n\n\n\n\n\nRight-click the \nMicrosoft.Knowzy.UWP\n project and select \nDeploy\n from the menu. You will most likely get the following error.\n\n\n\n\n\n\n\n\nIf you try to deploy at this point, you will see an error that says \nApplications with custom entry point executables are not supported. Check Executable attribute of the Application element in the package manifest\n:\n\n\n    1\n------ Build started: Project: Microsoft.Knowzy.UWP, Configuration: Debug x86 ------\n    1\n  Microsoft.Knowzy.UWP -\n C:\\Users\\stammen\\github\\BuildTourHack\\src\\Microsoft.Knowzy.UWP\\bin\\x86\\Debug\\Microsoft.Knowzy.UWP.exe\n    1\nC:\\Program Files (x86)\\MSBuild\\15.0\\.Net\\CoreRuntime\\Microsoft.Net.CoreRuntime.targets(236,5): error : Applications with custom entry point executables are not supported. Check Executable attribute of the Application element in the package manifest\n    ========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\n    ========== Deploy: 0 succeeded, 0 failed, 0 skipped ==========\n\n\n\nUnfortunately there is a bug in the current version of Visual Studio 2017 that prevents \nDebug\n builds of C# Desktop Bridge apps from being deployed. This bug will be fixed in a future update to Visual Studio 2017.\nUntil the bug is fixed, we will need to use the \nRelease\n configuration for our C# Desktop Bridge app. We will use the \n*Build | Configuration Manager\n to set this up.\n\n\n\n\nSelect \nConfiguration Manager\n from the \nBuild\n menu.\n\n\n\n\nFor the Microsoft.Knowzy.UWP project, set the Configuration to \nRelease\n. \nYou should also do this for the x86 and x64 Platform builds\n.\n\n\n\n\n\n\n\n\nRight-click the Microsoft.Knowzy.UWP project and select \nDeploy\n from the menu.\n\n\n2\n------ Deploy started: Project: Microsoft.Knowzy.UWP, Configuration: Release x86 ------\n2\nCreating a new clean layout...\n2\nCopying files: Total 11 mb to layout...\n2\nChecking whether required frameworks are installed...\n2\nRegistering the application to run from layout...\n2\nDeployment complete (0:00:01.818). Full package name: \"9aed127a-4cd4-4b87-a6a6-4b63499a73cb_1.0.0.0_x86__71pt5m19pd38p\"\n========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========\n========== Deploy: 1 succeeded, 0 failed, 0 skipped ==========\n\n\n\n\n\n\n\nYour Win32 WPF app has now been packaged as a UWP app using Visual Studio.\n\n\nIn the Windows Start menu, search for \nMicrosoft.Knowzy.UWP\n. If you click the UWP app in the Start menu, \nyou'll notice that it does not run\n. Actually, it did run but it exited immediately due to an error.\n\n\n\n\nThe error is the app cannot load the project.json file it needs to generate the Products list. The app then\nthrows an exception and exits.\n\n\nWe'll debug this error in a later task, but for now, let's comment out some code so that the app will run.\n\n\n\n\nIn the \nViewModels\n folder of the Microsoft.Knowzy.WPF project, open the \nMainViewModel.cs\n file.\n\n\n\n\n\n\n\n\n\n\nGo to the OnViewAttached() method at line 70 and comment out lines 72-75 statement after base.OnActivate();\n\n\nprotected override void OnViewAttached(object view, object context)\n{\n    /*\n    foreach (var item in _dataProvider.GetData())\n    {\n  DevelopmentItems.Add(new ItemViewModel(item, _eventAggregator));\n    }\n    */\n\n    base.OnViewAttached(view, context);\n}\n\n\n\n\n\n\n\nSelect \nRebuild Solution\n from the \nBuild\n menu.\n\n\n\n\n\n\nRight-click the \nMicrosoft.Knowzy.UWP\n project and select \nDeploy\n from the menu.\n\n\n\n\n\n\nIn the Windows Start menu, search for \nMicrosoft.Knowzy.UWP\n. Click \nMicrosoft.Knowzy.UWP\n to launch your app.\n\n\n\n\n\n\nThe Microsoft.Knowzy.UWP app should now run with the hacked code.\n\n\n\n\nNext Step: Debugging your Desktop Bridge app\n\n\nTo fix the error with the project.json file that causes the UWP app to crash, you need to be able to debug the various Knowzy projects. Let's try to debug the Microsoft.Knowzy.UWP project.\n\n\n\n\nRight-click the \nMicrosoft.Knowzy.UWP\n project and select \nSet as StartUp Project\n.\n\n\n\n\n\n\n\n\nPress F5 to start a debugging session for your UWP app. You will probably encounter the following error:\n\n\n\n\n\n\nWe will fix this error and enable the debugging of our app in the \nnext task\n.\n\n\nReferences\n\n\n\n\n\n\nPackage a .NET app using Visual Studio \n\n\n\n\n\n\nBridgeTour Workshop\n\n\n\n\n\n\nDevelopers Guide to the Desktop Bridge\n\n\n\n\n\n\nThe solution for this task is located \nhere\n\n\nContinue to \nnext task", 
            "title": "211 Centennial"
        }, 
        {
            "location": "/stories/2/211_Centennial/#task-211-add-desktop-bridge-support-using-visual-studio-2017", 
            "text": "This task will guide you through the process of converting an existing Win32 desktop app to a Desktop Bridge UWP app using Visual Studio 2017.\nThere are a lot of steps to correctly set up Visual Studio 2017 to build and package your Win32 app as a UWP app. Each update of Visual Studio 2017 had made this process easier.\nFuture updates to Visual Studio 2017 will most likely add Desktop Bridge project templates that will automate this process. Until then, please follow these steps carefully.", 
            "title": "Task 2.1.1 - Add Desktop Bridge support using Visual Studio 2017"
        }, 
        {
            "location": "/stories/2/211_Centennial/#prerequisites", 
            "text": "Basic knowledge of C# development    Basic knowledge of client development with the .NET framework    Basic knowledge of Windows 10 and the Universal Windows Platform    A computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, your PC must be running Windows 10 Pro or Windows 10 Enterprise (Windows 10 Home doesn't include the required Containers feature).    Visual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition of Visual Studio 2017 is supported, including the free  Visual Studio 2017 Community    Go to the Git repo at  https://github.com/Knowzy/KnowzyInternalApps  and clone or download the content onto your local computer.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/2/211_Centennial/#task-add-desktop-bridge-support-in-visual-studio", 
            "text": "This task covers the following steps:     Open the existing Knowzy Win32 solution with Visual Studio 2017    Add a UWP project and add a project dependency to the existing WPF project    Add the Microsoft.Knowzy.WPF binaries to the UWP project    Edit the Microsoft.Knowzy.UWP package manifest to enable the Desktop Bridge extensions    Deploy and run your converted Win32 App", 
            "title": "Task: Add Desktop Bridge support in Visual Studio"
        }, 
        {
            "location": "/stories/2/211_Centennial/#step-1-open-the-existing-knowzy-win32-solution-with-visual-studio-2017", 
            "text": "We will be converting an existing WPF application from Win32 to UWP. To get started, use Visual Studio 2017 to open  Microsoft.Knowzy.WPF.sln  in the  src\\Knowzy_Engineering_Win32App  folder.  Set the Microsoft.Knowzy.WPF project as the startup project. Press F5 to build and run the project. Feel free to try out the application and then quit the application and return to Visual Studio.", 
            "title": "Step 1: Open the existing Knowzy Win32 solution with Visual Studio 2017"
        }, 
        {
            "location": "/stories/2/211_Centennial/#step-2-add-a-uwp-project-and-add-a-project-dependency-to-the-existing-wpf-project", 
            "text": "We will be using an empty UWP Visual Studio project to package our WPF app into a UWP app.  To create a Desktop Bridge package, first add a C# Windows Universal Blank App project to the your solution.    In Solution Explorer, right-click the  src  folder and select  Add | New Project...     In the left pane of the  Add New Project  window, select the  Visual C# | Windows Universal | Blank App (Universal Windows)  project template.    In the  Name  box, enter  Microsoft.Knowzy.UWP .    In the  Location  box, verify that you're saving the project to the  Knowzy_Engineering_Win32App\\src  folder, and then click  OK .     In the  New Universal Windows Project  window, verify that  Minimum Version  is set to  Windows 10 Anniversary Update (10.0; Build 14393)  or higher.   Note: Desktop Bridge apps require Windows 10 SDK 14393 or higher. If you only have the Windows 10 SDK 15063 installed on    your PC, use  Windows 10 Creators Update (10.0; Build 15063)  for the  Minimum Version . You don't need to install the Windows 10 SDK 14393 to complete these tasks.    Your solution should now contain the following projects.     Add a project dependency to Microsoft.Knowzy.WPF    In Solution Explorer, right-click the  Microsoft.Knowzy.UWP (Universal Windows)  project.    Select  Build Dependencies | Project Dependencies...\"     In the  Depends on  section of the  Project Dependencies  window, select the  Microsoft.Knowzy.WPF  check box, and then click  OK .     Press F7 (or whatever your Build Solution shortcut key is) to build the solution.    To see what the empty C# UWP app looks like    In Solution Explorer, right-click the  Microsoft.Knowzy.UWP (Universal Windows)  project and select  Debug | Start new instance  to run the UWP app.    An empty UWP app window will appear.    Close the window to return to Visual Studio 2017.", 
            "title": "Step 2: Add a UWP project and add a project dependency to the existing WPF project"
        }, 
        {
            "location": "/stories/2/211_Centennial/#step-3-add-the-microsoftknowzywpf-binaries-to-the-uwp-project", 
            "text": "To convert the Microsoft.Knowzy.WPF app to a Desktop Bridge UWP app, you will need to add all the Win32 binaries created by the Microsoft.Knowzy.WPF app to the Microsoft.Knowzy.UWP app. You will copy them to a folder called  desktop  (this exact name is not required; you can use any name you like), and then package them with the UWP app.  We will automate the Microsoft.Knowzy.WPF project to copy these files after each build, improving the development workflow. We are going to edit the project file Microsoft.Knowzy.WPF.csproj\nto include an AfterBuild target that will copy all the Win32 output files to the  desktop  folder in the Microsoft.Knowzy.UWP project as follows:  Target Name=\"AfterBuild\" \n   PropertyGroup \n     TargetUWP ..\\Microsoft.Knowzy.UWP\\desktop\\ /TargetUWP \n   /PropertyGroup \n   ItemGroup \n     DesktopBinaries Include=\"$(TargetDir)\\**\\*.*\" / \n     ExcludeFilters Include=\"$(TargetDir)\\**\\*.winmd\" / \n   /ItemGroup \n   ItemGroup \n     DesktopBinaries Include=\"$(TargetDir)\\**\\*.*\" / \n   /ItemGroup \n   ItemGroup \n     DesktopBinaries Remove=\"@(ExcludeFilters)\" / \n   /ItemGroup \n   Copy SourceFiles=\"@(DesktopBinaries)\" DestinationFiles=\"@(DesktopBinaries- '$(TargetUWP)\\%(RecursiveDir)%(Filename)%(Extension)')\" /  /Target   This rather complicated bit of XML completes several important tasks:    The TargetUWP line specifies where to copy the Win32 binaries. In this example, the binaries will be copied to the  desktop  folder in the  Microsoft.Knowzy.UWP  project folder.    The ExcludeFilters line specifies that any .winmd files in the  Microsoft.Knowzy.WPF  output folder will not be copied to the output directory.    The DesktopBinaries lines specify that all of the DLL dependencies of the Microsoft.Knowzy.WPF EXE (including the ones from the NuGet packages) will be copied to the output directory.    The Copy SourceFiles line specifies that the directory structure will be preserved when the files are copied.    To automate copying the WPF binaries, edit the XML of the Microsoft.Knowzy.WPF.csproj    In Visual Studio, right-click the  Microsoft.Knowzy.WPF  project and select  Unload project .     Right-click the  Microsoft.Knowzy.WPF  project and select  Edit Microsoft.Knowzy.WPF.csproj .     Scroll to the end of the XML file and paste the above XML code to the end of the file  before the final project tag .    Save your changes and then reload Microsoft.Knowzy.WPF.     Rebuild the solution so the Microsoft.Knowzy.WPF project binaries will be copied to the  Microsoft.Knowzy.UWP/desktop  folder.    Now that the Win32 binaries are copied to the  desktop  folder in the Microsoft.Knowzy.UWP project after the build, we need to add the binaries to the UWP project so they will be packaged with the UWP app.  We will automate this process, similar to how we automated copying the files, as follows:  ItemGroup \n   Content Include=\"desktop\\**\\*.*\" \n     Link desktop\\%(RecursiveDir)%(FileName)%(Extension) /Link \n     CopyToOutputDirectory PreserveNewest /CopyToOutputDirectory \n   /Content  /ItemGroup   This segment of XML completes several important tasks:    The Content Include line specifies that all of the files in the  desktop  folder will be packaged with the UWP app    The Link line specifies that the files will be copied to the AppX, preserving their directory structure    To automate adding the WPF binaries to the UWP project, edit the XML of the Microsoft.Knowzy.UWP.csproj    In Visual Studio, right-click the  Microsoft.Knowzy.UWP  project and select  Unload project .    Right-click the  Microsoft.Knowzy.UWP  project and select  Edit Microsoft.Knowzy.UWP.csproj .    Scroll to the end of the XML file and paste the above XML code to the end of the file  before the final project tag .    Save your changes and then reload Microsoft.Knowzy.UWP.    Rebuild the solution so the Microsoft.Knowzy.WPF project binaries will be added to the UWP project and packaged with the UWP app.    Verify that the src\\Microsoft.Knowzy.UWP folder contains a  desktop  folder. If the folder is missing, close and reopen  Microsoft.Knowzy.WPF.sln .    You should be able to run the  src\\Microsoft.Knowzy.UWP\\desktop\\Microsoft.Knowzy.WPF.exe  app by navigating to the folder and double-clicking   Microsoft.Knowzy.WPF.exe . This will test that all of the dependencies for Microsoft.Knowzy.WPF.exe were copied correctly to the  desktop  folder.", 
            "title": "Step 3: Add the Microsoft.Knowzy.WPF binaries to the UWP Project"
        }, 
        {
            "location": "/stories/2/211_Centennial/#step-4-edit-the-microsoftknowzyuwp-package-manifest-to-enable-the-desktop-bridge-extensions", 
            "text": "The Microsoft.Knowzy.UWP project contains a file called  Package.appxmanifest  that describes how to package your UWP app and its dependencies for the Windows Store.  The package manifest is an XML document that contains the info the system needs to deploy, display, or update a Windows app. This info includes package identity, package dependencies, required capabilities, visual elements, and extensibility points. Every UWP app package must include one package manifest.  We need to edit this file so it includes the information needed to run our Win32 WPF app as a UWP app.  To edit the  Package.appxmanifest  XML file, right-click the file in the  Microsoft.Knowzy.UWP  project, and then select  View Code .   We will now edit the XML to add the Desktop Bridge extensions. This will enable your Win32 app to run as a UWP app.    Replace the line (near line 7):  IgnorableNamespaces=\"uap mp\"   with  xmlns:rescap=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities\"\nxmlns:desktop=\"http://schemas.microsoft.com/appx/manifest/desktop/windows10\"\nxmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"\nIgnorableNamespaces=\"uap mp rescap desktop\"   Adding these namespaces will allow us to add the Desktop Bridge extensions to our app.    We need to describe to Windows 10 that our app is a Desktop Bridge app. We also need to specify a minimum version of 13493.\nReplace the line (near line 25):  TargetDeviceFamily Name=\"Windows.Universal\" MinVersion=\"10.0.0.0\" MaxVersionTested=\"10.0.0.0\" /   with  TargetDeviceFamily Name=\"Windows.Desktop\" MinVersion=\"10.0.14393.0\" MaxVersionTested=\"10.0.14393.0\" /     We need to tell Windows 10 that our app is a Desktop Bridge app and needs to run as a Full Trust application. This\ncapability grants Desktop app capabilities to our UWP app. Add the following capability to the Capabilities section (near line 49)  rescap:Capability Name=\"runFullTrust\" /     We also need to specify that we are a Full Trust application in the Application tag. This tag also points to our WPF EXE as executable for out app.    Modify the Application tag to the following (near line 34):  Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\"     Your package.appxmanifest should now look something like:  ?xml version=\"1.0\" encoding=\"utf-8\"?  Package\n  xmlns=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10\"\n  xmlns:mp=\"http://schemas.microsoft.com/appx/2014/phone/manifest\"\n  xmlns:uap=\"http://schemas.microsoft.com/appx/manifest/uap/windows10\"\n  xmlns:rescap=\"http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities\"\n  xmlns:desktop=\"http://schemas.microsoft.com/appx/manifest/desktop/windows10\"\n  xmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"\n  IgnorableNamespaces=\"uap mp rescap desktop\" \n\n   Identity\n    Name=\"9aed127a-4cd4-4b87-a6a6-4b63499a73cb\"\n    Publisher=\"CN=stammen\"\n    Version=\"1.0.0.0\" / \n\n   mp:PhoneIdentity PhoneProductId=\"9aed127a-4cd4-4b87-a6a6-4b63499a73cb\" PhonePublisherId=\"00000000-0000-0000-0000-000000000000\"/ \n\n   Properties \n     DisplayName Microsoft.Knowzy.UWP /DisplayName \n     PublisherDisplayName stammen /PublisherDisplayName \n     Logo Assets\\StoreLogo.png /Logo \n   /Properties \n\n   Dependencies \n     TargetDeviceFamily Name=\"Windows.Desktop\" MinVersion=\"10.0.14393.0\" MaxVersionTested=\"10.0.14393.0\" / \n   /Dependencies \n\n   Resources \n     Resource Language=\"x-generate\"/ \n   /Resources \n\n   Applications \n     Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\" \n       uap:VisualElements\n        DisplayName=\"Microsoft.Knowzy.UWP\"\n        Square150x150Logo=\"Assets\\Square150x150Logo.png\"\n        Square44x44Logo=\"Assets\\Square44x44Logo.png\"\n        Description=\"Microsoft.Knowzy.UWP\"\n        BackgroundColor=\"transparent\" \n         uap:DefaultTile Wide310x150Logo=\"Assets\\Wide310x150Logo.png\"/ \n         uap:SplashScreen Image=\"Assets\\SplashScreen.png\" / \n       /uap:VisualElements \n     /Application \n   /Applications \n\n   Capabilities \n     Capability Name=\"internetClient\" / \n     rescap:Capability Name=\"runFullTrust\" / \n   /Capabilities  /Package    Note: Your Publisher, PublisherDisplayName, and other app id properties will be different.", 
            "title": "Step 4: Edit the Microsoft.Knowzy.UWP package manifest to enable the Desktop Bridge extensions"
        }, 
        {
            "location": "/stories/2/211_Centennial/#step-5-deploy-and-run-your-converted-win32-app", 
            "text": "Your converted Win32 app is now ready to be deployed and run as a UWP app on your computer.   Note: If your Solution configuration is  Debug | Any CPU , you will need to enable both the Build and Deploy setting of the Microsoft.Knowzy.UWP app using the Configuration Manager.    Make sure that the  Build  and  Deploy  check boxes are selected for the  Microsoft.Knowzy.UWP project.     Build the solution to make sure there are no errors.    Right-click the  Microsoft.Knowzy.UWP  project and select  Deploy  from the menu. You will most likely get the following error.     If you try to deploy at this point, you will see an error that says  Applications with custom entry point executables are not supported. Check Executable attribute of the Application element in the package manifest :      1 ------ Build started: Project: Microsoft.Knowzy.UWP, Configuration: Debug x86 ------\n    1   Microsoft.Knowzy.UWP -  C:\\Users\\stammen\\github\\BuildTourHack\\src\\Microsoft.Knowzy.UWP\\bin\\x86\\Debug\\Microsoft.Knowzy.UWP.exe\n    1 C:\\Program Files (x86)\\MSBuild\\15.0\\.Net\\CoreRuntime\\Microsoft.Net.CoreRuntime.targets(236,5): error : Applications with custom entry point executables are not supported. Check Executable attribute of the Application element in the package manifest\n    ========== Build: 0 succeeded, 1 failed, 0 up-to-date, 0 skipped ==========\n    ========== Deploy: 0 succeeded, 0 failed, 0 skipped ==========  Unfortunately there is a bug in the current version of Visual Studio 2017 that prevents  Debug  builds of C# Desktop Bridge apps from being deployed. This bug will be fixed in a future update to Visual Studio 2017.\nUntil the bug is fixed, we will need to use the  Release  configuration for our C# Desktop Bridge app. We will use the  *Build | Configuration Manager  to set this up.   Select  Configuration Manager  from the  Build  menu.   For the Microsoft.Knowzy.UWP project, set the Configuration to  Release .  You should also do this for the x86 and x64 Platform builds .     Right-click the Microsoft.Knowzy.UWP project and select  Deploy  from the menu.  2 ------ Deploy started: Project: Microsoft.Knowzy.UWP, Configuration: Release x86 ------\n2 Creating a new clean layout...\n2 Copying files: Total 11 mb to layout...\n2 Checking whether required frameworks are installed...\n2 Registering the application to run from layout...\n2 Deployment complete (0:00:01.818). Full package name: \"9aed127a-4cd4-4b87-a6a6-4b63499a73cb_1.0.0.0_x86__71pt5m19pd38p\"\n========== Build: 1 succeeded, 0 failed, 0 up-to-date, 0 skipped ==========\n========== Deploy: 1 succeeded, 0 failed, 0 skipped ==========    Your Win32 WPF app has now been packaged as a UWP app using Visual Studio.  In the Windows Start menu, search for  Microsoft.Knowzy.UWP . If you click the UWP app in the Start menu,  you'll notice that it does not run . Actually, it did run but it exited immediately due to an error.   The error is the app cannot load the project.json file it needs to generate the Products list. The app then\nthrows an exception and exits.  We'll debug this error in a later task, but for now, let's comment out some code so that the app will run.   In the  ViewModels  folder of the Microsoft.Knowzy.WPF project, open the  MainViewModel.cs  file.      Go to the OnViewAttached() method at line 70 and comment out lines 72-75 statement after base.OnActivate();  protected override void OnViewAttached(object view, object context)\n{\n    /*\n    foreach (var item in _dataProvider.GetData())\n    {\n  DevelopmentItems.Add(new ItemViewModel(item, _eventAggregator));\n    }\n    */\n\n    base.OnViewAttached(view, context);\n}    Select  Rebuild Solution  from the  Build  menu.    Right-click the  Microsoft.Knowzy.UWP  project and select  Deploy  from the menu.    In the Windows Start menu, search for  Microsoft.Knowzy.UWP . Click  Microsoft.Knowzy.UWP  to launch your app.    The Microsoft.Knowzy.UWP app should now run with the hacked code.", 
            "title": "Step 5: Deploy and run your converted Win32 App"
        }, 
        {
            "location": "/stories/2/211_Centennial/#next-step-debugging-your-desktop-bridge-app", 
            "text": "To fix the error with the project.json file that causes the UWP app to crash, you need to be able to debug the various Knowzy projects. Let's try to debug the Microsoft.Knowzy.UWP project.   Right-click the  Microsoft.Knowzy.UWP  project and select  Set as StartUp Project .     Press F5 to start a debugging session for your UWP app. You will probably encounter the following error:    We will fix this error and enable the debugging of our app in the  next task .", 
            "title": "Next Step: Debugging your Desktop Bridge app"
        }, 
        {
            "location": "/stories/2/211_Centennial/#references", 
            "text": "Package a .NET app using Visual Studio     BridgeTour Workshop    Developers Guide to the Desktop Bridge", 
            "title": "References"
        }, 
        {
            "location": "/stories/2/211_Centennial/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/2/211_Centennial/#continue-to-next-task", 
            "text": "", 
            "title": "Continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/2/212_Debugging/", 
            "text": "Task 2.1.2 - Debugging a Windows Desktop Bridge App\n\n\nThis task will guide you through the process of debugging a Windows Desktop Bridge App using Visual Studio 2017. \n\n\nPrerequisites\n\n\n\n\n\n\nBasic knowledge of C# development\n\n\n\n\n\n\nBasic knowledge of client development with the .NET framework\n\n\n\n\n\n\nBasic knowledge of Windows 10 and the Universal Windows Platform\n\n\n\n\n\n\nA computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.\n\n\n\n\n\n\nVisual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free \nVisual Studio 2017 Community\n\n\n\n\n\n\nThe \nDesktop Bridge Debugging Project template\n installed into Visual Studio 2017\n\n\n\n\n\n\nComplete the section on \nAdd Desktop Bridge Support using Visual Studio 2017\n\n\n\n\n\n\nTo get started, please open the \nMicrosoft.Knowzy.WPF.sln\n in the \nsrc\\Knowzy_Engineering_Win32App\n folder with Visual Studio 2017.\n\n\nThis task covers the following steps: \n1. Install the Desktop Bridge Debugging Project Extension\n\n\n\n\n\n\nAdd a Desktop Bridge Debugging project and add project dependencies to the existing WPF and UWP projects\n\n\n\n\n\n\nConfigure the Debugging Project to enable F5 builds and deployment of the Knowzy app\n\n\n\n\n\n\nEnable breakpoints in projects\n\n\n\n\n\n\nStep 1: Install the Desktop Bridge Debugging Project Extension\n\n\nIf you do not have the Desktop Bridge Debugging Project extension installed into Visual Studio 2017, please complete the following steps:\n\n\n\n\n\n\nClick on the \nTools\n menu and select \nExtensions and Updates...\n\n\n\n\n\n\n\n\nSelect \nOnline\n and enter \nDesktop Bridge Debugging Project\n in the search field. Click \nDownload\n.\n\n\n\n\n\n\n\n\nClose Visual Studio 2017 and the Desktop Bridge Debugging Project Extension will be installed.\n\n\n\n\n\n\nReopen your Desktop Bridge solution from the \nAdd Centennial Support using Visual Studio 2017\n task.\n\n\n\n\n\n\nStep 2: Add the Desktop Bridge Debugging Project to the Solution\n\n\n\n\n\n\nRight-click on the src folder in the Solution and select \nAdd | New Project...\n\n\n\n\n\n\n\n\nSelect the \nOther Project Types | Desktop Bridge Debugging Project\n project template. \n\n\n\n\n\n\n\n\nName the project Microsoft.Knowzy.Debug.\n\n\n\n\n\n\nMake sure you save the project to the \nKnowzy_Engineering_Win32App\\src\n folder.\n\n\n\n\n\n\nYou solution should now contain the following projects.\n\n\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.Debug project and select \nBuild Dependencies | Project Dependencies...\"\n\n\n\n\n\n\nSelect the Microsoft.Knowzy.WPF and Microsoft.Knowzy.UWP projects and click \nOK\n.\n\n\n\n\n\n\nStep 3: Configure the Desktop Bridge Debugging Project\n\n\nSince we will be working a lot with the Microsoft.Knowzy.UWP project, set the Build Configuration and Platform to \nDebug | x86\n\n\n\n\nClean\n the solution by selecting \nClean Solution\n from the \nBuild\n menu.\n\n\nBuild\n the x86 configuration of the solution. (Select \nBuild Solution\n from the \nBuild\n menu).\n\n\nAfter the build completes, deploy the Microsoft.Knowzy.UWP project so its AppX folder is created. The next step needs the AppX folder.\n(Select \nDeploy Solution\n from the \nBuild\n menu).\n\n\nRight-click on the Microsoft.Knowzy.Debug project and select \nSet as Startup Project\n. \n\n\n\n\nRight-click on the Microsoft.Knowzy.Debug project and select \nProperties\n. \n\n\nFor Debug builds use the following settings:\n\n\n\n\n\n\nPackage Layout: ..\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\n\n\n\n\n\n\nSelect Uninstall and then re-install my package.\n\n\n\n\n\n\nFrom the \nPackage Layout\n field tab to the \nStart Up Tile\n field and select Microsoft.Knowzy.WPF.\n\n\n\n\n\n\nNotice that we are specifying the path to the \nRelease\n build of the Microsoft.Knowzy.UWP project. This is a fix for the\nVisual 2017 C# UWP Desktop Bridge deployment bug we experienced in the previous task.\n\n\n\n\n\n\n\n\nSave and Close the Properties windows. \n\n\n\n\nNote:\n The Properties window can be a little buggy in saving your settings so make sure they were saved. Most issues with debugging are caused by\nincorrect Debugging Project settings.\n\n\nNote:\n You will need to add the correct Debugging Project Properties for x86 Release and x64 Debug and Release configurations if you want to build them.\n\n\n\n\n\n\n\n\nOpen the AppXPackageFileList.xml file in the Microsoft.Knowzy.Debug project\n\n\n\n\n\n\n\n\nModify the xml to the following:\n\n\n?xml version=\"1.0\" encoding=\"utf-8\"?\n\n\nProject ToolsVersion=\"14.0\"\n        xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"\n\n  \nPropertyGroup\n\n    \nMyProjectOutputPath\n..\\..\\bin\\Debug\n/MyProjectOutputPath\n\n  \n/PropertyGroup\n\n  \nItemGroup\n\n    \nLayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.WPF.exe\"\n\n      \nPackagePath\n$(PackageLayout)\\desktop\\Microsoft.Knowzy.WPF.exe\n/PackagePath\n\n    \n/LayoutFile\n\n  \n/ItemGroup\n\n\n/Project\n\n\n\n\n\n\n\n\nThis XML describes to the DesktopBridge Debugging project the location of the Microsoft.Knowzy.WPF.exe after it is built. It will use it when the project is launched and copy it to the correct location in the AppX package.\nThis will allow for any changes to the Microsoft.Knowzy.WPF project code to be included in the debugging session. The need for the Desktop Bridge Debugging project will most likely change in future updates to Visual Studio 2017.\n\n\n\n\n\n\nSave your changes. \n\n\n\n\n\n\nNow it is time to \nClean\n the solution and then \nBuild\n the Solution.\n\n\n\n\n\n\nIf you get a Build error stating the layout file could not be found you may need to manually deploy the Microsoft.Knowzy.UWP project by right-clicking on the Microsoft.Knowzy.UWP project and selecting \nDeploy\n. \nThen build the solution again.\n\n\n\n\n\n\nPress F5 and your UWP app will now be deployed and launch successfully. You should now be able to set breakpoints in the Microsoft.Knowzy.WPF source code.\n\n\n\n\nNote:\n There is a intermitent bug in the Desktop Bridge Debugging Project ** where it may hang when deploying a build. If this happens, use the Task Manager to kill Visual Studio and then reopen then solution. \nYou should then be able to build and run the app.\n\n\n\n\n\n\n\n\n\n\nSet a breakpoint at line 79 in the file ViewModels\\MainViewModel.cs in the Microsoft.Knowzy.WPF project. Restart the debugging session and it should break into the debugger at line 79. If you do not hit the breakpoint, \n\nClean\n and \nBuild\n your solution again.\n\n\n\n\n\n\nStop debugging and remove the comments we added in the previous task. Press F5 to start the app. You should get the following exception:\n\n\n\n\n\n\n\n\nFor some reason, our UWP app is unable to load the Project.json file and it appears that our app is looking for the file in the wrong directory. This is a common problem with newly converted Desktop Bridge apps.\nDepending on how the code is written, the app may be trying to load files from the wrong location. We will fix this in the next task.\n\n\nStep 4: Additional Debugging Settings\n\n\nIn order to be able to easily debug both both the WPF and UWP portions of our app, we need to specify a few more debugging settings.\n\n\n\n\n\n\nSelect \nOptions...\n from the \nDebug\n menu.\n\n\n\n\n\n\n\n\nClick on \nDebugging | General\n and turn off the \nEnable Just My Code\n options\n\n\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.UWP project and select \nProperties\n.\n\n\n\n\n\n\nSelect the \nBuild\n tab and turn off \nOptimize Code\n\n\n\n\n\n\n\n\nSelect the \nDebug\n tab and turn on \nDo not launch, but debug my code when it starts\n\n\n\n\n\n\n\n\nWe will now fix the products.json issue in the \nnext task\n.\n\n\nReferences\n\n\n\n\n\n\nRun, debug, and test a packaged desktop app (Desktop Bridge)\n\n\n\n\n\n\nDesktopBridge To UWP Samples\n\n\n\n\n\n\nPackage a .NET app using Visual Studio \n\n\n\n\n\n\nBridgeTour Workshop\n\n\n\n\n\n\nDevelopers Guide to the Desktop Bridge\n\n\n\n\n\n\nThe solution for this task is located \nhere\n\n\ncontinue to \nnext task", 
            "title": "212 Debugging"
        }, 
        {
            "location": "/stories/2/212_Debugging/#task-212-debugging-a-windows-desktop-bridge-app", 
            "text": "This task will guide you through the process of debugging a Windows Desktop Bridge App using Visual Studio 2017.", 
            "title": "Task 2.1.2 - Debugging a Windows Desktop Bridge App"
        }, 
        {
            "location": "/stories/2/212_Debugging/#prerequisites", 
            "text": "Basic knowledge of C# development    Basic knowledge of client development with the .NET framework    Basic knowledge of Windows 10 and the Universal Windows Platform    A computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.    Visual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free  Visual Studio 2017 Community    The  Desktop Bridge Debugging Project template  installed into Visual Studio 2017    Complete the section on  Add Desktop Bridge Support using Visual Studio 2017    To get started, please open the  Microsoft.Knowzy.WPF.sln  in the  src\\Knowzy_Engineering_Win32App  folder with Visual Studio 2017.  This task covers the following steps: \n1. Install the Desktop Bridge Debugging Project Extension    Add a Desktop Bridge Debugging project and add project dependencies to the existing WPF and UWP projects    Configure the Debugging Project to enable F5 builds and deployment of the Knowzy app    Enable breakpoints in projects", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/2/212_Debugging/#step-1-install-the-desktop-bridge-debugging-project-extension", 
            "text": "If you do not have the Desktop Bridge Debugging Project extension installed into Visual Studio 2017, please complete the following steps:    Click on the  Tools  menu and select  Extensions and Updates...     Select  Online  and enter  Desktop Bridge Debugging Project  in the search field. Click  Download .     Close Visual Studio 2017 and the Desktop Bridge Debugging Project Extension will be installed.    Reopen your Desktop Bridge solution from the  Add Centennial Support using Visual Studio 2017  task.", 
            "title": "Step 1: Install the Desktop Bridge Debugging Project Extension"
        }, 
        {
            "location": "/stories/2/212_Debugging/#step-2-add-the-desktop-bridge-debugging-project-to-the-solution", 
            "text": "Right-click on the src folder in the Solution and select  Add | New Project...     Select the  Other Project Types | Desktop Bridge Debugging Project  project template.      Name the project Microsoft.Knowzy.Debug.    Make sure you save the project to the  Knowzy_Engineering_Win32App\\src  folder.    You solution should now contain the following projects.     Right-click on the Microsoft.Knowzy.Debug project and select  Build Dependencies | Project Dependencies...\"    Select the Microsoft.Knowzy.WPF and Microsoft.Knowzy.UWP projects and click  OK .", 
            "title": "Step 2: Add the Desktop Bridge Debugging Project to the Solution"
        }, 
        {
            "location": "/stories/2/212_Debugging/#step-3-configure-the-desktop-bridge-debugging-project", 
            "text": "Since we will be working a lot with the Microsoft.Knowzy.UWP project, set the Build Configuration and Platform to  Debug | x86   Clean  the solution by selecting  Clean Solution  from the  Build  menu.  Build  the x86 configuration of the solution. (Select  Build Solution  from the  Build  menu).  After the build completes, deploy the Microsoft.Knowzy.UWP project so its AppX folder is created. The next step needs the AppX folder.\n(Select  Deploy Solution  from the  Build  menu).  Right-click on the Microsoft.Knowzy.Debug project and select  Set as Startup Project .    Right-click on the Microsoft.Knowzy.Debug project and select  Properties .   For Debug builds use the following settings:    Package Layout: ..\\Microsoft.Knowzy.UWP\\bin\\x86\\Release    Select Uninstall and then re-install my package.    From the  Package Layout  field tab to the  Start Up Tile  field and select Microsoft.Knowzy.WPF.    Notice that we are specifying the path to the  Release  build of the Microsoft.Knowzy.UWP project. This is a fix for the\nVisual 2017 C# UWP Desktop Bridge deployment bug we experienced in the previous task.     Save and Close the Properties windows.    Note:  The Properties window can be a little buggy in saving your settings so make sure they were saved. Most issues with debugging are caused by\nincorrect Debugging Project settings.  Note:  You will need to add the correct Debugging Project Properties for x86 Release and x64 Debug and Release configurations if you want to build them.     Open the AppXPackageFileList.xml file in the Microsoft.Knowzy.Debug project     Modify the xml to the following:  ?xml version=\"1.0\" encoding=\"utf-8\"?  Project ToolsVersion=\"14.0\"\n        xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\" \n   PropertyGroup \n     MyProjectOutputPath ..\\..\\bin\\Debug /MyProjectOutputPath \n   /PropertyGroup \n   ItemGroup \n     LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.WPF.exe\" \n       PackagePath $(PackageLayout)\\desktop\\Microsoft.Knowzy.WPF.exe /PackagePath \n     /LayoutFile \n   /ItemGroup  /Project     This XML describes to the DesktopBridge Debugging project the location of the Microsoft.Knowzy.WPF.exe after it is built. It will use it when the project is launched and copy it to the correct location in the AppX package.\nThis will allow for any changes to the Microsoft.Knowzy.WPF project code to be included in the debugging session. The need for the Desktop Bridge Debugging project will most likely change in future updates to Visual Studio 2017.    Save your changes.     Now it is time to  Clean  the solution and then  Build  the Solution.    If you get a Build error stating the layout file could not be found you may need to manually deploy the Microsoft.Knowzy.UWP project by right-clicking on the Microsoft.Knowzy.UWP project and selecting  Deploy . \nThen build the solution again.    Press F5 and your UWP app will now be deployed and launch successfully. You should now be able to set breakpoints in the Microsoft.Knowzy.WPF source code.   Note:  There is a intermitent bug in the Desktop Bridge Debugging Project ** where it may hang when deploying a build. If this happens, use the Task Manager to kill Visual Studio and then reopen then solution. \nYou should then be able to build and run the app.      Set a breakpoint at line 79 in the file ViewModels\\MainViewModel.cs in the Microsoft.Knowzy.WPF project. Restart the debugging session and it should break into the debugger at line 79. If you do not hit the breakpoint,  Clean  and  Build  your solution again.    Stop debugging and remove the comments we added in the previous task. Press F5 to start the app. You should get the following exception:     For some reason, our UWP app is unable to load the Project.json file and it appears that our app is looking for the file in the wrong directory. This is a common problem with newly converted Desktop Bridge apps.\nDepending on how the code is written, the app may be trying to load files from the wrong location. We will fix this in the next task.  Step 4: Additional Debugging Settings  In order to be able to easily debug both both the WPF and UWP portions of our app, we need to specify a few more debugging settings.    Select  Options...  from the  Debug  menu.     Click on  Debugging | General  and turn off the  Enable Just My Code  options     Right-click on the Microsoft.Knowzy.UWP project and select  Properties .    Select the  Build  tab and turn off  Optimize Code     Select the  Debug  tab and turn on  Do not launch, but debug my code when it starts     We will now fix the products.json issue in the  next task .", 
            "title": "Step 3: Configure the Desktop Bridge Debugging Project"
        }, 
        {
            "location": "/stories/2/212_Debugging/#references", 
            "text": "Run, debug, and test a packaged desktop app (Desktop Bridge)    DesktopBridge To UWP Samples    Package a .NET app using Visual Studio     BridgeTour Workshop    Developers Guide to the Desktop Bridge", 
            "title": "References"
        }, 
        {
            "location": "/stories/2/212_Debugging/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/2/212_Debugging/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/2/213_AddUwp/", 
            "text": "Task 2.1.3 - Adding Windows 10 UWP APIs to your Desktop Bridge App\n\n\nThis task will guide you through the process of adding Windows 10 UWP APIs to your Desktop Bridge app. \n\n\nPrerequisites\n\n\n\n\n\n\nBasic knowledge of C# development\n\n\n\n\n\n\nBasic knowledge of client development with the .NET framework\n\n\n\n\n\n\nBasic knowledge of Windows 10 and the Universal Windows Platform\n\n\n\n\n\n\nA computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.\n\n\n\n\n\n\nVisual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free \nVisual Studio 2017 Community\n\n\n\n\n\n\nComplete the section on \nDebugging a Windows Desktop Bridge App\n\n\n\n\n\n\nTo get started, please open the \nMicrosoft.Knowzy.WPF.sln\n in the \nsrc\\Knowzy_Engineering_Win32App\n folder with Visual Studio 2017.\n\n\n\n\nNote: If you are starting with this from the \n2.1.2\n solution, you will need to do the following:\n\n\n\n\n\n\n\n\nSet the Build configuration to \nDebug | x86\n\n\n\n\n\n\n\n\nSelect \nOptions\n from the \nDebug\n menu, From the \nDebugging | General\n Tab,  disable the \nEnable Just My Code\n option.\n\n\n\n\n\n\n\n\nSet the \nMicrosoft.Knowzy.Debug\n project as the startup project.\n\n\n\n\n\n\nVerify these settings before you continue with this task.\n\n\nTask\n\n\nIn this task we will do the following:\n\n\n\n\n\n\nConfigure our Desktop Bridge projects to be able to use Windows 10 UWP APIs.\n\n\n\n\n\n\nFix the issue from the previous tasks where the Desktop Bridge app was not able to load the Product.json file when running as a UWP app.\n\n\n\n\n\n\nIn the previous tasks we discovered that our Desktop Bridge version of the Knowzy app cannot find the required file Products.json. The UWP version is looking for Products.json in the location expected by the \nWPF version. We need to correct this code so that when the UWP version of Knowzy is running it will look for the file in the correct location.\n\n\n\n\n\n\nSearching the code for Products.json we find it in a file called Config.json. \n\n\n{\n\"JsonFilePath\": \"Products.json\",\n\"DataSourceUrl\": \"http://\"\n}\n\n\n\n\n\n\n\nSearching for JsonFilePath, we find it in src\\Microsoft.KnowzyJsonDataProvider\\JsonDataProvider.cs\n\n\npublic Product[] GetData()\n{\n    var jsonFilePath = _configuration.Configuration.JsonFilePath;\n    return _jsonHelper.Deserialize\nProduct[]\n(_fileHelper.ReadTextFile(jsonFilePath));\n}\n\n\n\n\n\n\n\nSetting a breakpoint around line 40 of JsonDataProvider.cs and stepping through the code we eventually find that ReadTextFile is looking for the Products.json file in the installed directory of the app.\n\n\n\n\n\n\nWhen we created the Desktop Bridge version of Knowzy we copied all of the WPF Knowzy binaries to the desktop folder of the Desktop Bridge app. \nAfter a build and deployment of the Knowzy app, we will find the Products.json file in the directory\n\n\nsrc\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX\\desktop\n\n\n\n\nSo an easy fix would be to try something like:\n\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if(IsRunningAsUwp())\n    {\n        jsonFilePath = \"desktop\\\\\" + _configuration.Configuration.JsonFilePath;\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize\nProduct[]\n(_fileHelper.ReadTextFile(jsonFilePath));\n}\n\n\n\nI'll save you some time and tell you that this won't work either. \n\n\n\n\nWe actually need to do something like this:\n\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if(IsRunningAsUwp())\n    {\n        jsonFilePath = Path.Combine(GetUWPAppDir(),\"desktop\", _configuration.Configuration.JsonFilePath);\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize\nProduct[]\n(_fileHelper.ReadTextFile(jsonFilePath));\n}\n\n\n\nWe are going to need to add at least 2 UWP methods to our DeskTop Bridge version of Knowzy in order to be able to load the Products.json file.\n\n\n\n\n\n\nA method to detect if we are running the UWP version\n\n\n\n\n\n\nA method that returns the directory of the UWP application\n\n\n\n\n\n\nStep 1: Adding UWP support to the Knowzy App\n\n\nWe can add UWP APIs to our Knowzy app at any location we need the UWP code. However, it will be easier if we create a set of UWP helper classes and place then all in a single C# library. \n\n\nSince all of the other dependencies in the Knowzy WPF solution are Windows Classic Desktop C# Class Libraries, we will add a new C# Class library called Microsoft.Knowzy.UwpHelpers.\n\n\n\n\n\n\nRight-click on the src folder in the solution and select \nAdd | New Project...\n\n\n\n\n\n\nSelect the \nVisual C# | Windows Classic Desktop | Class Library\n project template.\n\n\n\n\n\n\nName the library Microsoft.Knowzy.UwpHelpers. Make sure you are saving the project to the \nsrc\n directory.\n\n\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.UwpHelpers project and select \nAdd\n and then \nReference...\n\n\n\n\n\n\n\n\nOn the left of the Reference Manager, choose \nBrowse\n and click the \nBrowse\n button.\n\n\n\n\n\n\n\n\nFind the following file: \n\"C:\\Program Files (x86)\\Windows Kits\\10\\UnionMetadata\\10.0.15063.0\\Windows.winmd\"\n.  Add it to your project as a reference. Note: You will need to change the filter to \u201cAll Files\u201d to see this file.\n\n\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.UwpHelpers project and select \nAdd\n and then \nReference...\n\n\n\n\n\n\nOn the left of the Reference Manager, go to Browse and find the following file \n\u201cC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework.NETCore\\v4.5\\System.Runtime.WindowsRuntime.dll\u201d\n. Add a reference to this file.\n\n\n\n\n\n\n\n\nYou should now having the following references. Click \nOK\n.\n\n\n\n\n\n\n\n\nRebuild the solution\n\n\n\n\n\n\nNote: If you have the 14393 SDK installed in Visual Studio, instead of manually adding the above references to your porject, you can use a convenient NuGet package called \nUwpDesktop\n that makes it easy for you call into UWP APIs \nfrom Desktop and Centennial apps (WPF, WinForms, etc.) \n\n\nStep 2: Adding a UWP Helper Class\n\n\n\n\n\n\nAdd a new C# class to the Microsoft.Knowzy.UwpHelpers . Name the file ExecutionMode.cs.\n\n\n\n\n\n\nAdd the following code to ExecutionMode.cs. This code detects if the app is running as a UWP app.\n\n\nusing System;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing Windows.System.Profile;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class ExecutionMode\n    {\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        static extern int GetCurrentPackageFullName(ref int packageFullNameLength, ref StringBuilder packageFullName);\n\n        public static bool IsRunningAsUwp()\n        {\n            if (isWindows7OrLower())\n            {\n                return false;\n            }\n            else\n            {\n                StringBuilder sb = new StringBuilder(1024);\n                int length = 0;\n                int result = GetCurrentPackageFullName(ref length, ref sb);\n\n                return result != 15700;\n            }\n        }\n\n        internal static bool isWindows7OrLower()\n        {\n            int versionMajor = Environment.OSVersion.Version.Major;\n            int versionMinor = Environment.OSVersion.Version.Minor;\n            double version = versionMajor + (double)versionMinor / 10;\n            return version \n= 6.1;\n        }\n    }\n}\n\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.JsonDataProvider project, select \nAdd | Reference...\n and a reference to the Microsoft.Knowzy.UwpHelpers project.\n\n\n\n\n\n\nWe can now modify src\\Microsoft.KnowzyJsonDataProvider\\JsonDataProvider.cs as follows:\n\n\nusing Microsoft.Knowzy.UwpHelpers;\nusing System;\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        jsonFilePath = \"desktop\\\\\" + _configuration.Configuration.JsonFilePath;\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize\nProduct[]\n(_fileHelper.ReadTextFile(jsonFilePath));\n}\n\n\n\n\n\n\n\nBuild your solution and then set a break point at the following line of JsonDataProvider.cs (around line 40). \n\n\nif (ExecutionMode.IsRunningAsUwp())\n\n\n\n\n\n\n\nPress F5 to launch your app and...\n\n\nexecution does not stop at the breakpoint!\n\n\n\n\n\n\nThe build did not pick up our changes to Microsoft.Knowzy.JsonDataProvider. (Or if you rebuilt the entire solution, the changes did make it into the build).\nIn order to prevent having to do complete rebuild of our solution every time we change some code, we need to tell the DesktopBridge Debugging Project (Microsoft.Knowzy.Debug) which DLL's to copy to the AppX.\nUnfortunately, the current version of Visual Studio 2017 is not able to correctly handle code changes Desktop Bridge dependencies.\n\n\nSince we will be modifying the Microsoft.Knowzy.JsonDataProvider and Microsoft.Knowzy.UwpHelpers projects, let's add them to AppXPackageFileList.xml in the Microsoft.Knowzy.Debug project.\n\n\n?xml version=\"1.0\" encoding=\"utf-8\"?\n\n\nProject ToolsVersion=\"14.0\"\n        xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"\n\n\nPropertyGroup\n\n    \nMyProjectOutputPath\n..\\..\\bin\\Debug\n/MyProjectOutputPath\n\n\n/PropertyGroup\n\n\nItemGroup\n\n    \nLayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.WPF.exe\"\n\n    \nPackagePath\n$(PackageLayout)\\desktop\\Microsoft.Knowzy.WPF.exe\n/PackagePath\n\n    \n/LayoutFile\n\n    \nLayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.JsonDataProvider.dll\"\n\n    \nPackagePath\n$(PackageLayout)\\desktop\\Microsoft.Knowzy.JsonDataProvider.dll\n/PackagePath\n\n    \n/LayoutFile\n\n    \nLayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.UwpHelpers.dll\"\n\n    \nPackagePath\n$(PackageLayout)\\desktop\\Microsoft.Knowzy.UwpHelpers.dll\n/PackagePath\n\n    \n/LayoutFile\n\n\n/ItemGroup\n\n\n/Project\n\n\n\n\nNow every time you make a code change to Microsoft.Knowzy.JsonDataProvider or Microsoft.Knowzy.UwpHelpers, the changes will be part of the build.\n\n\nPress F5 again and now you should be able to hit the breakpoint in JsonDataProvider.cs.\n\n\nStep 3: Adding UWP support to detect the AppX Installation Folder\n\n\nWe are now going to start adding Windows 10 UWP APIs to our app in order to find the AppX folder's install location and in later tasks to add new Windows 10 features to our app. \n\n\n\n\n\n\nAdd a new C# class to theMicrosoft.Knowzy.UwpHelpers project. Name the file AppFolders.cs.\n\n\n\n\n\n\nAdd the following code to AppFolders.cs. This code uses methods from the Windows 10 UWP API\n\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class AppFolders\n    {\n        public static string Current\n        {\n            get\n            {\n                string path = null;\n                if (ExecutionMode.IsRunningAsUwp())\n                {\n                    path = GetSafeAppxFolder();\n                }\n                return path;\n            }\n        }\n\n        internal static string GetSafeAppxFolder()\n        {\n            try\n            {\n                return Windows.ApplicationModel.Package.Current.InstalledLocation.Path;\n            }\n            catch (Exception ex)\n            {\n\n                System.Diagnostics.Debug.WriteLine(ex.Message);\n            }\n            return null;\n        }\n    }\n}\n\n\n\n\n\n\n\nThis code uses the Package class in Windows.ApplicationModel.Package to determine the installed location of the UWP AppX folder.\n\n\n\n\nWe can now modify JsonDataProvider.cs as follows:\nusing System.IO;\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        jsonFilePath = Path.Combine(AppFolders.Current, \"desktop\", _configuration.Configuration.JsonFilePath);\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize\nProduct[]\n(_fileHelper.ReadTextFile(jsonFilePath));\n}\n\n\n\n\n\n\n\nPress F5 to run the Microsoft.Knowzy.Debug project. Finally our Knowzy UWP app can load the Products.json file from the correct location and display the information correctly.\n\n\n\n\nWe can also still run our original WPF version. The UWP additions are ignored by the WPF version. To try this out right-click on the Microsoft.Knowzy.WPF project and select \nDebug | Start new instance\n\n\n\n\nThe WPF app still continues to work as it was originally coded.\n\n\n\n\nWe will continue to add more Windows 10 UWP features to our app in the \nnext task\n.\n\n\nReferences\n\n\n\n\n\n\nCalling Windows 10 APIs From a Desktop Application\n\n\n\n\n\n\nPackage Class\n\n\n\n\n\n\nDesktop Bridge: Identify the application's context\n\n\n\n\n\n\nAnnouncing UWPDesktop NuGet Package Version 14393\n\n\n\n\n\n\nUWP for Desktop NuGet Package\n\n\n\n\n\n\nUWP for Desktop\n\n\n\n\n\n\nRun, debug, and test a packaged desktop app (Desktop Bridge)\n\n\n\n\n\n\nDesktopBridge To UWP Samples\n\n\n\n\n\n\nPackage a .NET app using Visual Studio \n\n\n\n\n\n\nBridgeTour Workshop\n\n\n\n\n\n\nDevelopers Guide to the Desktop Bridge\n\n\n\n\n\n\nThe solution for this task is located \nhere\n\n\ncontinue to \nnext task", 
            "title": "213 AddUwp"
        }, 
        {
            "location": "/stories/2/213_AddUwp/#task-213-adding-windows-10-uwp-apis-to-your-desktop-bridge-app", 
            "text": "This task will guide you through the process of adding Windows 10 UWP APIs to your Desktop Bridge app.", 
            "title": "Task 2.1.3 - Adding Windows 10 UWP APIs to your Desktop Bridge App"
        }, 
        {
            "location": "/stories/2/213_AddUwp/#prerequisites", 
            "text": "Basic knowledge of C# development    Basic knowledge of client development with the .NET framework    Basic knowledge of Windows 10 and the Universal Windows Platform    A computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.    Visual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free  Visual Studio 2017 Community    Complete the section on  Debugging a Windows Desktop Bridge App    To get started, please open the  Microsoft.Knowzy.WPF.sln  in the  src\\Knowzy_Engineering_Win32App  folder with Visual Studio 2017.   Note: If you are starting with this from the  2.1.2  solution, you will need to do the following:     Set the Build configuration to  Debug | x86     Select  Options  from the  Debug  menu, From the  Debugging | General  Tab,  disable the  Enable Just My Code  option.     Set the  Microsoft.Knowzy.Debug  project as the startup project.    Verify these settings before you continue with this task.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/2/213_AddUwp/#task", 
            "text": "In this task we will do the following:    Configure our Desktop Bridge projects to be able to use Windows 10 UWP APIs.    Fix the issue from the previous tasks where the Desktop Bridge app was not able to load the Product.json file when running as a UWP app.    In the previous tasks we discovered that our Desktop Bridge version of the Knowzy app cannot find the required file Products.json. The UWP version is looking for Products.json in the location expected by the \nWPF version. We need to correct this code so that when the UWP version of Knowzy is running it will look for the file in the correct location.    Searching the code for Products.json we find it in a file called Config.json.   {\n\"JsonFilePath\": \"Products.json\",\n\"DataSourceUrl\": \"http://\"\n}    Searching for JsonFilePath, we find it in src\\Microsoft.KnowzyJsonDataProvider\\JsonDataProvider.cs  public Product[] GetData()\n{\n    var jsonFilePath = _configuration.Configuration.JsonFilePath;\n    return _jsonHelper.Deserialize Product[] (_fileHelper.ReadTextFile(jsonFilePath));\n}    Setting a breakpoint around line 40 of JsonDataProvider.cs and stepping through the code we eventually find that ReadTextFile is looking for the Products.json file in the installed directory of the app.    When we created the Desktop Bridge version of Knowzy we copied all of the WPF Knowzy binaries to the desktop folder of the Desktop Bridge app. \nAfter a build and deployment of the Knowzy app, we will find the Products.json file in the directory  src\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX\\desktop   So an easy fix would be to try something like:  public Product[] GetData()\n{\n    String jsonFilePath;\n\n    if(IsRunningAsUwp())\n    {\n        jsonFilePath = \"desktop\\\\\" + _configuration.Configuration.JsonFilePath;\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize Product[] (_fileHelper.ReadTextFile(jsonFilePath));\n}  I'll save you some time and tell you that this won't work either.    We actually need to do something like this:  public Product[] GetData()\n{\n    String jsonFilePath;\n\n    if(IsRunningAsUwp())\n    {\n        jsonFilePath = Path.Combine(GetUWPAppDir(),\"desktop\", _configuration.Configuration.JsonFilePath);\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize Product[] (_fileHelper.ReadTextFile(jsonFilePath));\n}  We are going to need to add at least 2 UWP methods to our DeskTop Bridge version of Knowzy in order to be able to load the Products.json file.    A method to detect if we are running the UWP version    A method that returns the directory of the UWP application", 
            "title": "Task"
        }, 
        {
            "location": "/stories/2/213_AddUwp/#step-1-adding-uwp-support-to-the-knowzy-app", 
            "text": "We can add UWP APIs to our Knowzy app at any location we need the UWP code. However, it will be easier if we create a set of UWP helper classes and place then all in a single C# library.   Since all of the other dependencies in the Knowzy WPF solution are Windows Classic Desktop C# Class Libraries, we will add a new C# Class library called Microsoft.Knowzy.UwpHelpers.    Right-click on the src folder in the solution and select  Add | New Project...    Select the  Visual C# | Windows Classic Desktop | Class Library  project template.    Name the library Microsoft.Knowzy.UwpHelpers. Make sure you are saving the project to the  src  directory.     Right-click on the Microsoft.Knowzy.UwpHelpers project and select  Add  and then  Reference...     On the left of the Reference Manager, choose  Browse  and click the  Browse  button.     Find the following file:  \"C:\\Program Files (x86)\\Windows Kits\\10\\UnionMetadata\\10.0.15063.0\\Windows.winmd\" .  Add it to your project as a reference. Note: You will need to change the filter to \u201cAll Files\u201d to see this file.     Right-click on the Microsoft.Knowzy.UwpHelpers project and select  Add  and then  Reference...    On the left of the Reference Manager, go to Browse and find the following file  \u201cC:\\Program Files (x86)\\Reference Assemblies\\Microsoft\\Framework.NETCore\\v4.5\\System.Runtime.WindowsRuntime.dll\u201d . Add a reference to this file.     You should now having the following references. Click  OK .     Rebuild the solution    Note: If you have the 14393 SDK installed in Visual Studio, instead of manually adding the above references to your porject, you can use a convenient NuGet package called  UwpDesktop  that makes it easy for you call into UWP APIs \nfrom Desktop and Centennial apps (WPF, WinForms, etc.)", 
            "title": "Step 1: Adding UWP support to the Knowzy App"
        }, 
        {
            "location": "/stories/2/213_AddUwp/#step-2-adding-a-uwp-helper-class", 
            "text": "Add a new C# class to the Microsoft.Knowzy.UwpHelpers . Name the file ExecutionMode.cs.    Add the following code to ExecutionMode.cs. This code detects if the app is running as a UWP app.  using System;\nusing System.Runtime.InteropServices;\nusing System.Text;\nusing Windows.System.Profile;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class ExecutionMode\n    {\n        [DllImport(\"kernel32.dll\", CharSet = CharSet.Unicode, SetLastError = true)]\n        static extern int GetCurrentPackageFullName(ref int packageFullNameLength, ref StringBuilder packageFullName);\n\n        public static bool IsRunningAsUwp()\n        {\n            if (isWindows7OrLower())\n            {\n                return false;\n            }\n            else\n            {\n                StringBuilder sb = new StringBuilder(1024);\n                int length = 0;\n                int result = GetCurrentPackageFullName(ref length, ref sb);\n\n                return result != 15700;\n            }\n        }\n\n        internal static bool isWindows7OrLower()\n        {\n            int versionMajor = Environment.OSVersion.Version.Major;\n            int versionMinor = Environment.OSVersion.Version.Minor;\n            double version = versionMajor + (double)versionMinor / 10;\n            return version  = 6.1;\n        }\n    }\n}    Right-click on the Microsoft.Knowzy.JsonDataProvider project, select  Add | Reference...  and a reference to the Microsoft.Knowzy.UwpHelpers project.    We can now modify src\\Microsoft.KnowzyJsonDataProvider\\JsonDataProvider.cs as follows:  using Microsoft.Knowzy.UwpHelpers;\nusing System;\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        jsonFilePath = \"desktop\\\\\" + _configuration.Configuration.JsonFilePath;\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize Product[] (_fileHelper.ReadTextFile(jsonFilePath));\n}    Build your solution and then set a break point at the following line of JsonDataProvider.cs (around line 40).   if (ExecutionMode.IsRunningAsUwp())    Press F5 to launch your app and...  execution does not stop at the breakpoint!    The build did not pick up our changes to Microsoft.Knowzy.JsonDataProvider. (Or if you rebuilt the entire solution, the changes did make it into the build).\nIn order to prevent having to do complete rebuild of our solution every time we change some code, we need to tell the DesktopBridge Debugging Project (Microsoft.Knowzy.Debug) which DLL's to copy to the AppX.\nUnfortunately, the current version of Visual Studio 2017 is not able to correctly handle code changes Desktop Bridge dependencies.  Since we will be modifying the Microsoft.Knowzy.JsonDataProvider and Microsoft.Knowzy.UwpHelpers projects, let's add them to AppXPackageFileList.xml in the Microsoft.Knowzy.Debug project.  ?xml version=\"1.0\" encoding=\"utf-8\"?  Project ToolsVersion=\"14.0\"\n        xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\"  PropertyGroup \n     MyProjectOutputPath ..\\..\\bin\\Debug /MyProjectOutputPath  /PropertyGroup  ItemGroup \n     LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.WPF.exe\" \n     PackagePath $(PackageLayout)\\desktop\\Microsoft.Knowzy.WPF.exe /PackagePath \n     /LayoutFile \n     LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.JsonDataProvider.dll\" \n     PackagePath $(PackageLayout)\\desktop\\Microsoft.Knowzy.JsonDataProvider.dll /PackagePath \n     /LayoutFile \n     LayoutFile Include=\"$(MyProjectOutputPath)\\Microsoft.Knowzy.UwpHelpers.dll\" \n     PackagePath $(PackageLayout)\\desktop\\Microsoft.Knowzy.UwpHelpers.dll /PackagePath \n     /LayoutFile  /ItemGroup  /Project   Now every time you make a code change to Microsoft.Knowzy.JsonDataProvider or Microsoft.Knowzy.UwpHelpers, the changes will be part of the build.  Press F5 again and now you should be able to hit the breakpoint in JsonDataProvider.cs.", 
            "title": "Step 2: Adding a UWP Helper Class"
        }, 
        {
            "location": "/stories/2/213_AddUwp/#step-3-adding-uwp-support-to-detect-the-appx-installation-folder", 
            "text": "We are now going to start adding Windows 10 UWP APIs to our app in order to find the AppX folder's install location and in later tasks to add new Windows 10 features to our app.     Add a new C# class to theMicrosoft.Knowzy.UwpHelpers project. Name the file AppFolders.cs.    Add the following code to AppFolders.cs. This code uses methods from the Windows 10 UWP API  namespace Microsoft.Knowzy.UwpHelpers\n{\n    public class AppFolders\n    {\n        public static string Current\n        {\n            get\n            {\n                string path = null;\n                if (ExecutionMode.IsRunningAsUwp())\n                {\n                    path = GetSafeAppxFolder();\n                }\n                return path;\n            }\n        }\n\n        internal static string GetSafeAppxFolder()\n        {\n            try\n            {\n                return Windows.ApplicationModel.Package.Current.InstalledLocation.Path;\n            }\n            catch (Exception ex)\n            {\n\n                System.Diagnostics.Debug.WriteLine(ex.Message);\n            }\n            return null;\n        }\n    }\n}    This code uses the Package class in Windows.ApplicationModel.Package to determine the installed location of the UWP AppX folder.   We can now modify JsonDataProvider.cs as follows: using System.IO;\n\npublic Product[] GetData()\n{\n    String jsonFilePath;\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        jsonFilePath = Path.Combine(AppFolders.Current, \"desktop\", _configuration.Configuration.JsonFilePath);\n    }\n    else\n    {\n        jsonFilePath = _configuration.Configuration.JsonFilePath;\n    }\n\n    return _jsonHelper.Deserialize Product[] (_fileHelper.ReadTextFile(jsonFilePath));\n}    Press F5 to run the Microsoft.Knowzy.Debug project. Finally our Knowzy UWP app can load the Products.json file from the correct location and display the information correctly.   We can also still run our original WPF version. The UWP additions are ignored by the WPF version. To try this out right-click on the Microsoft.Knowzy.WPF project and select  Debug | Start new instance   The WPF app still continues to work as it was originally coded.   We will continue to add more Windows 10 UWP features to our app in the  next task .", 
            "title": "Step 3: Adding UWP support to detect the AppX Installation Folder"
        }, 
        {
            "location": "/stories/2/213_AddUwp/#references", 
            "text": "Calling Windows 10 APIs From a Desktop Application    Package Class    Desktop Bridge: Identify the application's context    Announcing UWPDesktop NuGet Package Version 14393    UWP for Desktop NuGet Package    UWP for Desktop    Run, debug, and test a packaged desktop app (Desktop Bridge)    DesktopBridge To UWP Samples    Package a .NET app using Visual Studio     BridgeTour Workshop    Developers Guide to the Desktop Bridge", 
            "title": "References"
        }, 
        {
            "location": "/stories/2/213_AddUwp/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/2/213_AddUwp/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/", 
            "text": "Task 2.1.4 - Integrate Windows Hello Authentication\n\n\nThis task will guide you through the process of adding the Windows Hello UWP API to your Win32 Desktop app using Visual Studio 2017. \nWe will also add support for presenting Windows 10 UWP Toast notifications to the user. \n\n\nWhat is Windows Hello?\n\n\nWindows Hello\n is the name Microsoft has given to the new biometric sign-in system built into Windows 10. Because it is built directly into the operating system, Windows Hello allows face or fingerprint identification to unlock users' devices. Authentication happens when the user supplies his or her unique biometric identifier to access the device-specific credentials, which means that an attacker who steals the device can't log on to it unless that attacker has the PIN. The Windows secure credential store protects biometric data on the device. By using Windows Hello to unlock a device, the authorized user gains access to all of his or her Windows experience, apps, data, websites, and services.\nThe Windows Hello authenticator is known as a Hello. A Hello is unique to the combination of an individual device and a specific user. It does not roam across devices, is not shared with a server or calling app, and cannot easily be extracted from a device. If multiple users share a device, each user needs to set up his or her own account. Every account gets a unique Hello for that device. You can think of a Hello as a token you can use to unlock (or release) a stored credential. The Hello itself does not authenticate you to an app or service, but it releases credentials that can. In other words, the Hello is not a user credential but it is a second factor for the authenticating process.\n\n\nWindows Hello is shipping as part of the Windows 10 operating system and developers can implement this technology to protect their Universal Windows Platform (UWP) apps and backend services. \n\n\nPrerequisites\n\n\n\n\n\n\nBasic knowledge of C# development\n\n\n\n\n\n\nBasic knowledge of client development with the .NET framework\n\n\n\n\n\n\nBasic knowledge of Windows 10 and the Universal Windows Platform\n\n\n\n\n\n\nA computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.\n\n\n\n\n\n\nVisual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free \nVisual Studio 2017 Community\n\n\n\n\n\n\nComplete the section on \nAdding Windows 10 UWP APIs to your Desktop Bridge App\n\n\n\n\n\n\nTask\n\n\nWe will use the Desktop Bridge Knowzy application which was created in the previous tasks as a starting point.\nTo get started, please open the \nMicrosoft.Knowzy.WPF.sln\n in the \nsrc\\Knowzy_Engineering_Win32App\n folder with Visual Studio 2017.\n\n\n\n\nNote: If you are starting with this from the \n2.1.3\n solution, you will need to do the following:\n\n\n\n\n\n\n\n\nSet the Build configuration to \nDebug | x86\n\n\n\n\n\n\n\n\nSelect \nOptions\n from the \nDebug\n menu, From the \nDebugging | General\n Tab,  disable the \nEnable Just My Code\n option.\n\n\n\n\n\n\n\n\nSet the \nMicrosoft.Knowzy.Debug\n project as the startup project.\n\n\n\n\n\n\nVerify these settings before you continue with this task.\n\n\nStep 1: Add a New UWP Helper Class for Windows Hello\n\n\nFollowing the techniques presented in the previous task, we are going to add the Windows 10 UWP code for the Windows Hello API and Toast notifications as helper classes.\nThese helper classes can be accessed by the Knowzy app when it is running as a Desktop Bridge UWP app.\n\n\n\n\n\n\nAdd a new C# class to the Microsoft.Knowzy.UwpHelpers project. Name the file WindowsHello.cs.\n\n\n\n\n\n\nAdd the following code to WindowsHello.cs. This code uses methods from the Windows 10 UWP API\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Windows.Security.Credentials;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class WindowsHello\n    {\n        public static async Task\nbool\n Login()\n        {\n            var result = await KeyCredentialManager.IsSupportedAsync();\n            String message;\n\n            if (result)\n            {\n                var authenticationResult = await KeyCredentialManager.RequestCreateAsync(\"login\", KeyCredentialCreationOption.ReplaceExisting);\n                if (authenticationResult.Status == KeyCredentialStatus.Success)\n                {\n                    message = \"User is logged in\";\n                }\n                else\n                {\n                    message = \"Login error: \" + authenticationResult.Status;\n                }\n            }\n            else\n            {\n                message = \"Windows Hello is not enabled for this device.\";\n            }\n\n            String imagePath = Windows.ApplicationModel.Package.Current.InstalledLocation.Path;\n            String xml = \"\ntoast\nvisual\nbinding template='ToastGeneric'\ntext hint-maxLines='1'\n\" + message + \"\n/text\n/binding\n/visual\n/toast\n\";\n\n            Toast.CreateToast(xml);\n\n            return result;\n        }\n    }\n}\n\n\n\n\n\n\n\nThis is only a starting point for Windows Hello support but it is sufficient to demonstrate how to add Windows 10 UWP APIs to your Desktop Bridge App. You will have the opportunity to complete coding\na Windows Hello login in a later task.\n\n\nStep 2: Add a New UWP Helper Class for Toast Notifications\n\n\nThe previous code example for Windows Hello uses a \nToast\n notification to indicated to the user\nif they are logged in. We need to add a UWP Helper class for Toasts.\n\n\n\n\n\n\nAdd a new C# class to the Microsoft.Knowzy.UwpHelpers project. Name the file Toast.cs.\n\n\n\n\n\n\nAdd the following code to Toast.cs. This code uses methods from the Windows 10 UWP API\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Windows.Data.Xml.Dom;\nusing Windows.UI.Notifications;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class Toast\n    {\n        static ToastNotification toast = null;\n        static ToastNotifier notifier = null;\n\n        public static void CreateToast(String xml)\n        {\n            if (!ExecutionMode.IsRunningAsUwp())\n            {\n                return;\n            }\n\n            try\n            {\n                if (notifier == null)\n                {\n                    notifier = ToastNotificationManager.CreateToastNotifier();\n                }\n                else\n                {\n                    notifier.Hide(toast);\n                }\n                XmlDocument toastXml = new XmlDocument();\n                toastXml.LoadXml(xml);\n\n                toast = new ToastNotification(toastXml);\n                notifier.Show(toast);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine(\"CreateToast Error:\" + ex.Message);\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\nStep 3: Add a Reference to Microsoft.Knowzy.UwpHelpers\n\n\n\n\nRight-click on the Microsoft.Knowzy.WPF project and select \nAdd | Reference...\n and select the Microsoft.Knowzy.UwpHelpers project. Click \nOK\n.\n\n\n\n\nStep 4: Add Login Code to the WPF App\n\n\nWhen the Login menu item in clicked in the UI of the Knowzy app, a message to open the Login dialog is sent to the  Handle(OpenLoginMessage message) method in\nMicrosoft.Knowzy.WPF\\ViewModels\\ShellViewModel.cs.\n\n\n\n\n\n\n\n\nOpen the file Microsoft.Knowzy.WPF\\ViewModels\\ShellViewModel.cs and find the Handle(OpenLoginMessage message) method near line 78.\n\n\n\n\n\n\nModify the Handle(OpenLoginMessage message) as follows:\n\n\nusing Microsoft.Knowzy.UwpHelpers;\n\npublic async void Handle(OpenLoginMessage message)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        await WindowsHello.Login();\n    }\n    else\n    {\n        _windowManager.ShowDialog(_loginViewModel);\n    }\n}\n\n\n\n\n\n\n\nBuild and run the solution (with Windows.Knowzy.Debug as the startup project)\n\n\n\n\n\n\nClick on the Login Menu item. \n\n\n\n\n\n\nIf your computer is capable of running the Windows Hello Login you will be presented with the Windows Hello Login interface.\n\n\n\n\n\n\nIf your computer is not capable of running the Windows Hello Login, a Toast will appear in the lower left corner of your screen.\n\n\n\n\n\n\n\n\n\n\n\n\nRun just the WPF version (right-click on the Microsoft.Knowzy.WPF project and select Debug | Start new instance). Clicking on the Login button will show:\n\n\n\n\n\n\n\n\nPlease note that this is not a complete implementation of Windows Hello login. For more information, please go \nhere\n.\n\n\nWe will continue to add more Windows 10 UWP features to our app in the \nnext task\n.\n\n\nReferences\n\n\n\n\n\n\nWindows Hello\n\n\n\n\n\n\nTiles, badges, and notifications for UWP apps\n\n\n\n\n\n\nAdaptive and interactive toast notifications\n\n\n\n\n\n\nThe solution for this task is located \nhere\n\n\ncontinue to \nnext task", 
            "title": "214 WindowsHello"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#task-214-integrate-windows-hello-authentication", 
            "text": "This task will guide you through the process of adding the Windows Hello UWP API to your Win32 Desktop app using Visual Studio 2017. \nWe will also add support for presenting Windows 10 UWP Toast notifications to the user.", 
            "title": "Task 2.1.4 - Integrate Windows Hello Authentication"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#what-is-windows-hello", 
            "text": "Windows Hello  is the name Microsoft has given to the new biometric sign-in system built into Windows 10. Because it is built directly into the operating system, Windows Hello allows face or fingerprint identification to unlock users' devices. Authentication happens when the user supplies his or her unique biometric identifier to access the device-specific credentials, which means that an attacker who steals the device can't log on to it unless that attacker has the PIN. The Windows secure credential store protects biometric data on the device. By using Windows Hello to unlock a device, the authorized user gains access to all of his or her Windows experience, apps, data, websites, and services.\nThe Windows Hello authenticator is known as a Hello. A Hello is unique to the combination of an individual device and a specific user. It does not roam across devices, is not shared with a server or calling app, and cannot easily be extracted from a device. If multiple users share a device, each user needs to set up his or her own account. Every account gets a unique Hello for that device. You can think of a Hello as a token you can use to unlock (or release) a stored credential. The Hello itself does not authenticate you to an app or service, but it releases credentials that can. In other words, the Hello is not a user credential but it is a second factor for the authenticating process.  Windows Hello is shipping as part of the Windows 10 operating system and developers can implement this technology to protect their Universal Windows Platform (UWP) apps and backend services.", 
            "title": "What is Windows Hello?"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#prerequisites", 
            "text": "Basic knowledge of C# development    Basic knowledge of client development with the .NET framework    Basic knowledge of Windows 10 and the Universal Windows Platform    A computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.    Visual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free  Visual Studio 2017 Community    Complete the section on  Adding Windows 10 UWP APIs to your Desktop Bridge App", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#task", 
            "text": "We will use the Desktop Bridge Knowzy application which was created in the previous tasks as a starting point.\nTo get started, please open the  Microsoft.Knowzy.WPF.sln  in the  src\\Knowzy_Engineering_Win32App  folder with Visual Studio 2017.   Note: If you are starting with this from the  2.1.3  solution, you will need to do the following:     Set the Build configuration to  Debug | x86     Select  Options  from the  Debug  menu, From the  Debugging | General  Tab,  disable the  Enable Just My Code  option.     Set the  Microsoft.Knowzy.Debug  project as the startup project.    Verify these settings before you continue with this task.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#step-1-add-a-new-uwp-helper-class-for-windows-hello", 
            "text": "Following the techniques presented in the previous task, we are going to add the Windows 10 UWP code for the Windows Hello API and Toast notifications as helper classes.\nThese helper classes can be accessed by the Knowzy app when it is running as a Desktop Bridge UWP app.    Add a new C# class to the Microsoft.Knowzy.UwpHelpers project. Name the file WindowsHello.cs.    Add the following code to WindowsHello.cs. This code uses methods from the Windows 10 UWP API  using System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Windows.Security.Credentials;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class WindowsHello\n    {\n        public static async Task bool  Login()\n        {\n            var result = await KeyCredentialManager.IsSupportedAsync();\n            String message;\n\n            if (result)\n            {\n                var authenticationResult = await KeyCredentialManager.RequestCreateAsync(\"login\", KeyCredentialCreationOption.ReplaceExisting);\n                if (authenticationResult.Status == KeyCredentialStatus.Success)\n                {\n                    message = \"User is logged in\";\n                }\n                else\n                {\n                    message = \"Login error: \" + authenticationResult.Status;\n                }\n            }\n            else\n            {\n                message = \"Windows Hello is not enabled for this device.\";\n            }\n\n            String imagePath = Windows.ApplicationModel.Package.Current.InstalledLocation.Path;\n            String xml = \" toast visual binding template='ToastGeneric' text hint-maxLines='1' \" + message + \" /text /binding /visual /toast \";\n\n            Toast.CreateToast(xml);\n\n            return result;\n        }\n    }\n}    This is only a starting point for Windows Hello support but it is sufficient to demonstrate how to add Windows 10 UWP APIs to your Desktop Bridge App. You will have the opportunity to complete coding\na Windows Hello login in a later task.", 
            "title": "Step 1: Add a New UWP Helper Class for Windows Hello"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#step-2-add-a-new-uwp-helper-class-for-toast-notifications", 
            "text": "The previous code example for Windows Hello uses a  Toast  notification to indicated to the user\nif they are logged in. We need to add a UWP Helper class for Toasts.    Add a new C# class to the Microsoft.Knowzy.UwpHelpers project. Name the file Toast.cs.    Add the following code to Toast.cs. This code uses methods from the Windows 10 UWP API  using System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Threading.Tasks;\nusing Windows.Data.Xml.Dom;\nusing Windows.UI.Notifications;\n\nnamespace Microsoft.Knowzy.UwpHelpers\n{\n    public class Toast\n    {\n        static ToastNotification toast = null;\n        static ToastNotifier notifier = null;\n\n        public static void CreateToast(String xml)\n        {\n            if (!ExecutionMode.IsRunningAsUwp())\n            {\n                return;\n            }\n\n            try\n            {\n                if (notifier == null)\n                {\n                    notifier = ToastNotificationManager.CreateToastNotifier();\n                }\n                else\n                {\n                    notifier.Hide(toast);\n                }\n                XmlDocument toastXml = new XmlDocument();\n                toastXml.LoadXml(xml);\n\n                toast = new ToastNotification(toastXml);\n                notifier.Show(toast);\n            }\n            catch (Exception ex)\n            {\n                Debug.WriteLine(\"CreateToast Error:\" + ex.Message);\n            }\n        }\n    }\n}", 
            "title": "Step 2: Add a New UWP Helper Class for Toast Notifications"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#step-3-add-a-reference-to-microsoftknowzyuwphelpers", 
            "text": "Right-click on the Microsoft.Knowzy.WPF project and select  Add | Reference...  and select the Microsoft.Knowzy.UwpHelpers project. Click  OK .", 
            "title": "Step 3: Add a Reference to Microsoft.Knowzy.UwpHelpers"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#step-4-add-login-code-to-the-wpf-app", 
            "text": "When the Login menu item in clicked in the UI of the Knowzy app, a message to open the Login dialog is sent to the  Handle(OpenLoginMessage message) method in\nMicrosoft.Knowzy.WPF\\ViewModels\\ShellViewModel.cs.     Open the file Microsoft.Knowzy.WPF\\ViewModels\\ShellViewModel.cs and find the Handle(OpenLoginMessage message) method near line 78.    Modify the Handle(OpenLoginMessage message) as follows:  using Microsoft.Knowzy.UwpHelpers;\n\npublic async void Handle(OpenLoginMessage message)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        await WindowsHello.Login();\n    }\n    else\n    {\n        _windowManager.ShowDialog(_loginViewModel);\n    }\n}    Build and run the solution (with Windows.Knowzy.Debug as the startup project)    Click on the Login Menu item.     If your computer is capable of running the Windows Hello Login you will be presented with the Windows Hello Login interface.    If your computer is not capable of running the Windows Hello Login, a Toast will appear in the lower left corner of your screen.       Run just the WPF version (right-click on the Microsoft.Knowzy.WPF project and select Debug | Start new instance). Clicking on the Login button will show:     Please note that this is not a complete implementation of Windows Hello login. For more information, please go  here .  We will continue to add more Windows 10 UWP features to our app in the  next task .", 
            "title": "Step 4: Add Login Code to the WPF App"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#references", 
            "text": "Windows Hello    Tiles, badges, and notifications for UWP apps    Adaptive and interactive toast notifications", 
            "title": "References"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/2/214_WindowsHello/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/2/221_XAMLView/", 
            "text": "Task 2.2.1 -  Create a new XAML view as part of app package\n\n\nThis task will guide you through the process of adding a Windows 10 UWP XAML UI to your Win32 Desktop Bridge app using Visual Studio 2017. \nWe will also add support for using Windows 10 UWP Protocols to communicate between the WPF exe and and UWP exe. \n\n\nPrerequisites\n\n\n\n\n\n\nBasic knowledge of C# development\n\n\n\n\n\n\nBasic knowledge of client development with the .NET framework\n\n\n\n\n\n\nBasic knowledge of Windows 10 and the Universal Windows Platform\n\n\n\n\n\n\nA computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.\n\n\n\n\n\n\nVisual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free \nVisual Studio 2017 Community\n\n\n\n\n\n\nCompleted the section on \nIntegrate Windows Hello Authentication\n\n\n\n\n\n\nMake sure the Microsoft.Knowzy.WPF.sln Build configuration to \nDebug | x86\n\n\n\n\n\n\n\n\nSet the \nMicrosoft.Knowzy.Debug\n project as the startup project.\n\n\n\n\n\n\nTask\n\n\nOur Desktop Bridge version of the Knowzy app actually consists of two different executables. The original WPF version (Microsoft.Knowzy.WPF.exe) and the UWP version (Microsoft.Knowzy.UWP.exe). \nMicrosoft.Knowzy.UWP.exe is located in src\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX.\n\n\n\n\nMicrosoft.Knowzy.WPF.exe is located in src\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX\\desktop\n\n\n\n\nThe Application element in the Package.appxmanifest in the Microsoft.Knowzy.UWP project specifies that Microsoft.Knowzy.WPF.exe is the app to be launched when the user starts the Desktop Bridge UWP version of Knowzy. \nThere is actually no mention of Microsoft.Knowzy.UWP.exe in the Package.appxmanifest and it currently will not run.\n\n\nApplications\n\n    \nApplication Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\"\n\n    \n/Application\n\n\n/Applications\n\n\n\n\nWe are now going to use the Microsoft.Knowzy.UWP.exe to display a UWP XAML UI page. We will launch Microsoft.Knowzy.UWP.exe by using \nURI activation\n.\n\n\nStep 1: Specify an Application Extension in the package manifest\n\n\nAs mentioned above, the Package.appxmanifest currently does not know anything about Microsoft.Knowzy.UWP.exe. We are going to add an Extension to the Application tag of the Package.appxmanifest.\n\n\n\n\n\n\nRight-click on the Package.appxmanifest file in the Microsoft.Knowzy.UWP project and select \nView Code\n*\n\n\n\n\n\n\nModify the Application section of the XML to add the following Extensions tag\n\n\nExtensions\n\n\nuap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\"\n\n    \nuap:Protocol Name=\"com.microsoft.knowzy.protocol.3d\" /\n\n\n/uap:Extension\n\n\n/Extensions\n\n\n\n\n\n\n\n\nYour Application section should now look something like this:\n\n\nApplication Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\"\n\n\nuap:VisualElements\n    DisplayName=\"Microsoft.Knowzy.UWP\"\n    Square150x150Logo=\"Assets\\Square150x150Logo.png\"\n    Square44x44Logo=\"Assets\\Square44x44Logo.png\"\n    Description=\"Microsoft.Knowzy.UWP\"\n    BackgroundColor=\"transparent\"\n\n    \nuap:DefaultTile Wide310x150Logo=\"Assets\\Wide310x150Logo.png\"/\n\n    \nuap:SplashScreen Image=\"Assets\\SplashScreen.png\" /\n\n\n/uap:VisualElements\n\n\nExtensions\n\n    \nuap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\"\n\n    \nuap:Protocol Name=\"com.microsoft.knowzy.protocol.3d\" /\n\n    \n/uap:Extension\n\n\n/Extensions\n\n\n/Application\n\n\n\n\n\n\n\n\nThe Microsoft.Knowzy.UWP app will now be registered as a handler for the com.microsoft.knowzy.protocol.3d Uniform Resource Identifier (URI) name.\n\n\n\n\nBuild and Deploy the Microsoft.Knowzy.UWP project to make sure your Package.appxmanifest file is valid. \n\n\n\n\nStep 2: Handle the activated event in Microsoft.Knowzy.UWP\n\n\nWhen another app sends the Knowzy app a protocol message using the com.microsoft.knowzy.protocol.3d URI, Microsoft.Knowzy.UWP.exe will be activated by the operationg system. \nWe need to add some code to Microsoft.Knowzy.UWP to handle the URI activation.\n\n\n\n\n\n\nOpen the file App.xaml.cs in the Microsoft.Knowzy.UWP project.\n\n\n\n\n\n\nAdd the following activation code at the bottom of the App class:\n\n\nprotected override void OnActivated(IActivatedEventArgs args)\n{\n    if (args.Kind == ActivationKind.Protocol)\n    {\n        ProtocolActivatedEventArgs eventArgs = args as ProtocolActivatedEventArgs;\n        // TODO: Handle URI activation\n        // The received URI is eventArgs.Uri.AbsoluteUri\n\n        Uri uri = eventArgs.Uri;\n        if (uri.Scheme == \"com.microsoft.knowzy.protocol.3d\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(MainPage), uri.Query);\n            Window.Current.Activate();\n        }\n    }\n}\n\n\n\n\n\n\n\nThis code will present the MainPage of the app if it receives the URI com.microsoft.knowzy.protocol.3d.\n\n\n\n\n\n\nOpen the file MainPage.xaml in the Microsoft.Knowzy.UWP project. Modify the XAML to add a WebView\n\n\nGrid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\"\n\n    \nWebView Name=\"webView\" /\n\n\n/Grid\n\n\n\n\n\n\n\n\nOpen the file MainPage.xaml.cs in the Microsoft.Knowzy.UWP project. Add the following method to the MainPage class:\n\n\nprotected override void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        WwwFormUrlDecoder decoder = new WwwFormUrlDecoder(args.Parameter.ToString());\n        try\n        {\n            var message = decoder.GetFirstValueByName(\"nose\");\n            webView.Source = new Uri(message);\n        }\n        catch(Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine(\"MainPage OnNavigatedTo Error: \"  + ex.Message);\n        }\n    }\n}\n\n\n\n\n\n\n\nStep 3: Add the Windows 10 UWP URI sending code to the WPF app\n\n\nNow that the Microsoft.Knowzy.UWP app knows how to handle a URI request, we are going to add code to the Microsoft.Knowzy.WPF project to make the URI request.\n\n\n\n\n\n\nAdd a new C# class to the Helpers folder of the Microsoft.Knowzy.UwpHelpers project. Name the file UriProtocol.cs.\n\n\n\n\n\n\nAdd the following method to the UriProtocol class. Make sure the class is public,\n\n\npublic class UriProtocol\n{\n    public static async Task\nbool\n SendUri(Uri uri)\n    {\n        // Note: DesktopBridge.Helpers NuGet package incorrectly warns that LaunchUriAsync is not supported in a Centennial App\n        bool result = await Windows.System.Launcher.LaunchUriAsync(uri);\n        return result;\n    }\n}\n\n\n\n\n\n\n\nIntellisense may complain that LaunchUriAsync is only available to UWP apps. You can ignore this warning.\n\n\nStep 4: Add the URI Code to the WPF App\n\n\nOur Knowzy app has an unused View menu item. We will use this to call the code to launch the UWP XAML UI using the Windows 10 UWP uri code we added to the Helpers.\n\n\n\n\n\n\n\n\nModify the XAML Microsoft.Knowzy.WPF\\Views\\MainView.xaml to add a Click event to the View MenuItem (around line 43)\n\n\nMenuItem Header=\"{x:Static localization:Resources.View_Menu}\" Template=\"{DynamicResource MenuItemControlTemplate}\"\n\n    \nMenuItem Header=\"{x:Static localization:Resources.ListView_Tab}\" Template=\"{StaticResource MenuItemBarControlTemplate}\" \n            cal:Message.Attach=\"ShowListView()\"/\n\n    \nMenuItem Header=\"Grid view\" Template=\"{StaticResource MenuItemBarControlTemplate}\"\n            cal:Message.Attach=\"ShowGridView()\"/\n\n    \nMenuItem Header=\"View 3D\" Template=\"{StaticResource MenuItemBarControlTemplate}\"\n            cal:Message.Attach=\"Show3DView()\"/\n\n\n/MenuItem\n\n\n\n\n\n\n\n\nAdd a Show3DView() method to Microsoft.Knowzy.WPF\\Models\\MainViewModel.cs\n\n\nusing Microsoft.Knowzy.UwpHelpers;\nusing System;\n\npublic async void Show3DView()\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        Uri uri = new Uri(\"com.microsoft.knowzy.protocol.3d://\" + \"message?nose=\" + \"https://www.remix3d.com/details/G009SXPQ5S3P\");\n        await UriProtocol.SendUri(uri);\n    }\n    else\n    {\n        MessageBox.Show(\"3D View not implemented in WPF version\", \"Microsoft.Knowzy.WPF\");\n    };\n}\n\n\n\n\n\n\n\nBuild and run the solution (with Windows.Knowzy.Debug as the startup application)\n\n\n\n\n\n\nSelect \nView 3D\n from the \nView\n menu. The Xaml ui of the Microsoft.Knowzy.UWP app will appear and display the 3D clown nose specified by the Uri parameters.\n\n\n\n\n\n\n\n\nIf you want to suggest to Windows 10 the size of the XAML UI Window, add the following code to the MainPage constructor in the file MainPage.xaml.cs in the Microsoft.Knowzy.UWP project\n\n\nusing Windows.UI.ViewManagement;\n\npublic MainPage()\n{\n    this.InitializeComponent();\n    ApplicationView.GetForCurrentView().TryResizeView(new Size(800, 800));\n}\n\n\n\n\n\n\n\nWe will continue to add more Windows 10 UWP features to our app in the \nnext task\n.\n\n\nReferences\n\n\n\n\nHandle URI activation\n\n\n\n\nThe solution for this task is located \nhere\n\n\ncontinue to \nnext task", 
            "title": "221 XAMLView"
        }, 
        {
            "location": "/stories/2/221_XAMLView/#task-221-create-a-new-xaml-view-as-part-of-app-package", 
            "text": "This task will guide you through the process of adding a Windows 10 UWP XAML UI to your Win32 Desktop Bridge app using Visual Studio 2017. \nWe will also add support for using Windows 10 UWP Protocols to communicate between the WPF exe and and UWP exe.", 
            "title": "Task 2.2.1 -  Create a new XAML view as part of app package"
        }, 
        {
            "location": "/stories/2/221_XAMLView/#prerequisites", 
            "text": "Basic knowledge of C# development    Basic knowledge of client development with the .NET framework    Basic knowledge of Windows 10 and the Universal Windows Platform    A computer with Windows 10 Anniversary Update or Windows 10 Creators Update. If you want to use the Desktop App Converter with an installer, you will need at least a Pro or Enterprise version, since it leverages a feature called Containers which is not available in the Home version.    Visual Studio 2017 with the tools to develop applications for the Universal Windows Platform. Any edition is supported, including the free  Visual Studio 2017 Community    Completed the section on  Integrate Windows Hello Authentication    Make sure the Microsoft.Knowzy.WPF.sln Build configuration to  Debug | x86     Set the  Microsoft.Knowzy.Debug  project as the startup project.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/2/221_XAMLView/#task", 
            "text": "Our Desktop Bridge version of the Knowzy app actually consists of two different executables. The original WPF version (Microsoft.Knowzy.WPF.exe) and the UWP version (Microsoft.Knowzy.UWP.exe). \nMicrosoft.Knowzy.UWP.exe is located in src\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX.   Microsoft.Knowzy.WPF.exe is located in src\\Microsoft.Knowzy.UWP\\bin\\x86\\Release\\AppX\\desktop   The Application element in the Package.appxmanifest in the Microsoft.Knowzy.UWP project specifies that Microsoft.Knowzy.WPF.exe is the app to be launched when the user starts the Desktop Bridge UWP version of Knowzy. \nThere is actually no mention of Microsoft.Knowzy.UWP.exe in the Package.appxmanifest and it currently will not run.  Applications \n     Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\" \n     /Application  /Applications   We are now going to use the Microsoft.Knowzy.UWP.exe to display a UWP XAML UI page. We will launch Microsoft.Knowzy.UWP.exe by using  URI activation .", 
            "title": "Task"
        }, 
        {
            "location": "/stories/2/221_XAMLView/#step-1-specify-an-application-extension-in-the-package-manifest", 
            "text": "As mentioned above, the Package.appxmanifest currently does not know anything about Microsoft.Knowzy.UWP.exe. We are going to add an Extension to the Application tag of the Package.appxmanifest.    Right-click on the Package.appxmanifest file in the Microsoft.Knowzy.UWP project and select  View Code *    Modify the Application section of the XML to add the following Extensions tag  Extensions  uap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\" \n     uap:Protocol Name=\"com.microsoft.knowzy.protocol.3d\" /  /uap:Extension  /Extensions     Your Application section should now look something like this:  Application Id=\"Knowzy\" Executable=\"desktop\\Microsoft.Knowzy.WPF.exe\" EntryPoint=\"Windows.FullTrustApplication\"  uap:VisualElements\n    DisplayName=\"Microsoft.Knowzy.UWP\"\n    Square150x150Logo=\"Assets\\Square150x150Logo.png\"\n    Square44x44Logo=\"Assets\\Square44x44Logo.png\"\n    Description=\"Microsoft.Knowzy.UWP\"\n    BackgroundColor=\"transparent\" \n     uap:DefaultTile Wide310x150Logo=\"Assets\\Wide310x150Logo.png\"/ \n     uap:SplashScreen Image=\"Assets\\SplashScreen.png\" /  /uap:VisualElements  Extensions \n     uap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\" \n     uap:Protocol Name=\"com.microsoft.knowzy.protocol.3d\" / \n     /uap:Extension  /Extensions  /Application     The Microsoft.Knowzy.UWP app will now be registered as a handler for the com.microsoft.knowzy.protocol.3d Uniform Resource Identifier (URI) name.   Build and Deploy the Microsoft.Knowzy.UWP project to make sure your Package.appxmanifest file is valid.", 
            "title": "Step 1: Specify an Application Extension in the package manifest"
        }, 
        {
            "location": "/stories/2/221_XAMLView/#step-2-handle-the-activated-event-in-microsoftknowzyuwp", 
            "text": "When another app sends the Knowzy app a protocol message using the com.microsoft.knowzy.protocol.3d URI, Microsoft.Knowzy.UWP.exe will be activated by the operationg system. \nWe need to add some code to Microsoft.Knowzy.UWP to handle the URI activation.    Open the file App.xaml.cs in the Microsoft.Knowzy.UWP project.    Add the following activation code at the bottom of the App class:  protected override void OnActivated(IActivatedEventArgs args)\n{\n    if (args.Kind == ActivationKind.Protocol)\n    {\n        ProtocolActivatedEventArgs eventArgs = args as ProtocolActivatedEventArgs;\n        // TODO: Handle URI activation\n        // The received URI is eventArgs.Uri.AbsoluteUri\n\n        Uri uri = eventArgs.Uri;\n        if (uri.Scheme == \"com.microsoft.knowzy.protocol.3d\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(MainPage), uri.Query);\n            Window.Current.Activate();\n        }\n    }\n}    This code will present the MainPage of the app if it receives the URI com.microsoft.knowzy.protocol.3d.    Open the file MainPage.xaml in the Microsoft.Knowzy.UWP project. Modify the XAML to add a WebView  Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" \n     WebView Name=\"webView\" /  /Grid     Open the file MainPage.xaml.cs in the Microsoft.Knowzy.UWP project. Add the following method to the MainPage class:  protected override void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        WwwFormUrlDecoder decoder = new WwwFormUrlDecoder(args.Parameter.ToString());\n        try\n        {\n            var message = decoder.GetFirstValueByName(\"nose\");\n            webView.Source = new Uri(message);\n        }\n        catch(Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine(\"MainPage OnNavigatedTo Error: \"  + ex.Message);\n        }\n    }\n}", 
            "title": "Step 2: Handle the activated event in Microsoft.Knowzy.UWP"
        }, 
        {
            "location": "/stories/2/221_XAMLView/#step-3-add-the-windows-10-uwp-uri-sending-code-to-the-wpf-app", 
            "text": "Now that the Microsoft.Knowzy.UWP app knows how to handle a URI request, we are going to add code to the Microsoft.Knowzy.WPF project to make the URI request.    Add a new C# class to the Helpers folder of the Microsoft.Knowzy.UwpHelpers project. Name the file UriProtocol.cs.    Add the following method to the UriProtocol class. Make sure the class is public,  public class UriProtocol\n{\n    public static async Task bool  SendUri(Uri uri)\n    {\n        // Note: DesktopBridge.Helpers NuGet package incorrectly warns that LaunchUriAsync is not supported in a Centennial App\n        bool result = await Windows.System.Launcher.LaunchUriAsync(uri);\n        return result;\n    }\n}    Intellisense may complain that LaunchUriAsync is only available to UWP apps. You can ignore this warning.", 
            "title": "Step 3: Add the Windows 10 UWP URI sending code to the WPF app"
        }, 
        {
            "location": "/stories/2/221_XAMLView/#step-4-add-the-uri-code-to-the-wpf-app", 
            "text": "Our Knowzy app has an unused View menu item. We will use this to call the code to launch the UWP XAML UI using the Windows 10 UWP uri code we added to the Helpers.     Modify the XAML Microsoft.Knowzy.WPF\\Views\\MainView.xaml to add a Click event to the View MenuItem (around line 43)  MenuItem Header=\"{x:Static localization:Resources.View_Menu}\" Template=\"{DynamicResource MenuItemControlTemplate}\" \n     MenuItem Header=\"{x:Static localization:Resources.ListView_Tab}\" Template=\"{StaticResource MenuItemBarControlTemplate}\" \n            cal:Message.Attach=\"ShowListView()\"/ \n     MenuItem Header=\"Grid view\" Template=\"{StaticResource MenuItemBarControlTemplate}\"\n            cal:Message.Attach=\"ShowGridView()\"/ \n     MenuItem Header=\"View 3D\" Template=\"{StaticResource MenuItemBarControlTemplate}\"\n            cal:Message.Attach=\"Show3DView()\"/  /MenuItem     Add a Show3DView() method to Microsoft.Knowzy.WPF\\Models\\MainViewModel.cs  using Microsoft.Knowzy.UwpHelpers;\nusing System;\n\npublic async void Show3DView()\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        Uri uri = new Uri(\"com.microsoft.knowzy.protocol.3d://\" + \"message?nose=\" + \"https://www.remix3d.com/details/G009SXPQ5S3P\");\n        await UriProtocol.SendUri(uri);\n    }\n    else\n    {\n        MessageBox.Show(\"3D View not implemented in WPF version\", \"Microsoft.Knowzy.WPF\");\n    };\n}    Build and run the solution (with Windows.Knowzy.Debug as the startup application)    Select  View 3D  from the  View  menu. The Xaml ui of the Microsoft.Knowzy.UWP app will appear and display the 3D clown nose specified by the Uri parameters.     If you want to suggest to Windows 10 the size of the XAML UI Window, add the following code to the MainPage constructor in the file MainPage.xaml.cs in the Microsoft.Knowzy.UWP project  using Windows.UI.ViewManagement;\n\npublic MainPage()\n{\n    this.InitializeComponent();\n    ApplicationView.GetForCurrentView().TryResizeView(new Size(800, 800));\n}    We will continue to add more Windows 10 UWP features to our app in the  next task .", 
            "title": "Step 4: Add the URI Code to the WPF App"
        }, 
        {
            "location": "/stories/2/221_XAMLView/#references", 
            "text": "Handle URI activation", 
            "title": "References"
        }, 
        {
            "location": "/stories/2/221_XAMLView/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/2/221_XAMLView/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/2/222_Share/", 
            "text": "Task 2.2.2 -  Add support for other apps to share images with the Knowzy App\n\n\nOur development department has the idea to allow Knowzy app users to share images from other Windows 10 applications with the Knowzy app. \nFor now, we just want you to implement the Windows 10 sharing code. To show that the image was shared with the Knowzy app, please display a toast\nwith the image.\n\n\nRequirements for this task:\n* Share an image from another Windows 10 App. The Knowzy app should appear as one of the options for Share Targets.\n\n\n\n\n\n\nDisplay a XAML UI for sharing with the Knowzy app.\n\n\n\n\n\n\nDisplay a Toast that displays the image after the sharing operation has completed.\n\n\n\n\n\n\nOur research has found a starting point for the sharing idea \nhere\n\nunder the \"Making your PC software a share target\" section.\n\n\nWe also found some \nsample code\n.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 2.2.1\n and all of it's prerequisites\n\n\n\n\nMake sure the Microsoft.Knowzy.WPF.sln Build configuration to \nDebug | x86\n\n\n\n\n\n\n\n\nSet the \nMicrosoft.Knowzy.Debug\n project as the startup project.\n\n\n\n\nTask\n\n\n\n\n\n\nYou will need to add a sharing extension to the Extension section of the Application tag in Package.appxmanifest in the Microsoft.Knowzy.UWP project to enable the app to be an image share target. \nYou also need to specify that you are a share target that supports Bitmap images.\n\n\nuap:Extension Category=\"windows.shareTarget\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\"\n\n  \nuap:ShareTarget\n\n    \nuap:SupportedFileTypes\n\n      \nuap:SupportsAnyFileType /\n\n    \n/uap:SupportedFileTypes\n\n    \nuap:DataFormat\nBitmap\n/uap:DataFormat\n\n  \n/uap:ShareTarget\n\n\n/uap:Extension\n\n\n\n\n\n\n\n\nYou will need to add an OnShareTargetActivated event handler to App.xaml.cs in the Microsoft.Knowzy.UWP project. This handler will be called when a user attempts to share an image to the Knowzy app.\nIt should look something like:\n\n\nprotected override void OnShareTargetActivated(ShareTargetActivatedEventArgs e)\n{\n    Frame rootFrame = new Frame();\n    Window.Current.Content = rootFrame;\n    rootFrame.Navigate(typeof(SharePage), e.ShareOperation);\n    Window.Current.Activate();\n}\n\n\n\n\n\n\n\nYou will need to add a new XAML page to the Microsoft.Knowzy.UWP project. Right click on the project and select \nAdd | New Item...\n. Choose the \nBlank Page\n template and name it \nSharePage.xaml\n.\n\n\n\n\n\n\nYou will need to add the Sharing UI to the SharePage.xaml file. For now, use something like:\n\n\nGrid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" Margin=\"12\"\n\n    \nStackPanel\n\n        \nButton Content=\"Share to Microsoft.Knowzy.WPF\" Click=\"ShareButton_Click\"/\n\n        \nTextBlock x:Name=\"tbFileName\" /\n\n        \nImage x:Name=\"img\"/\n\n    \n/StackPanel\n\n\n/Grid\n\n\n\n\n\n\n\n\nIn the file SharePage.xaml.cs you will need to handle the OnNavigatedTo event. The NavigationEventArgs parameter will contain the shared image information. Display the shared image in the\nSharedPage UI. Pay attention to threading issues such as processing the image in a separate task. Also, you can only update the XAML UI image on the UI thread so you will need to use a dispacther to update the UI.\n\n\n// add the following using directives\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Windows.ApplicationModel.DataTransfer;\nusing Windows.ApplicationModel.DataTransfer.ShareTarget;\nusing Windows.Storage;\nusing Windows.UI.Core;\nusing Windows.UI.Xaml.Media.Imaging;\n\n// add the following private members to the SharePage class\nprivate ShareOperation operation = null;\nprivate StorageFile file = null;\n\n// Add the following method to the SharePage class\nprotected override async void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        // It is recommended to only retrieve the ShareOperation object in the activation handler, return as\n        // quickly as possible, and retrieve all data from the share target asynchronously.\n        operation = (ShareOperation)args.Parameter;\n\n        await Task.Factory.StartNew(async () =\n\n        {\n            if (operation.Data.Contains(StandardDataFormats.StorageItems))\n            {\n                var storageItems = await operation.Data.GetStorageItemsAsync();\n                file = (StorageFile)(storageItems[0]);\n                var stream = await file.OpenReadAsync();\n                // Get back to the UI thread using the dispatcher.\n                await Dispatcher.RunAsync(CoreDispatcherPriority.Normal, async () =\n\n                {\n                    var image = new BitmapImage();\n                    img.Source = image;\n                    await image.SetSourceAsync(stream);\n                });\n            }\n        });\n    }\n}\n\n\n\n\n\n\n\nUp to this point, the user has only shared the image with the UWP version of Knowzy. We need to share the image so it can be accessed by the WPF version of Knowzy. The SharePage UI includes a \"Share to Knowzy WPF\" \nbutton that will trigger this sharing operation. Add a \"ShareButton_Click\" event handler to SharePage.xaml.cs. Please note the location of the sharing folder. ApplicationData.Current.LocalFolder. More information on\nthis folder is available \nhere\n.\n\n\nprivate async void ShareButton_Click(object sender, RoutedEventArgs e)\n{\n    if (file != null)\n    {\n        // copy file to app's local folder. Desktop Bridge app will detect new file with its FileWatcher\n        try\n        {\n            await file.CopyAsync(ApplicationData.Current.LocalFolder, file.Name, NameCollisionOption.ReplaceExisting);\n        }\n        catch (Exception ex)\n        {\n            Debug.WriteLine(\"ShareButton_Click Error:\" + ex.Message);\n        }\n    }\n\n    if (operation != null)\n    {\n        operation.ReportCompleted();\n    }\n}\n\n\n\n\n\n\n\nNow that the image has been copied to the ApplicationData.Current.LocalFolder, the Knowzy WPF app needs to be able to detect that an image has been shared. \nWe will use a FileSystemWatcher to detect when an image has been to the ApplicationData.Current.LocalFolder. We will make this a feature that is only supported\nwhen the app is running as a Desktop Bridge app. Add the following code to Views\\MainView.xaml.cs in the Microsoft.Knowzy.WPF project:\n\n\nusing System;\nusing System.Diagnostics;\nusing System.IO;\nusing Microsoft.Knowzy.UwpHelpers;\n\npublic MainView()\n{\n    InitializeComponent();\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n    try\n        {\n            // get the path to the App folder (WPF or UWP).\n            var path = AppFolders.Local;\n            FileSystemWatcher watcher = new FileSystemWatcher(path);\n            watcher.EnableRaisingEvents = true;\n            watcher.Changed += Watcher_Changed;\n        }\n        catch(Exception ex)\n        {\n            Debug.WriteLine(\"FileSystemWatcher Error:\" + ex.Message);\n        }\n    }\n}\n\n\n\n\n\n\n\nAdd the FileSystemWatcher event handler to MainView.xaml.cs in the Microsoft.Knowzy.WPF project:\n\n\nprivate void Watcher_Changed(object sender, FileSystemEventArgs e)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        if (File.Exists(e.FullPath))\n        {\n            var xml = \"\ntoast\nvisual\nbinding template='ToastGeneric'\nimage src='\" + e.FullPath + \"'/\ntext hint-maxLines='1'\nMicrosoft.Knowzy.WPF received a new image\n/text\n/binding\n/visual\n/toast\n\";\n            Toast.CreateToast(xml);\n        }\n    }\n}\n\n\n\n\n\n\n\nYou will need to add a getter to AppFolders.cs in Microsoft.Knowzy.UwpHelpers to return the path to Windows.Storage.ApplicationData.Current.LocalFolder. \n\n\nAdd the following code to AppFolders.cs\n\n\npublic static string Local\n{\n    get\n    {\n        string path = null;\n        if (ExecutionMode.IsRunningAsUwp())\n        {\n            path = GetSafeAppxLocalFolder();\n        }\n        return path;\n    }\n}\n\ninternal static string GetSafeAppxLocalFolder()\n{\n    try\n    {\n        return Windows.Storage.ApplicationData.Current.LocalFolder.Path;\n    }\n    catch (Exception ex)\n    {\n        System.Diagnostics.Debug.WriteLine(ex.Message);\n    }\n    return null;\n}\n\n\n\n\n\n\n\nOnce you have made all of your changes to to code, build and run the Microsoft.Knowzy.Debug project.\n\n\n\n\n\n\nOpen an Windows 10 application that is capable of sharing a picture (Microsoft Edge). Navigate to a picture you want to share.\n\n\n\n\n\n\nRight click on the image and select \nShare picture\n\n\n\n\n\n\n\n\nIn the list of apps that are iamge share targets, select Microsoft.Know.UWP\n\n\n\n\n\n\n\n\nThe Microsoft.Knowzy.UWP SharePage will appear and display the image. Click on the \nShare to Microsoft.Knowzy.WPF\n button.\n\n\n\n\n\n\n\n\nThe FileSystemWatcher in the Microsoft.Knowzy.WPF app will be notified that a new image has been shared to the app. It will then display the toast with the image.\n\n\n\n\n\n\n\n\nWe will continue to add more Windows 10 UWP features to our app in the \nnext task\n.\n\n\nReferences\n\n\n\n\n\n\nShare data\n\n\n\n\n\n\nSharing content target app sample\n \n\n\n\n\n\n\nSharing content source app sample\n\n\n\n\n\n\nAdding UWP features to your existing PC software\n\n\n\n\n\n\nWPF picture viewer as a share target\n\n\n\n\n\n\nThe solution for this task is located \nhere\n\n\ncontinue to \nnext task", 
            "title": "222 Share"
        }, 
        {
            "location": "/stories/2/222_Share/#task-222-add-support-for-other-apps-to-share-images-with-the-knowzy-app", 
            "text": "Our development department has the idea to allow Knowzy app users to share images from other Windows 10 applications with the Knowzy app. \nFor now, we just want you to implement the Windows 10 sharing code. To show that the image was shared with the Knowzy app, please display a toast\nwith the image.  Requirements for this task:\n* Share an image from another Windows 10 App. The Knowzy app should appear as one of the options for Share Targets.    Display a XAML UI for sharing with the Knowzy app.    Display a Toast that displays the image after the sharing operation has completed.    Our research has found a starting point for the sharing idea  here \nunder the \"Making your PC software a share target\" section.  We also found some  sample code .", 
            "title": "Task 2.2.2 -  Add support for other apps to share images with the Knowzy App"
        }, 
        {
            "location": "/stories/2/222_Share/#prerequisites", 
            "text": "This task has a dependency on  Task 2.2.1  and all of it's prerequisites   Make sure the Microsoft.Knowzy.WPF.sln Build configuration to  Debug | x86     Set the  Microsoft.Knowzy.Debug  project as the startup project.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/2/222_Share/#task", 
            "text": "You will need to add a sharing extension to the Extension section of the Application tag in Package.appxmanifest in the Microsoft.Knowzy.UWP project to enable the app to be an image share target. \nYou also need to specify that you are a share target that supports Bitmap images.  uap:Extension Category=\"windows.shareTarget\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\" \n   uap:ShareTarget \n     uap:SupportedFileTypes \n       uap:SupportsAnyFileType / \n     /uap:SupportedFileTypes \n     uap:DataFormat Bitmap /uap:DataFormat \n   /uap:ShareTarget  /uap:Extension     You will need to add an OnShareTargetActivated event handler to App.xaml.cs in the Microsoft.Knowzy.UWP project. This handler will be called when a user attempts to share an image to the Knowzy app.\nIt should look something like:  protected override void OnShareTargetActivated(ShareTargetActivatedEventArgs e)\n{\n    Frame rootFrame = new Frame();\n    Window.Current.Content = rootFrame;\n    rootFrame.Navigate(typeof(SharePage), e.ShareOperation);\n    Window.Current.Activate();\n}    You will need to add a new XAML page to the Microsoft.Knowzy.UWP project. Right click on the project and select  Add | New Item... . Choose the  Blank Page  template and name it  SharePage.xaml .    You will need to add the Sharing UI to the SharePage.xaml file. For now, use something like:  Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" Margin=\"12\" \n     StackPanel \n         Button Content=\"Share to Microsoft.Knowzy.WPF\" Click=\"ShareButton_Click\"/ \n         TextBlock x:Name=\"tbFileName\" / \n         Image x:Name=\"img\"/ \n     /StackPanel  /Grid     In the file SharePage.xaml.cs you will need to handle the OnNavigatedTo event. The NavigationEventArgs parameter will contain the shared image information. Display the shared image in the\nSharedPage UI. Pay attention to threading issues such as processing the image in a separate task. Also, you can only update the XAML UI image on the UI thread so you will need to use a dispacther to update the UI.  // add the following using directives\nusing System.Diagnostics;\nusing System.Threading.Tasks;\nusing Windows.ApplicationModel.DataTransfer;\nusing Windows.ApplicationModel.DataTransfer.ShareTarget;\nusing Windows.Storage;\nusing Windows.UI.Core;\nusing Windows.UI.Xaml.Media.Imaging;\n\n// add the following private members to the SharePage class\nprivate ShareOperation operation = null;\nprivate StorageFile file = null;\n\n// Add the following method to the SharePage class\nprotected override async void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        // It is recommended to only retrieve the ShareOperation object in the activation handler, return as\n        // quickly as possible, and retrieve all data from the share target asynchronously.\n        operation = (ShareOperation)args.Parameter;\n\n        await Task.Factory.StartNew(async () = \n        {\n            if (operation.Data.Contains(StandardDataFormats.StorageItems))\n            {\n                var storageItems = await operation.Data.GetStorageItemsAsync();\n                file = (StorageFile)(storageItems[0]);\n                var stream = await file.OpenReadAsync();\n                // Get back to the UI thread using the dispatcher.\n                await Dispatcher.RunAsync(CoreDispatcherPriority.Normal, async () = \n                {\n                    var image = new BitmapImage();\n                    img.Source = image;\n                    await image.SetSourceAsync(stream);\n                });\n            }\n        });\n    }\n}    Up to this point, the user has only shared the image with the UWP version of Knowzy. We need to share the image so it can be accessed by the WPF version of Knowzy. The SharePage UI includes a \"Share to Knowzy WPF\" \nbutton that will trigger this sharing operation. Add a \"ShareButton_Click\" event handler to SharePage.xaml.cs. Please note the location of the sharing folder. ApplicationData.Current.LocalFolder. More information on\nthis folder is available  here .  private async void ShareButton_Click(object sender, RoutedEventArgs e)\n{\n    if (file != null)\n    {\n        // copy file to app's local folder. Desktop Bridge app will detect new file with its FileWatcher\n        try\n        {\n            await file.CopyAsync(ApplicationData.Current.LocalFolder, file.Name, NameCollisionOption.ReplaceExisting);\n        }\n        catch (Exception ex)\n        {\n            Debug.WriteLine(\"ShareButton_Click Error:\" + ex.Message);\n        }\n    }\n\n    if (operation != null)\n    {\n        operation.ReportCompleted();\n    }\n}    Now that the image has been copied to the ApplicationData.Current.LocalFolder, the Knowzy WPF app needs to be able to detect that an image has been shared. \nWe will use a FileSystemWatcher to detect when an image has been to the ApplicationData.Current.LocalFolder. We will make this a feature that is only supported\nwhen the app is running as a Desktop Bridge app. Add the following code to Views\\MainView.xaml.cs in the Microsoft.Knowzy.WPF project:  using System;\nusing System.Diagnostics;\nusing System.IO;\nusing Microsoft.Knowzy.UwpHelpers;\n\npublic MainView()\n{\n    InitializeComponent();\n\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n    try\n        {\n            // get the path to the App folder (WPF or UWP).\n            var path = AppFolders.Local;\n            FileSystemWatcher watcher = new FileSystemWatcher(path);\n            watcher.EnableRaisingEvents = true;\n            watcher.Changed += Watcher_Changed;\n        }\n        catch(Exception ex)\n        {\n            Debug.WriteLine(\"FileSystemWatcher Error:\" + ex.Message);\n        }\n    }\n}    Add the FileSystemWatcher event handler to MainView.xaml.cs in the Microsoft.Knowzy.WPF project:  private void Watcher_Changed(object sender, FileSystemEventArgs e)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        if (File.Exists(e.FullPath))\n        {\n            var xml = \" toast visual binding template='ToastGeneric' image src='\" + e.FullPath + \"'/ text hint-maxLines='1' Microsoft.Knowzy.WPF received a new image /text /binding /visual /toast \";\n            Toast.CreateToast(xml);\n        }\n    }\n}    You will need to add a getter to AppFolders.cs in Microsoft.Knowzy.UwpHelpers to return the path to Windows.Storage.ApplicationData.Current.LocalFolder.   Add the following code to AppFolders.cs  public static string Local\n{\n    get\n    {\n        string path = null;\n        if (ExecutionMode.IsRunningAsUwp())\n        {\n            path = GetSafeAppxLocalFolder();\n        }\n        return path;\n    }\n}\n\ninternal static string GetSafeAppxLocalFolder()\n{\n    try\n    {\n        return Windows.Storage.ApplicationData.Current.LocalFolder.Path;\n    }\n    catch (Exception ex)\n    {\n        System.Diagnostics.Debug.WriteLine(ex.Message);\n    }\n    return null;\n}    Once you have made all of your changes to to code, build and run the Microsoft.Knowzy.Debug project.    Open an Windows 10 application that is capable of sharing a picture (Microsoft Edge). Navigate to a picture you want to share.    Right click on the image and select  Share picture     In the list of apps that are iamge share targets, select Microsoft.Know.UWP     The Microsoft.Knowzy.UWP SharePage will appear and display the image. Click on the  Share to Microsoft.Knowzy.WPF  button.     The FileSystemWatcher in the Microsoft.Knowzy.WPF app will be notified that a new image has been shared to the app. It will then display the toast with the image.     We will continue to add more Windows 10 UWP features to our app in the  next task .", 
            "title": "Task"
        }, 
        {
            "location": "/stories/2/222_Share/#references", 
            "text": "Share data    Sharing content target app sample      Sharing content source app sample    Adding UWP features to your existing PC software    WPF picture viewer as a share target", 
            "title": "References"
        }, 
        {
            "location": "/stories/2/222_Share/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/2/222_Share/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/2/223_AppServices/", 
            "text": "Task 2.2.3 -  Adding App Services to the Knowzy Desktop Bridge App\n\n\nOur development department has identified a problem with the Desktop Bridge version of the Knowzy app.\n\n\n\n\n\n\nThere appears to be no way to implement bi-directional communication between the WPF code and the UWP code of the Knowzy app.\n\n\n\n\n\n\nWe can send Uri protocol messages to the UWP code using Windows.System.Launcher.LaunchUriAsync(uri) but we can't receive a response.\n\n\n\n\n\n\nWindows.System.Launcher.LaunchUriForResultsAsync\n seems to be a solution as it returns a response to the request\nbut LaunchUriForResultsAsync is not supported in DesktopBridge applications.\n\n\n\n\n\n\n\n\n\n\nIt appears that a Windows 10 UWP \nApp Service\n will allow data to be shared between a UWP app and a WPF app. There is an example of \nthis sharing scenario \nhere\n \nin the \"Exposing an App Service\" section. However, this example requires that we move some of our WPF source code into the App Service. Also there is no example of \nhow to share data between the UWP and WPF portions of our app. \n\n\nHere is the problem with the communications between the WPF and UWP parts of our DeskTop Bridge app using an App Service.\n\n\n\n\n\n\nThe WPF app starts and connects to the App Service\n\n\n\n\n\n\n\n\nThe XAML UI starts up and connects to the App Service\n\n\n\n\n\n\n\n\nThe WPF app sends a request to the App Service. It can only receive a reply from the App Service. The request is not sent to the XAML UI.\nLikewise, if the XAML UI makes a request to the App Service, that request is not forwarded to the WPF app. Each app can only receive a reply from\nthe App Service. Each connection from an app to the App Service may also be running a separate instance of the App Servce so the two connections are not\naware of each other.\n\n\n\n\n\n\n\n\nThere is a solution to this problem if we make Microsoft.Knowzy.UWP.exe the startup app for our DeskTop Bridge app. However, we are not ready to make the UWP version since we have not ported the WPF UI to the UWP app.\nWe still need the WPF app to be the UI for our desktop bridge app. So we will need to modify our App Service to bridge the communication between the WPF and UWP portions of our Desktop Bridge app.\n\n\nRequirements for this task:\n\n\n\n\n\n\nCreate an App Service that enables the sharing of the Product information.\n\n\n\n\n\n\nShare Clown nose product information between the UWP XAML UI and the WPF Knowzy application.\n\n\n\n\n\n\nShare Clown nose product information from the WPF Knowzy application and an external Windows 10 UWP application.\n\n\n\n\n\n\nWe want to implement the following App Service  scenario:\n\n\n\n\n\n\nThe WPF app launches the Windows 10 App Service and registers itself to the App Service as a listener with a unique listener id.\n\n\n\n\n\n\n\n\nThe WPF app opens the UWP XAML UI using Windows.System.Launcher.LaunchUriAsync(uri) and sends the listener id as a parameter.\n\n\n\n\n\n\n\n\nThe UWP Xaml UI connects to the App Service, does its work, and sends the response data to the App Service along with the listener id.\n\n\n\n\n\n\n\n\nThe App Service sends the response data to the listener with the specified listener id.\n\n\n\n\n\n\n\n\nOur research has found a starting point for the App Service idea \nhere\n.\nYou will need to modify this code to enable bi-directional communication between the UWP Xaml ui and the WPF application code.\n\n\nWe also found some App Service sample code \nhere\n.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 2.2.1\n and all of it's prerequisites\n\n\nSince this will be quite a complicated task, it is recommended that you work through the \nCreate and consume an app service tutorial\n.\nThis tutorial will familiarize you with the following:\n\n\n\n\n\n\nHow to create an App Service project and add it to your solution.\n\n\n\n\n\n\nHow to specify the App Service in the Package.appxmanifest.\n\n\n\n\n\n\nHow to open a connection to an App Service.\n\n\n\n\n\n\nHow to send a request to an App Service.\n\n\n\n\n\n\nHow to receive a message from an App Service.\n\n\n\n\n\n\nOnce you have completed the tutorial, you will be ready to add an App Service to the Knowzy DeskTop Bridge app.\n\n\n\n\nMake sure the Microsoft.Knowzy.WPF.sln Build configuration to \nDebug | x86\n\n\n\n\n\n\n\n\nSet the \nMicrosoft.Knowzy.Debug\n project as the startup project.\n\n\n\n\nTask\n\n\nCreate the App Service Project\n\n\n\n\n\n\nRight-click on the src folder in the Microsoft.Knowzy.WPF solution and select \nAdd | New Project...\n\n\n\n\n\n\nSelect the \nVisual C# | Windows Univeral | Windows Runtime Component (Univeral Windows)\n project template.\n\n\n\n\n\n\nMake sure you are creating the project in the \nsrc\n folder and name the project \nMicrosoft.Knowzy.AppService\n.\n\n\n\n\n\n\n\n\nRename the Class1.cs file in the Microsoft.Knowzy.AppService project to AppServiceTask.cs\n\n\n\n\n\n\nAdd the following using directives to AppServiceTask.cs:\n\n\nusing Windows.ApplicationModel.AppService;\nusing Windows.ApplicationModel.Background;\n\n\n\n\n\n\n\nAdd the following boilerplate AppService code to AppServiceTask.cs\n\n\nnamespace Microsoft.Knowzy.AppService\n{\n    public sealed class AppServiceTask : IBackgroundTask\n    {\n        private BackgroundTaskDeferral backgroundTaskDeferral;\n        private AppServiceConnection appServiceconnection;\n\n        public void Run(IBackgroundTaskInstance taskInstance)\n        {\n            this.backgroundTaskDeferral = taskInstance.GetDeferral(); // Get a deferral so that the service isn't terminated.\n            taskInstance.Canceled += OnTaskCanceled; // Associate a cancellation handler with the background task.\n\n            // Retrieve the app service connection and set up a listener for incoming app service requests.\n            var details = taskInstance.TriggerDetails as AppServiceTriggerDetails;\n            appServiceconnection = details.AppServiceConnection;\n            appServiceconnection.RequestReceived += OnRequestReceived;\n        }\n\n        private async void OnRequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n        {\n        }\n\n        private void OnTaskCanceled(IBackgroundTaskInstance sender, BackgroundTaskCancellationReason reason)\n        {\n            if (this.backgroundTaskDeferral != null)\n            {\n                // Complete the service deferral.\n                this.backgroundTaskDeferral.Complete();\n            }\n        }\n    }\n}\n\n\n\n\n\n\n\nBuild your solution and fix any compilation errors in the App Service code.\n\n\n\n\n\n\nAdd the App Service to the Package.appxmanifest\n\n\n\n\n\n\nOpen the Package.appxmanifest file in the Microsoft.Knowzy.UWP project by right-clicking on the file and select \nView Code\n.\n\n\n\n\n\n\nAdd the following xml to the Extensions section.\n\n\nuap:Extension Category=\"windows.appService\" EntryPoint=\"Microsoft.Knowzy.AppService.AppServiceTask\"\n\n\nuap:AppService Name=\"com.microsoft.knowzy.appservice\" uap4:SupportsMultipleInstances=\"false\"/\n\n\n/uap:Extension\n\n\n\n\n\n\n\n\nIf necessary, add the following xmlns declaration to the Package tag\n\n\nxmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"\n\n\n\n\n\n\n\nAdd a project reference to Microsoft.Knowzy.AppService\n\n\n\n\n\n\nRight-click on the Microsoft.Knowzy.UWP project and select \nAdd | Reference...\n\n\n\n\n\n\nSelect the \nMicrosoft.Knowzy.AppService\n project under the \nProjects | Solution\n section. \n\n\n\n\n\n\nThe Microsoft.Knowzy.AppService will now be part of the Knowzy UWP AppX package after a build.\n\n\n\n\n\n\nAdd a AppService helper class to Microsoft.Knowzy.UwpHelpers\n\n\n\n\n\n\nAdd a new C# class called AppService.cs to the  Microsoft.Knowzy.UwpHelpers project.\n\n\n\n\n\n\nAdd the following using directives to AppService.cs\n\n\nusing Windows.ApplicationModel.AppService;\nusing Windows.Foundation.Collections;\n\n\n\n\n\n\n\nAdd the following code to AppService.cs. This code creates a connection to the App Service and registers the connection as a listener for messages with a specific id. Whenever the\nApp Service receives a message with the specified id, it will call the Connection_RequestReceived method with the message.\n\n\npublic class AppService\n{\n    private AppServiceConnection _connection = null;\n    private String _listenerId;\n\n    public AppService()\n    {\n    }\n\n    public async Task\nbool\n StartAppServiceConnection(String listenerId)\n    {\n        var result = false;\n        if (_connection != null)\n        {\n            _connection.Dispose();\n            _connection = null;\n        }\n\n        // Open a connection to the App Service\n        _listenerId = listenerId;\n        _connection = new AppServiceConnection();\n        _connection.AppServiceName = \"com.microsoft.knowzy.appservice\";\n        _connection.PackageFamilyName = Windows.ApplicationModel.Package.Current.Id.FamilyName;\n        _connection.RequestReceived += Connection_RequestReceived;\n        _connection.ServiceClosed += Connection_ServiceClosed;\n        AppServiceConnectionStatus status = await _connection.OpenAsync();\n        if (status == AppServiceConnectionStatus.Success)\n        {\n            // register this App Service Connection as a listener\n            ValueSet registerData = new ValueSet();\n            registerData.Add(\"Type\", \"Register\");\n            registerData.Add(\"Id\", listenerId);\n            var response = await _connection.SendMessageAsync(registerData);\n            if (response.Status == AppServiceResponseStatus.Success)\n            {\n                var message = response.Message;\n                result = message.ContainsKey(\"Status\") \n message[\"Status\"].ToString() == \"OK\";\n            }\n        }\n        return result;\n    }\n\n    private async void Connection_RequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n    {\n        var messageDeferral = args.GetDeferral();\n        ValueSet returnData = new ValueSet();\n        returnData.Add(\"Status\", \"OK\");\n        returnData.Add(\"Data\", \"Knowzy WPF app received message: \" + args.Request.Message[\"Data\"]);\n        await args.Request.SendResponseAsync(returnData);\n        messageDeferral.Complete(); // Complete the deferral so that the platform knows that we're done responding to the app service call.\n    }\n\n    private void Connection_ServiceClosed(AppServiceConnection sender, AppServiceClosedEventArgs args)\n    {\n        _connection.Dispose();\n        _connection = null;\n    }\n}\n\n\n\n\n\n\n\nAdd Listener support to the App Service\n\n\nWe will now modify the Microsoft.Knowzy.AppService component to support the adding and removing of connection listeners\n\n\n\n\n\n\nIf necessary, add the following using directive to AppServiceTask.cs in the Microsoft.Knowzy.AppService project:\n\n\nusing System.Collections.Generic;\nusing System.Threading;\nusing Windows.Foundation.Collections;\n\n\n\n\n\n\n\nAdd the following private members to the AppServiceTask class.\n\n\n// Map of AppService message Listeners\nprivate static IDictionary\nstring, AppServiceConnection\n _connectionMap = new Dictionary\nstring, AppServiceConnection\n();\n\n// Mutex to protect access to _connectionMap\nprivate static Mutex _mutex = new Mutex();\n\n\n\n\n\n\n\nAdd methods to add and remove a listener connection. We use a mutex to protect access to the connection Dictionary\n\n\nprivate void AddListener(String id, AppServiceConnection connection)\n{\n    _mutex.WaitOne();\n    _connectionMap[id] = connection;\n    _mutex.ReleaseMutex();\n}\n\nprivate void RemoveListener(String id)\n{\n    _mutex.WaitOne();\n    if (_connectionMap.ContainsKey(id))\n    {\n        _connectionMap.Remove(id);\n    }\n    _mutex.ReleaseMutex();\n}\n\n\n\n\n\n\n\nAdd a method to handle sending a message to a listener. This method will wait for the response from the listener and return the response to the caller.\n\n\nprivate async Task\nValueSet\n SendMessage(String id, ValueSet message)\n{\n    String errorMessage = \"\";\n\n    _mutex.WaitOne();\n    AppServiceConnection appServiceConnection = null;\n    if (_connectionMap.ContainsKey(id))\n    {\n        appServiceConnection = _connectionMap[id];\n    }\n    _mutex.ReleaseMutex();\n\n    if (appServiceConnection != null)\n    {\n        var response = await appServiceConnection.SendMessageAsync(message);\n        if (response.Status == AppServiceResponseStatus.Success)\n        {\n            return response.Message;\n        }\n        else\n        {\n            errorMessage = \"SendMessageAsync result: \" + response.Status;\n        }\n    }\n    else\n    {\n        errorMessage = \"No registered Listener for Id: \" + id;\n    }\n\n    // build the error response\n    ValueSet error = new ValueSet();\n    error.Add(\"Status\", \"Error\");\n    error.Add(\"ErrorMessage\", errorMessage);\n    return error;\n}\n\n\n\n\n\n\n\nUpdate the OnRequestReceived method to handle listener registration and the sending messages to listeners.\n\n\nasync void OnRequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n{\n    // Get a deferral because we use an awaitable API below to respond to the message\n    // and we don't want this call to get cancelled while we are waiting.\n    var messageDeferral = args.GetDeferral();\n\n    var message = args.Request.Message;\n    ValueSet response = new ValueSet();\n\n    if (message.ContainsKey(\"Type\") \n message.ContainsKey(\"Id\"))\n    {\n        var type = message[\"Type\"];\n        var id = message[\"Id\"].ToString();\n        switch (type)\n        {\n            case \"Register\":\n                AddListener(id, sender);\n                response.Add(\"Status\", \"OK\");\n                break;\n\n            case \"Unregister\":\n                RemoveListener(id);\n                response.Add(\"Status\", \"OK\");\n                break;\n\n            case \"Message\":\n                response = await SendMessage(id, message);\n                break;\n\n            default:\n                response.Add(\"Status\", \"Error\");\n                response.Add(\"ErrorMessage\", \"Unknown KnowzyAppServiceMessage type\");\n                break;\n        }\n    }\n    else\n    {\n        response.Add(\"Status\", \"Error\");\n        response.Add(\"ErrorMessage\", \"Missing valid Type or Id parameters\");\n    }\n\n    await args.Request.SendResponseAsync(response);\n    messageDeferral.Complete(); // Complete the deferral so that the platform knows that we're done responding to the app service call.\n}\n\n\n\n\n\n\n\nEnable Microsoft.Knowzy.WPF to use the App Service\n\n\n\n\n\n\nAdd a Click event to the Menu Menu in Views\\MainView.xaml in the Microsoft.Knowzy.WPF project near line 42.\n\n\nMenuItem Header=\"{x:Static localization:Resources.Menu_Menu}\" Template=\"{DynamicResource MenuItemControlTemplate}\" Click=\"Menu_Click\"/\n\n\n\n\n\n\n\n\nAdd the Menu_Click handler in MainView.xaml.cs in the Microsoft.Knowzy.WPF project.\n\n\nAppService _appService = null;\n\nprivate async void Menu_Click(object sender, EventArgs e)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        if(_appService == null)\n        {\n            // start the app service\n            _appService = new AppService();\n            var result = await _appService.StartAppServiceConnection(\"com.microsoft.knowzy.appservice.test\");\n        }\n\n        // start the XAML UI that will communicate with the App Service\n        Uri uri = new Uri(\"com.microsoft.knowzy.protocol.test://\" + \"message?appserviceid=\" + \"com.microsoft.knowzy.appservice.test\");\n        await UriProtocol.SendUri(uri);\n    }\n}\n\n\n\n\n\n\n\nThis code will open a connection to the Knowzy App Service and will also open the Xaml AppServiceTest page in the UWP portion of Knowzy. The AppServiceTest page will connect to the AppService and send a message\nto the WPF app through the AppService when the use clicks on the Connect button. The WPF app will echo the message and send it back to the UWP app through the App Service.\n\n\nAdd the new Uri protocol to package.appxmanifest in the Microsoft.Knowzy.UWP project\n\n\nuap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\"\n\n\nuap:Protocol Name=\"com.microsoft.knowzy.protocol.test\" /\n\n\n/uap:Extension\n\n\n\n\nAdd the XAML ui page that will communicate with the App Service\n\n\n\n\n\n\nAdd a new XAML page to Microsoft.Knowzy.UWP project. Name the page AppServiceTest.xaml.\n\n\n\n\n\n\nAdd some XAML UI elements to AppServiceTest.xaml\n\n\nGrid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" Margin=\"12\"\n\n    \nStackPanel Orientation=\"Vertical\"\n\n        \nTextBox Name=\"textBox\" /\n\n        \nButton Content=\"Connect\" Click=\"Button_Click\" /\n\n    \n/StackPanel\n\n\n/Grid\n\n\n\n\n\n\n\n\nModify the OnActivated() method in App.xaml.cs in the Microsoft.Knowzy.UWP project as follows:\n\n\nprotected override void OnActivated(IActivatedEventArgs args)\n{\n    if (args.Kind == ActivationKind.Protocol)\n    {\n        ProtocolActivatedEventArgs eventArgs = args as ProtocolActivatedEventArgs;\n        // TODO: Handle URI activation\n        // The received URI is eventArgs.Uri.AbsoluteUri\n\n        Uri uri = eventArgs.Uri;\n        if (uri.Scheme == \"com.microsoft.knowzy.protocol.3d\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(MainPage), uri.Query);\n            Window.Current.Activate();\n        }\n        else if (uri.Scheme == \"com.microsoft.knowzy.protocol.test\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(AppServiceTest), uri.Query);\n            Window.Current.Activate();\n        }\n    }\n}\n\n\n\n\n\n\n\nAdd the following using directive to AppServiceTest.xaml.cs\n\n\nusing Windows.ApplicationModel.AppService;\n\n\n\n\n\n\n\nAdd the following properties to the AppServiceTest class:\n\n\nprivate String _connectionId;\nprivate AppServiceConnection _connection = null;\n\n\n\n\n\n\n\nAdd the uri protocol handler to parse the appserviceid from the uri.\n\n\nprotected override void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        WwwFormUrlDecoder decoder = new WwwFormUrlDecoder(args.Parameter.ToString());\n        try\n        {\n            _connectionId = decoder.GetFirstValueByName(\"appserviceid\");\n        }\n        catch (Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine(\"AppServiceTest OnNavigatedTo Error: \" + ex.Message);\n        }\n    }\n}\n\n\n\n\n\n\n\nAdd the Button_Click handler\n\n\nprivate async void Button_Click(object sender, RoutedEventArgs e)\n{\n    if (_connection == null)\n    {\n        _connection = new AppServiceConnection();\n\n        // Here, we use the app service name defined in the app service provider's Package.appxmanifest file in the \nExtension\n section.\n        _connection.AppServiceName = \"com.microsoft.knowzy.appservice\"; ;\n\n        // Use Windows.ApplicationModel.Package.Current.Id.FamilyName within the app service provider to get this value.\n        _connection.PackageFamilyName = Windows.ApplicationModel.Package.Current.Id.FamilyName;\n\n        var status = await _connection.OpenAsync();\n        if (status != AppServiceConnectionStatus.Success)\n        {\n            textBox.Text = \"Failed to connect \" + status;\n            return;\n        }\n    }\n\n    ValueSet data = new ValueSet();\n    data.Add(\"Type\", \"Message\");\n    data.Add(\"Id\", _connectionId);\n    data.Add(\"Data\", \"Message from AppServiceTest XAML UI\");\n    textBox.Text = \"Sending message to App Service connection listener: \" + _connectionId;\n\n    var response = await _connection.SendMessageAsync(data);\n    if (response.Status == AppServiceResponseStatus.Success)\n    {\n        var message = response.Message;\n        bool result = message.ContainsKey(\"Status\") \n message[\"Status\"].ToString() == \"OK\";\n        if (result)\n        {\n            textBox.Text = message[\"Data\"] as String;\n        }\n        else if (message.ContainsKey(\"ErrorMessage\"))\n        {\n            textBox.Text = message[\"ErrorMessage\"] as String;\n        }\n    }\n    else\n    {\n        textBox.Text = \"App Service connection error: \" + response.Status;\n    }\n}\n\n\n\n\n\n\n\nBuild and run the Knowzy app by starting the Microsoft.Knowzy.Debug project.\n\n\n\n\n\n\nClick on the \nMenu\n menu item.\n\n\n\n\n\n\nWhen the AppServiceTest windows appears, click on the \nConnect\n button.\n\n\n\n\n\n\nThe following things should now happen\n\n\n\n\n\n\nThe UWP app will send a message to the AppService\n\n\n\n\n\n\nThe AppService wil forward the event to the WPF via its listener connection\n\n\n\n\n\n\nThe WPF responds to the message and send the result back to the App Service\n\n\n\n\n\n\nThe App Service returns the result from the WPF app back to the UWP app\n\n\n\n\n\n\nThe UWP app displays the result it received from the WPF app.\n\n\n\n\n\n\n\n\n\n\n\n\nYou have now successfully developed a solution for communicating between the UWP and WPF portions of your Desktop Bridge app using an App Service.\n\n\nReferences\n\n\n\n\n\n\nCreate and consume an app service\n\n\n\n\n\n\nApp services sample\n\n\n\n\n\n\nAdding UWP features to your existing PC software\n\n\n\n\n\n\nThe solution for this task is located \nhere\n\n\ncontinue to \nnext task", 
            "title": "223 AppServices"
        }, 
        {
            "location": "/stories/2/223_AppServices/#task-223-adding-app-services-to-the-knowzy-desktop-bridge-app", 
            "text": "Our development department has identified a problem with the Desktop Bridge version of the Knowzy app.    There appears to be no way to implement bi-directional communication between the WPF code and the UWP code of the Knowzy app.    We can send Uri protocol messages to the UWP code using Windows.System.Launcher.LaunchUriAsync(uri) but we can't receive a response.    Windows.System.Launcher.LaunchUriForResultsAsync  seems to be a solution as it returns a response to the request\nbut LaunchUriForResultsAsync is not supported in DesktopBridge applications.      It appears that a Windows 10 UWP  App Service  will allow data to be shared between a UWP app and a WPF app. There is an example of \nthis sharing scenario  here  \nin the \"Exposing an App Service\" section. However, this example requires that we move some of our WPF source code into the App Service. Also there is no example of \nhow to share data between the UWP and WPF portions of our app.   Here is the problem with the communications between the WPF and UWP parts of our DeskTop Bridge app using an App Service.    The WPF app starts and connects to the App Service     The XAML UI starts up and connects to the App Service     The WPF app sends a request to the App Service. It can only receive a reply from the App Service. The request is not sent to the XAML UI.\nLikewise, if the XAML UI makes a request to the App Service, that request is not forwarded to the WPF app. Each app can only receive a reply from\nthe App Service. Each connection from an app to the App Service may also be running a separate instance of the App Servce so the two connections are not\naware of each other.     There is a solution to this problem if we make Microsoft.Knowzy.UWP.exe the startup app for our DeskTop Bridge app. However, we are not ready to make the UWP version since we have not ported the WPF UI to the UWP app.\nWe still need the WPF app to be the UI for our desktop bridge app. So we will need to modify our App Service to bridge the communication between the WPF and UWP portions of our Desktop Bridge app.  Requirements for this task:    Create an App Service that enables the sharing of the Product information.    Share Clown nose product information between the UWP XAML UI and the WPF Knowzy application.    Share Clown nose product information from the WPF Knowzy application and an external Windows 10 UWP application.    We want to implement the following App Service  scenario:    The WPF app launches the Windows 10 App Service and registers itself to the App Service as a listener with a unique listener id.     The WPF app opens the UWP XAML UI using Windows.System.Launcher.LaunchUriAsync(uri) and sends the listener id as a parameter.     The UWP Xaml UI connects to the App Service, does its work, and sends the response data to the App Service along with the listener id.     The App Service sends the response data to the listener with the specified listener id.     Our research has found a starting point for the App Service idea  here .\nYou will need to modify this code to enable bi-directional communication between the UWP Xaml ui and the WPF application code.  We also found some App Service sample code  here .", 
            "title": "Task 2.2.3 -  Adding App Services to the Knowzy Desktop Bridge App"
        }, 
        {
            "location": "/stories/2/223_AppServices/#prerequisites", 
            "text": "This task has a dependency on  Task 2.2.1  and all of it's prerequisites  Since this will be quite a complicated task, it is recommended that you work through the  Create and consume an app service tutorial .\nThis tutorial will familiarize you with the following:    How to create an App Service project and add it to your solution.    How to specify the App Service in the Package.appxmanifest.    How to open a connection to an App Service.    How to send a request to an App Service.    How to receive a message from an App Service.    Once you have completed the tutorial, you will be ready to add an App Service to the Knowzy DeskTop Bridge app.   Make sure the Microsoft.Knowzy.WPF.sln Build configuration to  Debug | x86     Set the  Microsoft.Knowzy.Debug  project as the startup project.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/2/223_AppServices/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/2/223_AppServices/#create-the-app-service-project", 
            "text": "Right-click on the src folder in the Microsoft.Knowzy.WPF solution and select  Add | New Project...    Select the  Visual C# | Windows Univeral | Windows Runtime Component (Univeral Windows)  project template.    Make sure you are creating the project in the  src  folder and name the project  Microsoft.Knowzy.AppService .     Rename the Class1.cs file in the Microsoft.Knowzy.AppService project to AppServiceTask.cs    Add the following using directives to AppServiceTask.cs:  using Windows.ApplicationModel.AppService;\nusing Windows.ApplicationModel.Background;    Add the following boilerplate AppService code to AppServiceTask.cs  namespace Microsoft.Knowzy.AppService\n{\n    public sealed class AppServiceTask : IBackgroundTask\n    {\n        private BackgroundTaskDeferral backgroundTaskDeferral;\n        private AppServiceConnection appServiceconnection;\n\n        public void Run(IBackgroundTaskInstance taskInstance)\n        {\n            this.backgroundTaskDeferral = taskInstance.GetDeferral(); // Get a deferral so that the service isn't terminated.\n            taskInstance.Canceled += OnTaskCanceled; // Associate a cancellation handler with the background task.\n\n            // Retrieve the app service connection and set up a listener for incoming app service requests.\n            var details = taskInstance.TriggerDetails as AppServiceTriggerDetails;\n            appServiceconnection = details.AppServiceConnection;\n            appServiceconnection.RequestReceived += OnRequestReceived;\n        }\n\n        private async void OnRequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n        {\n        }\n\n        private void OnTaskCanceled(IBackgroundTaskInstance sender, BackgroundTaskCancellationReason reason)\n        {\n            if (this.backgroundTaskDeferral != null)\n            {\n                // Complete the service deferral.\n                this.backgroundTaskDeferral.Complete();\n            }\n        }\n    }\n}    Build your solution and fix any compilation errors in the App Service code.", 
            "title": "Create the App Service Project"
        }, 
        {
            "location": "/stories/2/223_AppServices/#add-the-app-service-to-the-packageappxmanifest", 
            "text": "Open the Package.appxmanifest file in the Microsoft.Knowzy.UWP project by right-clicking on the file and select  View Code .    Add the following xml to the Extensions section.  uap:Extension Category=\"windows.appService\" EntryPoint=\"Microsoft.Knowzy.AppService.AppServiceTask\"  uap:AppService Name=\"com.microsoft.knowzy.appservice\" uap4:SupportsMultipleInstances=\"false\"/  /uap:Extension     If necessary, add the following xmlns declaration to the Package tag  xmlns:uap4=\"http://schemas.microsoft.com/appx/manifest/uap/windows10/4\"", 
            "title": "Add the App Service to the Package.appxmanifest"
        }, 
        {
            "location": "/stories/2/223_AppServices/#add-a-project-reference-to-microsoftknowzyappservice", 
            "text": "Right-click on the Microsoft.Knowzy.UWP project and select  Add | Reference...    Select the  Microsoft.Knowzy.AppService  project under the  Projects | Solution  section.     The Microsoft.Knowzy.AppService will now be part of the Knowzy UWP AppX package after a build.", 
            "title": "Add a project reference to Microsoft.Knowzy.AppService"
        }, 
        {
            "location": "/stories/2/223_AppServices/#add-a-appservice-helper-class-to-microsoftknowzyuwphelpers", 
            "text": "Add a new C# class called AppService.cs to the  Microsoft.Knowzy.UwpHelpers project.    Add the following using directives to AppService.cs  using Windows.ApplicationModel.AppService;\nusing Windows.Foundation.Collections;    Add the following code to AppService.cs. This code creates a connection to the App Service and registers the connection as a listener for messages with a specific id. Whenever the\nApp Service receives a message with the specified id, it will call the Connection_RequestReceived method with the message.  public class AppService\n{\n    private AppServiceConnection _connection = null;\n    private String _listenerId;\n\n    public AppService()\n    {\n    }\n\n    public async Task bool  StartAppServiceConnection(String listenerId)\n    {\n        var result = false;\n        if (_connection != null)\n        {\n            _connection.Dispose();\n            _connection = null;\n        }\n\n        // Open a connection to the App Service\n        _listenerId = listenerId;\n        _connection = new AppServiceConnection();\n        _connection.AppServiceName = \"com.microsoft.knowzy.appservice\";\n        _connection.PackageFamilyName = Windows.ApplicationModel.Package.Current.Id.FamilyName;\n        _connection.RequestReceived += Connection_RequestReceived;\n        _connection.ServiceClosed += Connection_ServiceClosed;\n        AppServiceConnectionStatus status = await _connection.OpenAsync();\n        if (status == AppServiceConnectionStatus.Success)\n        {\n            // register this App Service Connection as a listener\n            ValueSet registerData = new ValueSet();\n            registerData.Add(\"Type\", \"Register\");\n            registerData.Add(\"Id\", listenerId);\n            var response = await _connection.SendMessageAsync(registerData);\n            if (response.Status == AppServiceResponseStatus.Success)\n            {\n                var message = response.Message;\n                result = message.ContainsKey(\"Status\")   message[\"Status\"].ToString() == \"OK\";\n            }\n        }\n        return result;\n    }\n\n    private async void Connection_RequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n    {\n        var messageDeferral = args.GetDeferral();\n        ValueSet returnData = new ValueSet();\n        returnData.Add(\"Status\", \"OK\");\n        returnData.Add(\"Data\", \"Knowzy WPF app received message: \" + args.Request.Message[\"Data\"]);\n        await args.Request.SendResponseAsync(returnData);\n        messageDeferral.Complete(); // Complete the deferral so that the platform knows that we're done responding to the app service call.\n    }\n\n    private void Connection_ServiceClosed(AppServiceConnection sender, AppServiceClosedEventArgs args)\n    {\n        _connection.Dispose();\n        _connection = null;\n    }\n}", 
            "title": "Add a AppService helper class to Microsoft.Knowzy.UwpHelpers"
        }, 
        {
            "location": "/stories/2/223_AppServices/#add-listener-support-to-the-app-service", 
            "text": "We will now modify the Microsoft.Knowzy.AppService component to support the adding and removing of connection listeners    If necessary, add the following using directive to AppServiceTask.cs in the Microsoft.Knowzy.AppService project:  using System.Collections.Generic;\nusing System.Threading;\nusing Windows.Foundation.Collections;    Add the following private members to the AppServiceTask class.  // Map of AppService message Listeners\nprivate static IDictionary string, AppServiceConnection  _connectionMap = new Dictionary string, AppServiceConnection ();\n\n// Mutex to protect access to _connectionMap\nprivate static Mutex _mutex = new Mutex();    Add methods to add and remove a listener connection. We use a mutex to protect access to the connection Dictionary  private void AddListener(String id, AppServiceConnection connection)\n{\n    _mutex.WaitOne();\n    _connectionMap[id] = connection;\n    _mutex.ReleaseMutex();\n}\n\nprivate void RemoveListener(String id)\n{\n    _mutex.WaitOne();\n    if (_connectionMap.ContainsKey(id))\n    {\n        _connectionMap.Remove(id);\n    }\n    _mutex.ReleaseMutex();\n}    Add a method to handle sending a message to a listener. This method will wait for the response from the listener and return the response to the caller.  private async Task ValueSet  SendMessage(String id, ValueSet message)\n{\n    String errorMessage = \"\";\n\n    _mutex.WaitOne();\n    AppServiceConnection appServiceConnection = null;\n    if (_connectionMap.ContainsKey(id))\n    {\n        appServiceConnection = _connectionMap[id];\n    }\n    _mutex.ReleaseMutex();\n\n    if (appServiceConnection != null)\n    {\n        var response = await appServiceConnection.SendMessageAsync(message);\n        if (response.Status == AppServiceResponseStatus.Success)\n        {\n            return response.Message;\n        }\n        else\n        {\n            errorMessage = \"SendMessageAsync result: \" + response.Status;\n        }\n    }\n    else\n    {\n        errorMessage = \"No registered Listener for Id: \" + id;\n    }\n\n    // build the error response\n    ValueSet error = new ValueSet();\n    error.Add(\"Status\", \"Error\");\n    error.Add(\"ErrorMessage\", errorMessage);\n    return error;\n}    Update the OnRequestReceived method to handle listener registration and the sending messages to listeners.  async void OnRequestReceived(AppServiceConnection sender, AppServiceRequestReceivedEventArgs args)\n{\n    // Get a deferral because we use an awaitable API below to respond to the message\n    // and we don't want this call to get cancelled while we are waiting.\n    var messageDeferral = args.GetDeferral();\n\n    var message = args.Request.Message;\n    ValueSet response = new ValueSet();\n\n    if (message.ContainsKey(\"Type\")   message.ContainsKey(\"Id\"))\n    {\n        var type = message[\"Type\"];\n        var id = message[\"Id\"].ToString();\n        switch (type)\n        {\n            case \"Register\":\n                AddListener(id, sender);\n                response.Add(\"Status\", \"OK\");\n                break;\n\n            case \"Unregister\":\n                RemoveListener(id);\n                response.Add(\"Status\", \"OK\");\n                break;\n\n            case \"Message\":\n                response = await SendMessage(id, message);\n                break;\n\n            default:\n                response.Add(\"Status\", \"Error\");\n                response.Add(\"ErrorMessage\", \"Unknown KnowzyAppServiceMessage type\");\n                break;\n        }\n    }\n    else\n    {\n        response.Add(\"Status\", \"Error\");\n        response.Add(\"ErrorMessage\", \"Missing valid Type or Id parameters\");\n    }\n\n    await args.Request.SendResponseAsync(response);\n    messageDeferral.Complete(); // Complete the deferral so that the platform knows that we're done responding to the app service call.\n}", 
            "title": "Add Listener support to the App Service"
        }, 
        {
            "location": "/stories/2/223_AppServices/#enable-microsoftknowzywpf-to-use-the-app-service", 
            "text": "Add a Click event to the Menu Menu in Views\\MainView.xaml in the Microsoft.Knowzy.WPF project near line 42.  MenuItem Header=\"{x:Static localization:Resources.Menu_Menu}\" Template=\"{DynamicResource MenuItemControlTemplate}\" Click=\"Menu_Click\"/     Add the Menu_Click handler in MainView.xaml.cs in the Microsoft.Knowzy.WPF project.  AppService _appService = null;\n\nprivate async void Menu_Click(object sender, EventArgs e)\n{\n    if (ExecutionMode.IsRunningAsUwp())\n    {\n        if(_appService == null)\n        {\n            // start the app service\n            _appService = new AppService();\n            var result = await _appService.StartAppServiceConnection(\"com.microsoft.knowzy.appservice.test\");\n        }\n\n        // start the XAML UI that will communicate with the App Service\n        Uri uri = new Uri(\"com.microsoft.knowzy.protocol.test://\" + \"message?appserviceid=\" + \"com.microsoft.knowzy.appservice.test\");\n        await UriProtocol.SendUri(uri);\n    }\n}    This code will open a connection to the Knowzy App Service and will also open the Xaml AppServiceTest page in the UWP portion of Knowzy. The AppServiceTest page will connect to the AppService and send a message\nto the WPF app through the AppService when the use clicks on the Connect button. The WPF app will echo the message and send it back to the UWP app through the App Service.", 
            "title": "Enable Microsoft.Knowzy.WPF to use the App Service"
        }, 
        {
            "location": "/stories/2/223_AppServices/#add-the-new-uri-protocol-to-packageappxmanifest-in-the-microsoftknowzyuwp-project", 
            "text": "uap:Extension Category=\"windows.protocol\" Executable=\"Microsoft.Knowzy.UWP.exe\" EntryPoint=\"Microsoft.Knowzy.UWP.App\"  uap:Protocol Name=\"com.microsoft.knowzy.protocol.test\" /  /uap:Extension", 
            "title": "Add the new Uri protocol to package.appxmanifest in the Microsoft.Knowzy.UWP project"
        }, 
        {
            "location": "/stories/2/223_AppServices/#add-the-xaml-ui-page-that-will-communicate-with-the-app-service", 
            "text": "Add a new XAML page to Microsoft.Knowzy.UWP project. Name the page AppServiceTest.xaml.    Add some XAML UI elements to AppServiceTest.xaml  Grid Background=\"{ThemeResource ApplicationPageBackgroundThemeBrush}\" Margin=\"12\" \n     StackPanel Orientation=\"Vertical\" \n         TextBox Name=\"textBox\" / \n         Button Content=\"Connect\" Click=\"Button_Click\" / \n     /StackPanel  /Grid     Modify the OnActivated() method in App.xaml.cs in the Microsoft.Knowzy.UWP project as follows:  protected override void OnActivated(IActivatedEventArgs args)\n{\n    if (args.Kind == ActivationKind.Protocol)\n    {\n        ProtocolActivatedEventArgs eventArgs = args as ProtocolActivatedEventArgs;\n        // TODO: Handle URI activation\n        // The received URI is eventArgs.Uri.AbsoluteUri\n\n        Uri uri = eventArgs.Uri;\n        if (uri.Scheme == \"com.microsoft.knowzy.protocol.3d\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(MainPage), uri.Query);\n            Window.Current.Activate();\n        }\n        else if (uri.Scheme == \"com.microsoft.knowzy.protocol.test\")\n        {\n            Frame rootFrame = new Frame();\n            Window.Current.Content = rootFrame;\n            rootFrame.Navigate(typeof(AppServiceTest), uri.Query);\n            Window.Current.Activate();\n        }\n    }\n}    Add the following using directive to AppServiceTest.xaml.cs  using Windows.ApplicationModel.AppService;    Add the following properties to the AppServiceTest class:  private String _connectionId;\nprivate AppServiceConnection _connection = null;    Add the uri protocol handler to parse the appserviceid from the uri.  protected override void OnNavigatedTo(NavigationEventArgs args)\n{\n    if (args.Parameter != null)\n    {\n        WwwFormUrlDecoder decoder = new WwwFormUrlDecoder(args.Parameter.ToString());\n        try\n        {\n            _connectionId = decoder.GetFirstValueByName(\"appserviceid\");\n        }\n        catch (Exception ex)\n        {\n            System.Diagnostics.Debug.WriteLine(\"AppServiceTest OnNavigatedTo Error: \" + ex.Message);\n        }\n    }\n}    Add the Button_Click handler  private async void Button_Click(object sender, RoutedEventArgs e)\n{\n    if (_connection == null)\n    {\n        _connection = new AppServiceConnection();\n\n        // Here, we use the app service name defined in the app service provider's Package.appxmanifest file in the  Extension  section.\n        _connection.AppServiceName = \"com.microsoft.knowzy.appservice\"; ;\n\n        // Use Windows.ApplicationModel.Package.Current.Id.FamilyName within the app service provider to get this value.\n        _connection.PackageFamilyName = Windows.ApplicationModel.Package.Current.Id.FamilyName;\n\n        var status = await _connection.OpenAsync();\n        if (status != AppServiceConnectionStatus.Success)\n        {\n            textBox.Text = \"Failed to connect \" + status;\n            return;\n        }\n    }\n\n    ValueSet data = new ValueSet();\n    data.Add(\"Type\", \"Message\");\n    data.Add(\"Id\", _connectionId);\n    data.Add(\"Data\", \"Message from AppServiceTest XAML UI\");\n    textBox.Text = \"Sending message to App Service connection listener: \" + _connectionId;\n\n    var response = await _connection.SendMessageAsync(data);\n    if (response.Status == AppServiceResponseStatus.Success)\n    {\n        var message = response.Message;\n        bool result = message.ContainsKey(\"Status\")   message[\"Status\"].ToString() == \"OK\";\n        if (result)\n        {\n            textBox.Text = message[\"Data\"] as String;\n        }\n        else if (message.ContainsKey(\"ErrorMessage\"))\n        {\n            textBox.Text = message[\"ErrorMessage\"] as String;\n        }\n    }\n    else\n    {\n        textBox.Text = \"App Service connection error: \" + response.Status;\n    }\n}    Build and run the Knowzy app by starting the Microsoft.Knowzy.Debug project.    Click on the  Menu  menu item.    When the AppServiceTest windows appears, click on the  Connect  button.    The following things should now happen    The UWP app will send a message to the AppService    The AppService wil forward the event to the WPF via its listener connection    The WPF responds to the message and send the result back to the App Service    The App Service returns the result from the WPF app back to the UWP app    The UWP app displays the result it received from the WPF app.       You have now successfully developed a solution for communicating between the UWP and WPF portions of your Desktop Bridge app using an App Service.", 
            "title": "Add the XAML ui page that will communicate with the App Service"
        }, 
        {
            "location": "/stories/2/223_AppServices/#references", 
            "text": "Create and consume an app service    App services sample    Adding UWP features to your existing PC software", 
            "title": "References"
        }, 
        {
            "location": "/stories/2/223_AppServices/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/2/223_AppServices/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/", 
            "text": "Task 2.3.1 - Add support for ink\n\n\nOur development department is pleased with the results of \nTask 2.2.2 Add support for other apps to share images with the Knowzy App\n \nthat allowed Knowzy app users to share images from other Windows 10 applications with the Knowzy app. However, we would like Knowzy users to be able\nto annotate the image with the Windows 10 Inking APIs before sharing the image.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 2.2.2\n and all of it's prerequisites\n\n\nTask\n\n\n\n\n\n\nShare an image from another Windows 10 App. The Knowzy app should appear as one of the options for Share Targets.\n\n\n\n\n\n\nDisplay a XAML UI for sharing with the Knowzy app.\n\n\n\n\n\n\nEnable Inking controls on the SharePage to allow the user to annotate the image. Look \nhere\n\nfor some sample code. You will need to add the Win2D.uwp NuGet Package to your UWP project.\n\n\n\n\n\n\nDisplay a Toast that displays the annotated image after the sharing operation has completed.\n\n\n\n\n\n\nComments\n\n\n@ 8:12am\n\n\nOur research has found a starting point for the inking idea \nhere\n\n\n@ 10:43am\n\n\nWe also found sample code for Inking \nhere\n\n\n@ 10:49am\n\n\nYou might need to add the following to the Dependencies tag of Package.appxmanifest in Microsoft.Knowzy.UWP in order to be able to use Win2D with Visual Studio 2017\n\n\n  \nDependencies\n\n    \nTargetDeviceFamily Name=\nWindows.Desktop\n MinVersion=\n10.0.14393.0\n MaxVersionTested=\n10.0.14393.0\n /\n\n    \nPackageDependency Name=\nMicrosoft.VCLibs.140.00\n MinVersion=\n14.0.22929.0\n Publisher=\nCN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US\n /\n\n  \n/Dependencies\n\n\n\n\n\n@ 10:58am\n\n\nHint: save the image file you receive from the Sharing Protocol to ApplicationData.Current.TemporaryFolder before trying to open it with Win2D.\n\n\nThe solution for this task is located \nhere\n\n\ncontinue to \nnext task", 
            "title": "231 Inking Dial"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/#task-231-add-support-for-ink", 
            "text": "Our development department is pleased with the results of  Task 2.2.2 Add support for other apps to share images with the Knowzy App  \nthat allowed Knowzy app users to share images from other Windows 10 applications with the Knowzy app. However, we would like Knowzy users to be able\nto annotate the image with the Windows 10 Inking APIs before sharing the image.", 
            "title": "Task 2.3.1 - Add support for ink"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/#prerequisites", 
            "text": "This task has a dependency on  Task 2.2.2  and all of it's prerequisites", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/#task", 
            "text": "Share an image from another Windows 10 App. The Knowzy app should appear as one of the options for Share Targets.    Display a XAML UI for sharing with the Knowzy app.    Enable Inking controls on the SharePage to allow the user to annotate the image. Look  here \nfor some sample code. You will need to add the Win2D.uwp NuGet Package to your UWP project.    Display a Toast that displays the annotated image after the sharing operation has completed.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/#812am", 
            "text": "Our research has found a starting point for the inking idea  here", 
            "title": "@ 8:12am"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/#1043am", 
            "text": "We also found sample code for Inking  here", 
            "title": "@ 10:43am"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/#1049am", 
            "text": "You might need to add the following to the Dependencies tag of Package.appxmanifest in Microsoft.Knowzy.UWP in order to be able to use Win2D with Visual Studio 2017     Dependencies \n     TargetDeviceFamily Name= Windows.Desktop  MinVersion= 10.0.14393.0  MaxVersionTested= 10.0.14393.0  / \n     PackageDependency Name= Microsoft.VCLibs.140.00  MinVersion= 14.0.22929.0  Publisher= CN=Microsoft Corporation, O=Microsoft Corporation, L=Redmond, S=Washington, C=US  / \n   /Dependencies", 
            "title": "@ 10:49am"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/#1058am", 
            "text": "Hint: save the image file you receive from the Sharing Protocol to ApplicationData.Current.TemporaryFolder before trying to open it with Win2D.", 
            "title": "@ 10:58am"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/2/231_Inking_Dial/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/2/232_Windows_Hello/", 
            "text": "Task 2.3.2 - Complete support for Windows Hello Authentication\n\n\nOur development department is pleased with the results of \nTask 2.1.4 Integrate Windows Hello Authentication\n \nthat prototyped using Windows Hello to log into the Knowzy app if the user was using the Desktop Bridge version of Knowzy. We now want you to\nattempt a more complete implementation.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 2.1.4\n and all of it's prerequisites\n\n\nTask\n\n\n\n\n\n\nImplement a complete solution for Windows Hello.\n\n\n\n\n\n\nImplement a local Windows Hello Server\n\n\n\n\n\n\nUpdate Xaml UI as needed.\n\n\n\n\n\n\nComments\n\n\n@ 8:14am\n\n\nOur research has found a starting point for Windows Hello \nhere\n\n\n@ 10:49am\n\n\nWe also found sample code for Windows Hello \nhere\n\n\ncontinue to \nnext task", 
            "title": "232 Windows Hello"
        }, 
        {
            "location": "/stories/2/232_Windows_Hello/#task-232-complete-support-for-windows-hello-authentication", 
            "text": "Our development department is pleased with the results of  Task 2.1.4 Integrate Windows Hello Authentication  \nthat prototyped using Windows Hello to log into the Knowzy app if the user was using the Desktop Bridge version of Knowzy. We now want you to\nattempt a more complete implementation.", 
            "title": "Task 2.3.2 - Complete support for Windows Hello Authentication"
        }, 
        {
            "location": "/stories/2/232_Windows_Hello/#prerequisites", 
            "text": "This task has a dependency on  Task 2.1.4  and all of it's prerequisites", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/2/232_Windows_Hello/#task", 
            "text": "Implement a complete solution for Windows Hello.    Implement a local Windows Hello Server    Update Xaml UI as needed.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/2/232_Windows_Hello/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/2/232_Windows_Hello/#814am", 
            "text": "Our research has found a starting point for Windows Hello  here", 
            "title": "@ 8:14am"
        }, 
        {
            "location": "/stories/2/232_Windows_Hello/#1049am", 
            "text": "We also found sample code for Windows Hello  here", 
            "title": "@ 10:49am"
        }, 
        {
            "location": "/stories/2/232_Windows_Hello/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/2/233_Extend/", 
            "text": "Task 2.3.3 - Integrate with more UWP APIs\n\n\nNow that we have moved our apps to UWP, we can start taking advantage of some new APIs to light up our app on Windows 10. Time to build on top of what you've already built and differentiate your app.\n\n\nPrerequisites\n\n\nThis task assumes you have completed at least one of the Tasks in 2.2 \n\n\nTask\n\n\nChose one or more from the below APIs to integrate in your app in a meaningful way. You are not limited to the below features - if you find an API or feature is not listed below, ask your proctors if it will satisfy the requirements for this task\n\n\n\n\n\n\nComposition, Animations, and Effects\n\n\n\n\n\n\nUWP Community Toolkit\n\n\n\n\n\n\nDial\n\n\n\n\n\n\nProject Rome\n\n\n\n\n\n\nInking\n\n\n\n\n\n\nDevices/Sensors\n\n\n\n\n\n\nMaps\n\n\n\n\n\n\n...\n\n\n\n\n\n\nResource\n\n\nMake sure to visit the \nGetting Started\n portal for \ndocumentation\n, and check out the \nUWP samples\n for ideas.", 
            "title": "233 Extend"
        }, 
        {
            "location": "/stories/2/233_Extend/#task-233-integrate-with-more-uwp-apis", 
            "text": "Now that we have moved our apps to UWP, we can start taking advantage of some new APIs to light up our app on Windows 10. Time to build on top of what you've already built and differentiate your app.", 
            "title": "Task 2.3.3 - Integrate with more UWP APIs"
        }, 
        {
            "location": "/stories/2/233_Extend/#prerequisites", 
            "text": "This task assumes you have completed at least one of the Tasks in 2.2", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/2/233_Extend/#task", 
            "text": "Chose one or more from the below APIs to integrate in your app in a meaningful way. You are not limited to the below features - if you find an API or feature is not listed below, ask your proctors if it will satisfy the requirements for this task    Composition, Animations, and Effects    UWP Community Toolkit    Dial    Project Rome    Inking    Devices/Sensors    Maps    ...", 
            "title": "Task"
        }, 
        {
            "location": "/stories/2/233_Extend/#resource", 
            "text": "Make sure to visit the  Getting Started  portal for  documentation , and check out the  UWP samples  for ideas.", 
            "title": "Resource"
        }, 
        {
            "location": "/stories/3/311_XamarinForms/", 
            "text": "Task 3.1.1 - Create a Xamarin.Forms app with shared UI\n\n\nBuilding a cross platform mobile application will help our marketing department reach an even wider audience of potential customers. Xamarin.Forms allows us to build one application that reaches multiple platforms.\n\n\nGoals for this task:\n Create a mobile application with Shared App that runs on Android and UWP.\n\n\nThis is going to be an entirely new product for Knowzy and we'll start from scratch. We've already done some investigation based on the requirements given to us by our management, and we've written a guide for the developer to help them get started.\n\n\nPrerequisites\n\n\nThis walkthrough assumes that you have:\n\n\n\n\nWindows 10 Creators Update\n\n\nVisual Studio 2017 with the following additional workloads:\n\n\nMobile Development with .NET\n\n\nUniversal Windows Platform development\n\n\n\n\n\n\n\n\nClick here\n to learn how to install Visual Studio. If you already have Visual Studio 2017 but you're not sure if you have the right workloads installed, open the Visual Studio installer, and then select \nModify\n to view your current workloads. Install any that are missing.\n\n\nTask\n\n\nStart by creating a new Xamarin.Forms application\n\n\n\n\n\n\nIn Visual Studio, select \nFile -\n New -\n Project\n from the taskbar.\n\n\n\n\n\n\nUnder \nTemplates -\n Visual C# -\n Cross-Platform\n select \nCross Platform App (Xamarin.Forms or Native)\n. Pick a name, and then create the project.\n    \n Note: pick a short name and place the project close to the root of your drive (ex: c:\\source) in order to avoid long names that might cause issues later when running your project.\n\n\n\n\n\n\nWe'll start with a Blank App. Make sure Xamarin.Forms is selected under \nUI Technology\n and that Shared Project is selected under \nCode Sharing Strategy\n.\n\n\n\n\n\n\nNote: A \nXamarin Mac Agent\n window might open asking you to connect to a Mac as soon as you create the project. You can safely ignore the message and close this window.\n\n\nNote: A \nNew Universal Windows Project\n might open asking you to choose target and minimum platform version. Make sure \nTarget Version\n is \nWindows 10 Creators Update\n. Minimum version can be anything.\n\n\n\n\n\n\n\n\n\n\nThat's it. At this point, you should probably spend some time checking out the new solution. You'll notice there are four projects in the solution, one shared project and three platform specific projects. To run the app on a specific platform, use the drop down menu near the top of Visual Studio to select which project you want to run:\n\n\n\n\nWe'll focus on UWP and Android for our first release. To run your app as a UWP app, select the UWP project. Then change the architecture (the drop down menu to the left of the Startup projects menu), and select x86 or x64. Then, click the play button (or press \nF5\n) to build and run the app:\n\n\n\n\nTo test and debug the app on Android, there are several options:\n\n\n\n\n\n\nUse the Android SDK Emulator\n\n\n\n\n\n\nUse the Visual Studio Emulator\n\n\n\n\n\n\nUse a physical device\n\n\n\n\n\n\n\n\nNote: If you try to run the faster x86 version of the Android SDK Emulator and get an exception, you might need to turn of the hypervisor by running the following command in Command Prompt as Administrator: \nbcdedit /set hypervisorlaunchtype off\n and reboot.\n\n\n\n\nChange the Startup Project to the Android project, and use the drop down menu on the right to select the emulator or device that you want to use. Click the play icon to build and run the app.\n\n\n\n\nNow get to know your new app.\n\n\n\n\nNote: Since we'll not be using the iOS project for this release, feel free to remove it from your solution.\n\n\n\n\nAdd shared Business Logic\n\n\nFor our first task, we want to be able to list all the different Knowzy products. Fortunately, we already have a public feed for our products. It's located  \nhere\n, and we can use it to get all of the data for our app.\n\n\n\n\n\n\nLet's create a new class that we can use to represent our nose model. Right-click the Shared project (the one without a platform specifier at the end), and select \nAdd -\n Class\n.\n\n\n\n\nName the new class \nNose\n. Erase everything between the namespace definition. We need our new class to match the data that we get from our JSON feed, so we'll create a new class from the JSON. Copy this JSON but don't paste it anywhere yet:\n\n\n{\n    \"Id\": \"RN3454\",\n    \"Name\": \"Black Nose\",\n    \"RawMaterial\": \"Black foam\",\n    \"Notes\": \"Everything you'd expect, and a little something more.\",\n    \"Image\": \"https://raw.githubusercontent.com/Knowzy/KnowzyInternalApps/master/src/Noses/black.png\"\n}\n\n\n\nIn Visual Studio, place the cursor where you want to copy the new class (between the namespace braces). In the taskbar, select \nEdit -\n Paste Special -\n Paste JSON as Classes\n. This generates a new class for you by using the JSON that you just copied. You just need to change the name from RootObject to \nNose\n.\n\n\n\n\n\n\n\n\nNow that we have our model, let's create a way to retrieve the data from our feed.\n\n\n\n\nFirst, we'll use Json.Net to deserialize the JSON, so we'll need to reference the Nuget package to both the UWP and the Android project. Right-click each project and select \nManage Nuget Packages\n. Search for \nNewtonsoft.Json\n and then install it (make sure to switch to the \nBrowse\n tab when searching).\n\n\nFollow the same steps as above to create a new class in the shared project.\n\n\nName the new class \nDataProvider\n.\n\n\nMake the class public.\n\n\n\n\nAdd this static method in the class to pull in the data from the link above:\n\n\npublic static async Task\nNose[]\n GetProducts()\n{\n    using (var client = new HttpClient())\n    {\n        var json = await client.GetStringAsync(\"https://raw.githubusercontent.com/Knowzy/KnowzyInternalApps/master/src/Noses/noses.json\");\n\n        return JsonConvert.DeserializeObject\nNose[]\n(json);\n    }\n}\n\n\n\nYou'll need to add few namespaces for this function to work:\n\n\nusing Newtonsoft.Json;\nusing System.Net.Http;\nusing System.Threading.Tasks;\n\n\n\n\n\n\n\n\n\n\n\nWe now have a static method that retrieves the JSON feed and deserializes it into Nose objects, which we can use in our app.\n\n\nAdd shared UI\n\n\nNow that we have the business logic out of the way, let's move on to the UI. Xamarin.Forms uses XAML to define the shared UI, so if you've used XAML before, you'll feel right at home. All the shared code is in the shared project of the solution, and there's already a XAML page created for us: MainPage.xaml. Go ahead and open the page. Currently there's only one element there, a \nLabel\n. Instead of a Label, we'll use a \nListView\n to display all of the products.\n\n\n\n\n\n\nRemove the Label and add a ListView instead. Give it a name. In this case it's \nProductListView\n.\n\n\nListView x:Name=\"ProductListView\"\n\n\n\n/ListView\n\n\n\n\n\n\n\n\nOpen MainPage.xaml.cs. This is where the underlying code for your app view goes. Here we can override the \nOnAppearing\n method which allows us to get the list of products, and set them as the source of the ListView. Add the following code to the class:\n\n\nprotected async override void OnAppearing()\n{\n    base.OnAppearing();\n    ProductListView.ItemsSource = await DataProvider.GetProducts();\n}\n\n\n\n\n\n\n\nFinally, we need to define what each product will look like. For that, we'll create a data template to customize each \nCell\n. Here is the final XAML for the ListView:\n\n\nListView x:Name=\"ProductListView\"\n\n    \nListView.ItemTemplate\n\n        \nDataTemplate\n\n            \nViewCell\n\n                \nStackLayout Orientation=\"Horizontal\"\n\n                    \nImage Source=\"{Binding Image}\" HeightRequest=\"150\" WidthRequest=\"150\"\n/Image\n\n                    \nLabel Text=\"{Binding Name}\"\n/Label\n\n                \n/StackLayout\n\n            \n/ViewCell\n\n        \n/DataTemplate\n\n    \n/ListView.ItemTemplate\n\n\n/ListView\n\n\n\n\n\n\n\n\nTask Complete\n. Go ahead and try running the app on your machine, and then in the Android emulator.\n\n\n\n\nGo to the next Task\n where you'll add another page and the capability to capture an image by using APIs specific to each platform.\n\n\nResources\n\n\n\n\nXamarin.Forms Quickstart\n\n\nIntroduction to Xamarin.Forms\n\n\nXamarin.Forms XAML documentation\n\n\n\n\ncontinue to \nnext task \n \n\n\nThe solution for this task is located \nhere", 
            "title": "311 XamarinForms"
        }, 
        {
            "location": "/stories/3/311_XamarinForms/#task-311-create-a-xamarinforms-app-with-shared-ui", 
            "text": "Building a cross platform mobile application will help our marketing department reach an even wider audience of potential customers. Xamarin.Forms allows us to build one application that reaches multiple platforms.  Goals for this task:  Create a mobile application with Shared App that runs on Android and UWP.  This is going to be an entirely new product for Knowzy and we'll start from scratch. We've already done some investigation based on the requirements given to us by our management, and we've written a guide for the developer to help them get started.", 
            "title": "Task 3.1.1 - Create a Xamarin.Forms app with shared UI"
        }, 
        {
            "location": "/stories/3/311_XamarinForms/#prerequisites", 
            "text": "This walkthrough assumes that you have:   Windows 10 Creators Update  Visual Studio 2017 with the following additional workloads:  Mobile Development with .NET  Universal Windows Platform development     Click here  to learn how to install Visual Studio. If you already have Visual Studio 2017 but you're not sure if you have the right workloads installed, open the Visual Studio installer, and then select  Modify  to view your current workloads. Install any that are missing.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/311_XamarinForms/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/311_XamarinForms/#start-by-creating-a-new-xamarinforms-application", 
            "text": "In Visual Studio, select  File -  New -  Project  from the taskbar.    Under  Templates -  Visual C# -  Cross-Platform  select  Cross Platform App (Xamarin.Forms or Native) . Pick a name, and then create the project.\n      Note: pick a short name and place the project close to the root of your drive (ex: c:\\source) in order to avoid long names that might cause issues later when running your project.    We'll start with a Blank App. Make sure Xamarin.Forms is selected under  UI Technology  and that Shared Project is selected under  Code Sharing Strategy .    Note: A  Xamarin Mac Agent  window might open asking you to connect to a Mac as soon as you create the project. You can safely ignore the message and close this window.  Note: A  New Universal Windows Project  might open asking you to choose target and minimum platform version. Make sure  Target Version  is  Windows 10 Creators Update . Minimum version can be anything.      That's it. At this point, you should probably spend some time checking out the new solution. You'll notice there are four projects in the solution, one shared project and three platform specific projects. To run the app on a specific platform, use the drop down menu near the top of Visual Studio to select which project you want to run:   We'll focus on UWP and Android for our first release. To run your app as a UWP app, select the UWP project. Then change the architecture (the drop down menu to the left of the Startup projects menu), and select x86 or x64. Then, click the play button (or press  F5 ) to build and run the app:   To test and debug the app on Android, there are several options:    Use the Android SDK Emulator    Use the Visual Studio Emulator    Use a physical device     Note: If you try to run the faster x86 version of the Android SDK Emulator and get an exception, you might need to turn of the hypervisor by running the following command in Command Prompt as Administrator:  bcdedit /set hypervisorlaunchtype off  and reboot.   Change the Startup Project to the Android project, and use the drop down menu on the right to select the emulator or device that you want to use. Click the play icon to build and run the app.   Now get to know your new app.   Note: Since we'll not be using the iOS project for this release, feel free to remove it from your solution.", 
            "title": "Start by creating a new Xamarin.Forms application"
        }, 
        {
            "location": "/stories/3/311_XamarinForms/#add-shared-business-logic", 
            "text": "For our first task, we want to be able to list all the different Knowzy products. Fortunately, we already have a public feed for our products. It's located   here , and we can use it to get all of the data for our app.    Let's create a new class that we can use to represent our nose model. Right-click the Shared project (the one without a platform specifier at the end), and select  Add -  Class .   Name the new class  Nose . Erase everything between the namespace definition. We need our new class to match the data that we get from our JSON feed, so we'll create a new class from the JSON. Copy this JSON but don't paste it anywhere yet:  {\n    \"Id\": \"RN3454\",\n    \"Name\": \"Black Nose\",\n    \"RawMaterial\": \"Black foam\",\n    \"Notes\": \"Everything you'd expect, and a little something more.\",\n    \"Image\": \"https://raw.githubusercontent.com/Knowzy/KnowzyInternalApps/master/src/Noses/black.png\"\n}  In Visual Studio, place the cursor where you want to copy the new class (between the namespace braces). In the taskbar, select  Edit -  Paste Special -  Paste JSON as Classes . This generates a new class for you by using the JSON that you just copied. You just need to change the name from RootObject to  Nose .     Now that we have our model, let's create a way to retrieve the data from our feed.   First, we'll use Json.Net to deserialize the JSON, so we'll need to reference the Nuget package to both the UWP and the Android project. Right-click each project and select  Manage Nuget Packages . Search for  Newtonsoft.Json  and then install it (make sure to switch to the  Browse  tab when searching).  Follow the same steps as above to create a new class in the shared project.  Name the new class  DataProvider .  Make the class public.   Add this static method in the class to pull in the data from the link above:  public static async Task Nose[]  GetProducts()\n{\n    using (var client = new HttpClient())\n    {\n        var json = await client.GetStringAsync(\"https://raw.githubusercontent.com/Knowzy/KnowzyInternalApps/master/src/Noses/noses.json\");\n\n        return JsonConvert.DeserializeObject Nose[] (json);\n    }\n}  You'll need to add few namespaces for this function to work:  using Newtonsoft.Json;\nusing System.Net.Http;\nusing System.Threading.Tasks;      We now have a static method that retrieves the JSON feed and deserializes it into Nose objects, which we can use in our app.", 
            "title": "Add shared Business Logic"
        }, 
        {
            "location": "/stories/3/311_XamarinForms/#add-shared-ui", 
            "text": "Now that we have the business logic out of the way, let's move on to the UI. Xamarin.Forms uses XAML to define the shared UI, so if you've used XAML before, you'll feel right at home. All the shared code is in the shared project of the solution, and there's already a XAML page created for us: MainPage.xaml. Go ahead and open the page. Currently there's only one element there, a  Label . Instead of a Label, we'll use a  ListView  to display all of the products.    Remove the Label and add a ListView instead. Give it a name. In this case it's  ProductListView .  ListView x:Name=\"ProductListView\"  /ListView     Open MainPage.xaml.cs. This is where the underlying code for your app view goes. Here we can override the  OnAppearing  method which allows us to get the list of products, and set them as the source of the ListView. Add the following code to the class:  protected async override void OnAppearing()\n{\n    base.OnAppearing();\n    ProductListView.ItemsSource = await DataProvider.GetProducts();\n}    Finally, we need to define what each product will look like. For that, we'll create a data template to customize each  Cell . Here is the final XAML for the ListView:  ListView x:Name=\"ProductListView\" \n     ListView.ItemTemplate \n         DataTemplate \n             ViewCell \n                 StackLayout Orientation=\"Horizontal\" \n                     Image Source=\"{Binding Image}\" HeightRequest=\"150\" WidthRequest=\"150\" /Image \n                     Label Text=\"{Binding Name}\" /Label \n                 /StackLayout \n             /ViewCell \n         /DataTemplate \n     /ListView.ItemTemplate  /ListView     Task Complete . Go ahead and try running the app on your machine, and then in the Android emulator.   Go to the next Task  where you'll add another page and the capability to capture an image by using APIs specific to each platform.", 
            "title": "Add shared UI"
        }, 
        {
            "location": "/stories/3/311_XamarinForms/#resources", 
            "text": "Xamarin.Forms Quickstart  Introduction to Xamarin.Forms  Xamarin.Forms XAML documentation", 
            "title": "Resources"
        }, 
        {
            "location": "/stories/3/311_XamarinForms/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/311_XamarinForms/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/3/312_Camera/", 
            "text": "Task 3.1.2 - Capture Images\n\n\nOur marketing department wants to allow users of our app to capture images, and position Knowzy products over the image to see how they would look. It's a fun way to try the product without actually buying it. The marketing department is hoping that these images will be shared on social media to spread the word.\n\n\nGoals for this task:\n Enable your Android and UWP app to capture images from the camera.\n\n\nFor this task, you'll need to access APIs that are specific to each platform. We've done the research on how to do it and we've included the steps below.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 3.1.1\n and all of it's prerequisites.\n\n\nTask\n\n\nCreate and navigate to a new page\n\n\n\n\n\n\nRight-click the Shared project, and then select \nAdd -\n New Item\n.\n\n\n\n\n\n\nUnder \nVisual C# -\n Cross-Platform\n select \nForms Blank Content Page Xaml\n, give it a name (we use CameraPage in this guide), and then click the \nAdd\n button.\n\n\n\n\n\n\n\n\nNote: The new page might also be found under \nVisual C# -\n Xamarin.Forms -\n Content Page\n\n\n\n\nThis will create a new page which you can navigate to once a product has been selected on the Main page.\n\n\nThere are \nmultiple ways to navigate between pages\n. In this example, we'll use a \nNavigationPage\n to act as a host for our pages and provide hierarchical navigation.\n\n\n\n\n\n\nIn the Shared project, open the App.xaml.cs file.\n\n\nNotice that the constructor sets the MainPage to a new MainPage (the default page when the app is created):\n\n\nMainPage = new Knowzy.Mobile.MainPage();\n\n\n\n\n\nNote: the \nKnowzy.Mobile\n namespace above might be different for you depending on what you named your project\n\n\n\n\n\n\n\n\nInstead of setting the MainPage to a new MainPage, set it to a new NavigationPage and pass a new MainPage as a parameter.\n\n\nMainPage = new NavigationPage(new MainPage());\n\n\n\nThis will set it as the first page in our hierarchical navigation system.\n\n\nYou're now ready to navigate to the new page. We want to navigate to the new page when a product (nose) is clicked in the main page, and we want to pass the nose as a parameter. The easiest way to do that is to pass the clicked nose as a parameter to the constructor when navigating to the new page.\n\n\n\n\n\n\nOpen the code-behind file for the new page that you created (CameraPage.xaml.cs in our example), and modify the constructor to accept a Nose object as a parameter.\n\n\nNose _nose;\n\npublic CameraPage(Nose nose)\n{\n    _nose = nose;\n    InitializeComponent ();\n}\n\n\n\n\n\n\n\nOpen the XAML file for the main page, and add an \nItemTapped\n event handler to handle an event that is raised when an item is taped on the ListView.\n\n\nListView x:Name=\"ProductListView\" ItemTapped=\"ProductListViewItemTapped\"\n\n    \n!-- ... --\n\n\n/ListView\n\n\n\n\n\n\n\n\nIn the code-behind for the main page (MainPage.xaml.cs), implement the event handler, and add the following code to the handler:\n\n\nprivate void ProductListViewItemTapped(object sender, ItemTappedEventArgs e)\n{\n    Navigation.PushAsync(new CameraPage(e.Item as Nose));\n}\n\n\n\nThis code navigates to the new page by passing the tapped item.\n\n\n\n\n\n\nYou should now be able to navigate to the new (empty) page. Test it out to make sure it all works as expected.\n\n\nCapture image from camera on Android and UWP\n\n\nOnce we've navigated to the new page, the goal is to capture an image from the camera. Because each platform has a different native API for camera capture, we'll design an interface and then implement that interface on each platform. Then, we'll use the \nDependencyService\n from Xamarin.Forms to call the right implementation.\n\n\n\n\n\n\nCreate a new interface class in the Shared Project and name it \nIPhotoService\n.\n\n\n\n\n\n\nAdd a method definition for capturing the photo. It should look like this:\n\n\npublic interface IPhotoService\n{\n    Task\nbyte[]\n TakePhotoAsync();\n}\n\n\n\nYou'll need to add few namespaces:\n\n\nusing System.Threading.Tasks;\nusing Xamarin.Forms;\n\n\n\nTo use the native APIs, you'll need to implement this interface for each platform. Let's start with UWP.\n\n\n\n\n\n\nImplement the IPhotoService interface for UWP\n\n\n\n\n\n\nIn the UWP project, create a new class and name it PhotoService. Extend IPhotoService and register with the DependencyService by adding a metadata attribute above the namespace. The class would look like this:\n\n\nusing Xamarin.Forms;\nusing YourNamespace.UWP;\n\n[assembly: Dependency(typeof(PhotoService))]\nnamespace YourNamespace.UWP\n{\n        public class PhotoService : IPhotoService\n        {\n            public async Task\nbyte[]\n TakePhotoAsync()\n            {\n\n            }\n        }\n}\n\n\n\n\n\n\n\nImplement the TakePhotoAsync method to use the native \nCameraCaptureUI\n from UWP and make it async:\n\n\npublic Task\nbyte[]\n TakePhotoAsync()\n{\n        CameraCaptureUI captureUI = new CameraCaptureUI();\n        captureUI.PhotoSettings.Format = CameraCaptureUIPhotoFormat.Jpeg;\n\n        StorageFile photo = await captureUI.CaptureFileAsync(CameraCaptureUIMode.Photo);\n\n        if (photo == null) return null;\n\n        using (var stream = await photo.OpenReadAsync())\n        {\n            var buffer = new Windows.Storage.Streams.Buffer((uint)stream.Size);\n            var data = await stream.ReadAsync(buffer, (uint)stream.Size, Windows.Storage.Streams.InputStreamOptions.None);\n            return data.ToArray();\n        }\n}\n\n\n\nYou'll also need few namespaces:\n\n\nusing Windows.Media.Capture;\nusing Windows.Storage;\n\n\n\nThat's all for UWP.\n\n\n\n\n\n\nImplement IPhotoService for Android\n\n\nImplementing the Android version is a bit more complicated because it requires the use of Android intents.\n\n\n\n\n\n\nIn the Android project, open the MainActivity.cs file.\n\n\nThis file is the entry point for the Android application.\n\n\n\n\n\n\nIn that file, create a new static readonly property of the type \nFile\n. This property will store the captured image\n\n\nstatic readonly File file =\nnew File(Android.OS.Environment.GetExternalStoragePublicDirectory(\n    Android.OS.Environment.DirectoryPictures), \"tmp.jpg\");\n\n\n\n\n\n\n\nCreate a new method to start the new Image Capture intent and place the results in a the new file:\n\n\npublic void StartMediaCaptureActivity()\n{\n        var intent = new Intent(MediaStore.ActionImageCapture);\n        intent.PutExtra(MediaStore.ExtraOutput, Android.Net.Uri.FromFile(file));\n        StartActivityForResult(intent, 0);\n}\n\n\n\n\n\n\n\nAdd these namespaces to the file:\n\n\nusing Java.IO;\nusing Android.Content;\nusing Android.Provider;\n\n\n\n\n\n\n\nAdd a new event, and then override the OnActivityResult method so that it can respond when the intent has completed and an image has been captured.\n\n\npublic event EventHandler\nFile\n ImageCaptured;\n\nprotected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n        if (requestCode == 0 \n resultCode == Result.Ok)\n        {\n            ImageCaptured?.Invoke(this, file);\n        }\n}\n\n\n\nLater, we can subscribe to the ImageCaptured event that you created so that we're notified when an image has been captured.\n\n\n\n\n\n\nJust like we did in the UWP project, create a new class in the Android project and name it PhotoService. Extend IPhotoService and register with the DependencyService by adding a metadata attribute above the namespace. Your class should look like this:\n\n\nusing Xamarin.Forms;\nusing System.Threading.Tasks;\nusing YourNamespace.Droid;\n\n[assembly: Dependency(typeof(PhotoService))]\nnamespace YourNamespace.Droid\n{\n        public class PhotoService : IPhotoService\n        {\n            public Task\nbyte[]\n TakePhotoAsync()\n            {\n\n            }\n        }\n    }\n\n\n\n\n\nNote: your namespace for Android might be \nDroid\n or \nAndroid\n\n\n\n\n\n\n\n\nYou're now ready to implement the Android version of the TakePhotoAsync method.\n\n\n\n\n\n\nIn the method, add code that does these things:\n\n\n\n\nCalls the StartMediaCaptureActivity method you created in MainActivity.\n\n\nCreates an event handler to listen to when the image has been captured.\n\n\nCreates TaskCompletionSource instance that will complete once the image has been captured and the event has raised.\n\n\n\n\nHere's the code.\n\n\npublic Task\nbyte[]\n TakePhotoAsync()\n{\n    var mainActivity = Forms.Context as MainActivity;\n    var tcs = new TaskCompletionSource\nbyte[]\n();\n    EventHandler\nJava.IO.File\n handler = null;\n    handler = (s, e) =\n\n    {\n        using (var streamReader = new StreamReader(e.Path))\n        {\n            using (var memstream = new MemoryStream())\n            {\n                streamReader.BaseStream.CopyTo(memstream);\n                tcs.SetResult(memstream.ToArray());\n            }\n        }\n        mainActivity.ImageCaptured -= handler;\n    };\n\n    mainActivity.ImageCaptured += handler;\n    mainActivity.StartMediaCaptureActivity();\n    return tcs.Task;\n}\n\n\n\nYou're now done with Android.\n\n\n\n\n\n\nConsume the PhotoService class\n\n\n\n\n\n\nIn the new page that you created (CameraPage.xaml in this example), add a Button and an Image element to host the capture image. Create an event handler for the Clicked event of the button.\n\n\nStackLayout VerticalOptions=\"FillAndExpand\"\n                HorizontalOptions=\"FillAndExpand\"\n                Orientation=\"Vertical\"\n                Spacing=\"15\"\n\n    \nButton x:Name=\"captureButton\"\n            Text=\"Capture Image\"\n            Clicked=\"captureButton_Clicked\"\n/Button\n\n    \nImage x:Name=\"image\"\n/Image\n\n\n/StackLayout\n\n\n\n\n\n\n\n\nIn the button event handler, create an instance of the PhotoService class via the DependencyService, and then call the TakePhotoAsync method to capture an image. Once the image is captured, set the source of the image:\n\n\nprivate async void captureButton_Clicked(object sender, EventArgs e)\n{\n    var photoService = DependencyService.Get\nIPhotoService\n();\n    if(photoService != null)\n    {\n        var imageBytes = await photoService.TakePhotoAsync();\n        image.Source = ImageSource.FromStream(() =\n new MemoryStream(imageBytes));\n    }\n}\n\n\n\n\n\n\n\nAnd you're done! Run the app and try it out. You should be able to navigate to the new page when you click on a nose. There should be a button to capture an image that will open the platform specific UI for capturing images. Once the image is captured, it should display the image below the button.\n\n\nGo to the next Task\n where you'll extend this page to overlay the noses on top of the image and add Inking capabilities on Windows.\n\n\ncontinue to \nnext task \n \n\n\nThe solution for this task is located \nhere", 
            "title": "312 Camera"
        }, 
        {
            "location": "/stories/3/312_Camera/#task-312-capture-images", 
            "text": "Our marketing department wants to allow users of our app to capture images, and position Knowzy products over the image to see how they would look. It's a fun way to try the product without actually buying it. The marketing department is hoping that these images will be shared on social media to spread the word.  Goals for this task:  Enable your Android and UWP app to capture images from the camera.  For this task, you'll need to access APIs that are specific to each platform. We've done the research on how to do it and we've included the steps below.", 
            "title": "Task 3.1.2 - Capture Images"
        }, 
        {
            "location": "/stories/3/312_Camera/#prerequisites", 
            "text": "This task has a dependency on  Task 3.1.1  and all of it's prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/312_Camera/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/312_Camera/#create-and-navigate-to-a-new-page", 
            "text": "Right-click the Shared project, and then select  Add -  New Item .    Under  Visual C# -  Cross-Platform  select  Forms Blank Content Page Xaml , give it a name (we use CameraPage in this guide), and then click the  Add  button.     Note: The new page might also be found under  Visual C# -  Xamarin.Forms -  Content Page   This will create a new page which you can navigate to once a product has been selected on the Main page.  There are  multiple ways to navigate between pages . In this example, we'll use a  NavigationPage  to act as a host for our pages and provide hierarchical navigation.    In the Shared project, open the App.xaml.cs file.  Notice that the constructor sets the MainPage to a new MainPage (the default page when the app is created):  MainPage = new Knowzy.Mobile.MainPage();   Note: the  Knowzy.Mobile  namespace above might be different for you depending on what you named your project     Instead of setting the MainPage to a new MainPage, set it to a new NavigationPage and pass a new MainPage as a parameter.  MainPage = new NavigationPage(new MainPage());  This will set it as the first page in our hierarchical navigation system.  You're now ready to navigate to the new page. We want to navigate to the new page when a product (nose) is clicked in the main page, and we want to pass the nose as a parameter. The easiest way to do that is to pass the clicked nose as a parameter to the constructor when navigating to the new page.    Open the code-behind file for the new page that you created (CameraPage.xaml.cs in our example), and modify the constructor to accept a Nose object as a parameter.  Nose _nose;\n\npublic CameraPage(Nose nose)\n{\n    _nose = nose;\n    InitializeComponent ();\n}    Open the XAML file for the main page, and add an  ItemTapped  event handler to handle an event that is raised when an item is taped on the ListView.  ListView x:Name=\"ProductListView\" ItemTapped=\"ProductListViewItemTapped\" \n     !-- ... --  /ListView     In the code-behind for the main page (MainPage.xaml.cs), implement the event handler, and add the following code to the handler:  private void ProductListViewItemTapped(object sender, ItemTappedEventArgs e)\n{\n    Navigation.PushAsync(new CameraPage(e.Item as Nose));\n}  This code navigates to the new page by passing the tapped item.    You should now be able to navigate to the new (empty) page. Test it out to make sure it all works as expected.", 
            "title": "Create and navigate to a new page"
        }, 
        {
            "location": "/stories/3/312_Camera/#capture-image-from-camera-on-android-and-uwp", 
            "text": "Once we've navigated to the new page, the goal is to capture an image from the camera. Because each platform has a different native API for camera capture, we'll design an interface and then implement that interface on each platform. Then, we'll use the  DependencyService  from Xamarin.Forms to call the right implementation.    Create a new interface class in the Shared Project and name it  IPhotoService .    Add a method definition for capturing the photo. It should look like this:  public interface IPhotoService\n{\n    Task byte[]  TakePhotoAsync();\n}  You'll need to add few namespaces:  using System.Threading.Tasks;\nusing Xamarin.Forms;  To use the native APIs, you'll need to implement this interface for each platform. Let's start with UWP.", 
            "title": "Capture image from camera on Android and UWP"
        }, 
        {
            "location": "/stories/3/312_Camera/#implement-the-iphotoservice-interface-for-uwp", 
            "text": "In the UWP project, create a new class and name it PhotoService. Extend IPhotoService and register with the DependencyService by adding a metadata attribute above the namespace. The class would look like this:  using Xamarin.Forms;\nusing YourNamespace.UWP;\n\n[assembly: Dependency(typeof(PhotoService))]\nnamespace YourNamespace.UWP\n{\n        public class PhotoService : IPhotoService\n        {\n            public async Task byte[]  TakePhotoAsync()\n            {\n\n            }\n        }\n}    Implement the TakePhotoAsync method to use the native  CameraCaptureUI  from UWP and make it async:  public Task byte[]  TakePhotoAsync()\n{\n        CameraCaptureUI captureUI = new CameraCaptureUI();\n        captureUI.PhotoSettings.Format = CameraCaptureUIPhotoFormat.Jpeg;\n\n        StorageFile photo = await captureUI.CaptureFileAsync(CameraCaptureUIMode.Photo);\n\n        if (photo == null) return null;\n\n        using (var stream = await photo.OpenReadAsync())\n        {\n            var buffer = new Windows.Storage.Streams.Buffer((uint)stream.Size);\n            var data = await stream.ReadAsync(buffer, (uint)stream.Size, Windows.Storage.Streams.InputStreamOptions.None);\n            return data.ToArray();\n        }\n}  You'll also need few namespaces:  using Windows.Media.Capture;\nusing Windows.Storage;  That's all for UWP.", 
            "title": "Implement the IPhotoService interface for UWP"
        }, 
        {
            "location": "/stories/3/312_Camera/#implement-iphotoservice-for-android", 
            "text": "Implementing the Android version is a bit more complicated because it requires the use of Android intents.    In the Android project, open the MainActivity.cs file.  This file is the entry point for the Android application.    In that file, create a new static readonly property of the type  File . This property will store the captured image  static readonly File file =\nnew File(Android.OS.Environment.GetExternalStoragePublicDirectory(\n    Android.OS.Environment.DirectoryPictures), \"tmp.jpg\");    Create a new method to start the new Image Capture intent and place the results in a the new file:  public void StartMediaCaptureActivity()\n{\n        var intent = new Intent(MediaStore.ActionImageCapture);\n        intent.PutExtra(MediaStore.ExtraOutput, Android.Net.Uri.FromFile(file));\n        StartActivityForResult(intent, 0);\n}    Add these namespaces to the file:  using Java.IO;\nusing Android.Content;\nusing Android.Provider;    Add a new event, and then override the OnActivityResult method so that it can respond when the intent has completed and an image has been captured.  public event EventHandler File  ImageCaptured;\n\nprotected override void OnActivityResult(int requestCode, Result resultCode, Intent data)\n{\n        if (requestCode == 0   resultCode == Result.Ok)\n        {\n            ImageCaptured?.Invoke(this, file);\n        }\n}  Later, we can subscribe to the ImageCaptured event that you created so that we're notified when an image has been captured.    Just like we did in the UWP project, create a new class in the Android project and name it PhotoService. Extend IPhotoService and register with the DependencyService by adding a metadata attribute above the namespace. Your class should look like this:  using Xamarin.Forms;\nusing System.Threading.Tasks;\nusing YourNamespace.Droid;\n\n[assembly: Dependency(typeof(PhotoService))]\nnamespace YourNamespace.Droid\n{\n        public class PhotoService : IPhotoService\n        {\n            public Task byte[]  TakePhotoAsync()\n            {\n\n            }\n        }\n    }   Note: your namespace for Android might be  Droid  or  Android     You're now ready to implement the Android version of the TakePhotoAsync method.    In the method, add code that does these things:   Calls the StartMediaCaptureActivity method you created in MainActivity.  Creates an event handler to listen to when the image has been captured.  Creates TaskCompletionSource instance that will complete once the image has been captured and the event has raised.   Here's the code.  public Task byte[]  TakePhotoAsync()\n{\n    var mainActivity = Forms.Context as MainActivity;\n    var tcs = new TaskCompletionSource byte[] ();\n    EventHandler Java.IO.File  handler = null;\n    handler = (s, e) = \n    {\n        using (var streamReader = new StreamReader(e.Path))\n        {\n            using (var memstream = new MemoryStream())\n            {\n                streamReader.BaseStream.CopyTo(memstream);\n                tcs.SetResult(memstream.ToArray());\n            }\n        }\n        mainActivity.ImageCaptured -= handler;\n    };\n\n    mainActivity.ImageCaptured += handler;\n    mainActivity.StartMediaCaptureActivity();\n    return tcs.Task;\n}  You're now done with Android.", 
            "title": "Implement IPhotoService for Android"
        }, 
        {
            "location": "/stories/3/312_Camera/#consume-the-photoservice-class", 
            "text": "In the new page that you created (CameraPage.xaml in this example), add a Button and an Image element to host the capture image. Create an event handler for the Clicked event of the button.  StackLayout VerticalOptions=\"FillAndExpand\"\n                HorizontalOptions=\"FillAndExpand\"\n                Orientation=\"Vertical\"\n                Spacing=\"15\" \n     Button x:Name=\"captureButton\"\n            Text=\"Capture Image\"\n            Clicked=\"captureButton_Clicked\" /Button \n     Image x:Name=\"image\" /Image  /StackLayout     In the button event handler, create an instance of the PhotoService class via the DependencyService, and then call the TakePhotoAsync method to capture an image. Once the image is captured, set the source of the image:  private async void captureButton_Clicked(object sender, EventArgs e)\n{\n    var photoService = DependencyService.Get IPhotoService ();\n    if(photoService != null)\n    {\n        var imageBytes = await photoService.TakePhotoAsync();\n        image.Source = ImageSource.FromStream(() =  new MemoryStream(imageBytes));\n    }\n}    And you're done! Run the app and try it out. You should be able to navigate to the new page when you click on a nose. There should be a button to capture an image that will open the platform specific UI for capturing images. Once the image is captured, it should display the image below the button.  Go to the next Task  where you'll extend this page to overlay the noses on top of the image and add Inking capabilities on Windows.", 
            "title": "Consume the PhotoService class"
        }, 
        {
            "location": "/stories/3/312_Camera/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/312_Camera/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/3/313_InkCanvas/", 
            "text": "Task 3.1.3 - Overlay noses and support inking for UWP\n\n\nOur marketing department wants to allow users of our app to capture images, and position Knowzy products over the image to see how they would look. It's a fun way to try the product without actually buying it. The marketing department is hoping that these images will be shared on social media to spread the word.\n\n\nGoals for this task:\n\n\n Overlay noses on top of an image and allow nose to be manipulated.\n\n Support inking on UWP devices.\n\n\nFor this task, you will need to access APIs that are specific to each platform. We've done the research on how to do it and have included the steps below.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 3.1.2\n and all of it's prerequisites.\n\n\nTask\n\n\nOverlay nose on image and allow to be manipulated\n\n\nOnce the image is captured, let's add the nose image on top of it, and allow the user to move it by panning and resize it by pinching.\n\n\n\n\n\n\nOpen the XAML page that you added in the previous task (CameraPage.xaml in this example).\n\n\n\n\n\n\nAdd code that does these things:\n\n\n\n\n\n\nWraps the image element that hosts the camera image into a new Grid element.\n\n\nThis will allow you to position multiple elements on top of each other.\n\n\n\n\n\n\nAdds a new \nAbsoluteLayout\n element below the existing Image in the grid.\n\n\n\n\n\n\nAdds a new Image element inside of the AbsoluteLayout element, which will be used to host the nose image.\n\n\n\n\n\n\nHere is what the final result should look like:\n\n\nBefore:\n\n\nImage x:Name=\"image\"\n/Image\n\n\n\n\nAfter:\n\n\nGrid x:Name=\"imageGrid\" IsVisible=\"False\"\n\n    \nImage x:Name=\"image\"\n/Image\n\n    \nAbsoluteLayout\n\n        \nImage x:Name=\"noseImage\"\n            HeightRequest=\"120\"\n            WidthRequest=\"120\"\n            AbsoluteLayout.LayoutBounds=\"0, 0, AutoSize, AutoSize\"\n            AbsoluteLayout.LayoutFlags=\"None\"\n\n        \n/Image\n\n    \n/AbsoluteLayout\n\n\n/Grid\n\n\n\n\n\n\n\n\nNotice that in the XAML, we've set the visibility of the Grid to False. Once the image has been captured, we can set the visibility to True, and then set the source of the noseImage element. Make those changes in the captureButton_Clicked event handler. When you're done, your code should look something like this:\n\n\nprivate async void captureButton_Clicked(object sender, EventArgs e)\n{\n    var photoService = DependencyService.Get\nIPhotoService\n();\n    if (photoService != null)\n    {\n        var imageBytes = await photoService.TakePhotoAsync();\n        noseImage.Source = ImageSource.FromUri(new Uri(_nose.Image)); // set source of nose image\n        image.Source = ImageSource.FromStream(() =\n new MemoryStream(imageBytes));\n        imageGrid.IsVisible = true; // set visibility to true\n    }\n}\n\n\n\n\n\n\n\nTo allow elements to be manipulated by panning or pinching, Xamarin.Forms has built in \nGestures\n. Inside of the the noseImage element that we just added to our page, let's add a new PanGestureRecognizer and a new PinchGestureRecognizer, which will subscribe to the relevant events so we can manipulate the nose image with gestures:\n\n\nImage x:Name=\"noseImage\"\n        HeightRequest=\"120\"\n        WidthRequest=\"120\"\n        AbsoluteLayout.LayoutBounds=\"0, 0, AutoSize, AutoSize\"\n        AbsoluteLayout.LayoutFlags=\"None\"\n\n\n    \n!-- Gesture Recognizers --\n\n    \nImage.GestureRecognizers\n\n        \nPanGestureRecognizer PanUpdated=\"OnPanUpdated\" /\n\n        \nPinchGestureRecognizer PinchUpdated=\"OnPinchUpdated\" /\n\n    \n/Image.GestureRecognizers\n\n\n\n/Image\n\n\n\n\n\n\n\n\nIn your code-behind file (CameraPage.xaml.cs in this example), implement the event handlers for the gestures that we just added. The nose moves with the finger or mouse, and the scale of the image changes when the image is pinched:\n\n\nprivate void OnPanUpdated(object sender, PanUpdatedEventArgs e)\n{\n    switch (e.StatusType)\n    {\n        case GestureStatus.Started:\n            var bounds = AbsoluteLayout.GetLayoutBounds(noseImage);\n            bounds.X += noseImage.TranslationX;\n            bounds.Y += noseImage.TranslationY;\n            AbsoluteLayout.SetLayoutBounds(noseImage, bounds);\n            noseImage.TranslationX = 0;\n            noseImage.TranslationY = 0;\n            break;\n\n        case GestureStatus.Running:\n            noseImage.TranslationX = e.TotalX;\n            noseImage.TranslationY = e.TotalY;\n            break;\n    }\n}\n\nprivate void OnPinchUpdated(object sender, PinchGestureUpdatedEventArgs e)\n{\n    switch (e.Status)\n    {\n        case GestureStatus.Running:\n            noseImage.Scale *= e.Scale;\n            break;\n    }\n}\n\n\n\nThat's it. Run the app, take a photo, position the nose, and have fun.\n\n\n\n\n\n\nAdd inking support on UWP devices.\n\n\nIn addition to using the built in Xamarin.Forms controls, developers have full access to native platform controls through \nnative view declaration\n. This allows developers to use native or custom controls (such as the UWP Community Toolkit), and mix them with Xamarin.Forms controls directly in XAML. For our app, we can use the native InkCanvas control and InkToolbar control when the app runs on UWP.\n\n\n\n\n\n\nTo make native views consumable via XAML, add XML namespaces for each platform we'll be embedding views from.\n\n\nWe'll add the namespace for the UWP native controls as part of the ContentPage declaration that we created in the previous task (CameraPage in our example):\n\n\nContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n        x:Class=\"App1.CameraPage\"\n\n        xmlns:win=\"clr-namespace:Windows.UI.Xaml.Controls;assembly=Windows,\n            Version=255.255.255.255, Culture=neutral, PublicKeyToken=null,\n            ContentType=WindowsRuntime;targetPlatform=Windows\"\n        \n\n\n\n\n\n\n\n\nWe can now add two UWP XAML controls directly to the page.\n\n\n\n\nAdd the InkCanvas below the camera image but above the nose image.\n\n\nAdd the InkToolbar control between the top button and the imageGrid.\nStackLayout VerticalOptions=\"FillAndExpand\"\n            HorizontalOptions=\"FillAndExpand\"\n            Orientation=\"Vertical\"\n            Spacing=\"15\"\n\n    \nButton x:Name=\"captureButton\"\n            Text=\"Capture Image\"\n            Clicked=\"captureButton_Clicked\"\n/Button\n\n\n    \n!-- UWP XAML CONTROL InkToolbar --\n\n    \nContentView x:Name=\"InkingToolbar\"\n\n        \nwin:InkToolbar\n/win:InkToolbar\n\n    \n/ContentView\n\n\n    \nGrid x:Name=\"ImageGrid\" IsVisible=\"False\"\n\n        \nImage x:Name=\"image\"\n/Image\n\n\n        \n!-- UWP XAML CONTROL InkCanvas --\n\n        \nContentView x:Name=\"InkingContent\"\n\n            \nwin:InkCanvas\n/win:InkCanvas\n\n        \n/ContentView\n\n\n        \nAbsoluteLayout\n\n            \n!-- ... --\n\n        \n/AbsoluteLayout\n\n\n    \n/Grid\n\n\n/StackLayout\n\n\n\n\n\n\n\n\n\n\nNote: It is not possible to name native views, so we use a ContentView as a way to get a reference to the native views in our code-behind file.\n\n\n\n\n\n\n\n\nTo use the native views in the code behind, we need to use compilation directives, as the native views will only be used on the platform in which they are available. In this case, the InkCanvas and InkToolbar are only available on UWP, so we need to use the \nWINDOWS_UWP\n directive to wrap our code.\n\n\nIn the constructor of our page, after the call to \nInitializeComponent\n, we need to bind the InkToolbar to the InkCanvas, and then set the input device type of the InkCanvas to all input types:\n\n\n#if WINDOWS_UWP\n    var inkingWrapper = (Xamarin.Forms.Platform.UWP.NativeViewWrapper)InkingContent.Content;\n    var inkCanvas = (Windows.UI.Xaml.Controls.InkCanvas)inkingWrapper.NativeElement;\n    inkCanvas.InkPresenter.InputDeviceTypes =\n        Windows.UI.Core.CoreInputDeviceTypes.Touch |\n        Windows.UI.Core.CoreInputDeviceTypes.Mouse |\n        Windows.UI.Core.CoreInputDeviceTypes.Pen;\n\n    var inkToolbarWrapper = (Xamarin.Forms.Platform.UWP.NativeViewWrapper)InkingToolbar.Content;\n    var inkToolbar = (Windows.UI.Xaml.Controls.InkToolbar)inkToolbarWrapper.NativeElement;\n    inkToolbar.TargetInkCanvas = inkCanvas;\n#endif\n\n\n\n\n\n\n\nIf you run into a null reference exception, check to see if the following line is added above your page class definition:\n\n\n[XamlCompilation(XamlCompilationOptions.Compile)]\n\n\n\n\n\n\n\nXamarin adds this line to any new page created to \nimprove the performance\n of XAML pages. However, this optimization will not work when using native views and needs to be deleted.\n\n\nAnd you're done! Run the app and draw the perfect masterpiece. You should now be able to start the app, select a nose, capture an image, position the nose where you want, and on UWP, draw using the pen, mouse or touch.\n\n\nCongratulations, you are now done with the first deliverable. You should now be able to take control and start adding more features on your own. Take a look at the other deliverables and tasks for ideas and small hints about how to implement other features that would be useful for our users.\n\n\nReferences\n\n\n\n\nXamarin Native Views\n\n\n\n\ncontinue to \nnext task \n \n\n\nThe solution for this task is located \nhere", 
            "title": "313 InkCanvas"
        }, 
        {
            "location": "/stories/3/313_InkCanvas/#task-313-overlay-noses-and-support-inking-for-uwp", 
            "text": "Our marketing department wants to allow users of our app to capture images, and position Knowzy products over the image to see how they would look. It's a fun way to try the product without actually buying it. The marketing department is hoping that these images will be shared on social media to spread the word.  Goals for this task:   Overlay noses on top of an image and allow nose to be manipulated.  Support inking on UWP devices.  For this task, you will need to access APIs that are specific to each platform. We've done the research on how to do it and have included the steps below.", 
            "title": "Task 3.1.3 - Overlay noses and support inking for UWP"
        }, 
        {
            "location": "/stories/3/313_InkCanvas/#prerequisites", 
            "text": "This task has a dependency on  Task 3.1.2  and all of it's prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/313_InkCanvas/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/313_InkCanvas/#overlay-nose-on-image-and-allow-to-be-manipulated", 
            "text": "Once the image is captured, let's add the nose image on top of it, and allow the user to move it by panning and resize it by pinching.    Open the XAML page that you added in the previous task (CameraPage.xaml in this example).    Add code that does these things:    Wraps the image element that hosts the camera image into a new Grid element.  This will allow you to position multiple elements on top of each other.    Adds a new  AbsoluteLayout  element below the existing Image in the grid.    Adds a new Image element inside of the AbsoluteLayout element, which will be used to host the nose image.    Here is what the final result should look like:  Before:  Image x:Name=\"image\" /Image   After:  Grid x:Name=\"imageGrid\" IsVisible=\"False\" \n     Image x:Name=\"image\" /Image \n     AbsoluteLayout \n         Image x:Name=\"noseImage\"\n            HeightRequest=\"120\"\n            WidthRequest=\"120\"\n            AbsoluteLayout.LayoutBounds=\"0, 0, AutoSize, AutoSize\"\n            AbsoluteLayout.LayoutFlags=\"None\" \n         /Image \n     /AbsoluteLayout  /Grid     Notice that in the XAML, we've set the visibility of the Grid to False. Once the image has been captured, we can set the visibility to True, and then set the source of the noseImage element. Make those changes in the captureButton_Clicked event handler. When you're done, your code should look something like this:  private async void captureButton_Clicked(object sender, EventArgs e)\n{\n    var photoService = DependencyService.Get IPhotoService ();\n    if (photoService != null)\n    {\n        var imageBytes = await photoService.TakePhotoAsync();\n        noseImage.Source = ImageSource.FromUri(new Uri(_nose.Image)); // set source of nose image\n        image.Source = ImageSource.FromStream(() =  new MemoryStream(imageBytes));\n        imageGrid.IsVisible = true; // set visibility to true\n    }\n}    To allow elements to be manipulated by panning or pinching, Xamarin.Forms has built in  Gestures . Inside of the the noseImage element that we just added to our page, let's add a new PanGestureRecognizer and a new PinchGestureRecognizer, which will subscribe to the relevant events so we can manipulate the nose image with gestures:  Image x:Name=\"noseImage\"\n        HeightRequest=\"120\"\n        WidthRequest=\"120\"\n        AbsoluteLayout.LayoutBounds=\"0, 0, AutoSize, AutoSize\"\n        AbsoluteLayout.LayoutFlags=\"None\" \n\n     !-- Gesture Recognizers -- \n     Image.GestureRecognizers \n         PanGestureRecognizer PanUpdated=\"OnPanUpdated\" / \n         PinchGestureRecognizer PinchUpdated=\"OnPinchUpdated\" / \n     /Image.GestureRecognizers  /Image     In your code-behind file (CameraPage.xaml.cs in this example), implement the event handlers for the gestures that we just added. The nose moves with the finger or mouse, and the scale of the image changes when the image is pinched:  private void OnPanUpdated(object sender, PanUpdatedEventArgs e)\n{\n    switch (e.StatusType)\n    {\n        case GestureStatus.Started:\n            var bounds = AbsoluteLayout.GetLayoutBounds(noseImage);\n            bounds.X += noseImage.TranslationX;\n            bounds.Y += noseImage.TranslationY;\n            AbsoluteLayout.SetLayoutBounds(noseImage, bounds);\n            noseImage.TranslationX = 0;\n            noseImage.TranslationY = 0;\n            break;\n\n        case GestureStatus.Running:\n            noseImage.TranslationX = e.TotalX;\n            noseImage.TranslationY = e.TotalY;\n            break;\n    }\n}\n\nprivate void OnPinchUpdated(object sender, PinchGestureUpdatedEventArgs e)\n{\n    switch (e.Status)\n    {\n        case GestureStatus.Running:\n            noseImage.Scale *= e.Scale;\n            break;\n    }\n}  That's it. Run the app, take a photo, position the nose, and have fun.", 
            "title": "Overlay nose on image and allow to be manipulated"
        }, 
        {
            "location": "/stories/3/313_InkCanvas/#add-inking-support-on-uwp-devices", 
            "text": "In addition to using the built in Xamarin.Forms controls, developers have full access to native platform controls through  native view declaration . This allows developers to use native or custom controls (such as the UWP Community Toolkit), and mix them with Xamarin.Forms controls directly in XAML. For our app, we can use the native InkCanvas control and InkToolbar control when the app runs on UWP.    To make native views consumable via XAML, add XML namespaces for each platform we'll be embedding views from.  We'll add the namespace for the UWP native controls as part of the ContentPage declaration that we created in the previous task (CameraPage in our example):  ContentPage xmlns=\"http://xamarin.com/schemas/2014/forms\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2009/xaml\"\n        x:Class=\"App1.CameraPage\"\n\n        xmlns:win=\"clr-namespace:Windows.UI.Xaml.Controls;assembly=Windows,\n            Version=255.255.255.255, Culture=neutral, PublicKeyToken=null,\n            ContentType=WindowsRuntime;targetPlatform=Windows\"\n             We can now add two UWP XAML controls directly to the page.   Add the InkCanvas below the camera image but above the nose image.  Add the InkToolbar control between the top button and the imageGrid. StackLayout VerticalOptions=\"FillAndExpand\"\n            HorizontalOptions=\"FillAndExpand\"\n            Orientation=\"Vertical\"\n            Spacing=\"15\" \n     Button x:Name=\"captureButton\"\n            Text=\"Capture Image\"\n            Clicked=\"captureButton_Clicked\" /Button \n\n     !-- UWP XAML CONTROL InkToolbar -- \n     ContentView x:Name=\"InkingToolbar\" \n         win:InkToolbar /win:InkToolbar \n     /ContentView \n\n     Grid x:Name=\"ImageGrid\" IsVisible=\"False\" \n         Image x:Name=\"image\" /Image \n\n         !-- UWP XAML CONTROL InkCanvas -- \n         ContentView x:Name=\"InkingContent\" \n             win:InkCanvas /win:InkCanvas \n         /ContentView \n\n         AbsoluteLayout \n             !-- ... -- \n         /AbsoluteLayout \n\n     /Grid  /StackLayout      Note: It is not possible to name native views, so we use a ContentView as a way to get a reference to the native views in our code-behind file.     To use the native views in the code behind, we need to use compilation directives, as the native views will only be used on the platform in which they are available. In this case, the InkCanvas and InkToolbar are only available on UWP, so we need to use the  WINDOWS_UWP  directive to wrap our code.  In the constructor of our page, after the call to  InitializeComponent , we need to bind the InkToolbar to the InkCanvas, and then set the input device type of the InkCanvas to all input types:  #if WINDOWS_UWP\n    var inkingWrapper = (Xamarin.Forms.Platform.UWP.NativeViewWrapper)InkingContent.Content;\n    var inkCanvas = (Windows.UI.Xaml.Controls.InkCanvas)inkingWrapper.NativeElement;\n    inkCanvas.InkPresenter.InputDeviceTypes =\n        Windows.UI.Core.CoreInputDeviceTypes.Touch |\n        Windows.UI.Core.CoreInputDeviceTypes.Mouse |\n        Windows.UI.Core.CoreInputDeviceTypes.Pen;\n\n    var inkToolbarWrapper = (Xamarin.Forms.Platform.UWP.NativeViewWrapper)InkingToolbar.Content;\n    var inkToolbar = (Windows.UI.Xaml.Controls.InkToolbar)inkToolbarWrapper.NativeElement;\n    inkToolbar.TargetInkCanvas = inkCanvas;\n#endif    If you run into a null reference exception, check to see if the following line is added above your page class definition:  [XamlCompilation(XamlCompilationOptions.Compile)]    Xamarin adds this line to any new page created to  improve the performance  of XAML pages. However, this optimization will not work when using native views and needs to be deleted.  And you're done! Run the app and draw the perfect masterpiece. You should now be able to start the app, select a nose, capture an image, position the nose where you want, and on UWP, draw using the pen, mouse or touch.  Congratulations, you are now done with the first deliverable. You should now be able to take control and start adding more features on your own. Take a look at the other deliverables and tasks for ideas and small hints about how to implement other features that would be useful for our users.", 
            "title": "Add inking support on UWP devices."
        }, 
        {
            "location": "/stories/3/313_InkCanvas/#references", 
            "text": "Xamarin Native Views", 
            "title": "References"
        }, 
        {
            "location": "/stories/3/313_InkCanvas/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/313_InkCanvas/#the-solution-for-this-task-is-located-here", 
            "text": "", 
            "title": "The solution for this task is located here"
        }, 
        {
            "location": "/stories/3/321_CustomVisionService/", 
            "text": "Task 3.2.1 - Set up Cognitive Services Custom Vision Service to Recognize People Wearing Knowzy Products\n\n\nOur marketing department wants to let users capture pictures of themselves wearing Knowzy products to share with their friends. Knowzy can use this information to automatically detect what products are being worn and determine the user's excitement for each of the products. This information can be used to drive improvements to those products.\n\n\nGoals for this task:\n Enable your Android and UWP app to use a Cognitive Services Custom Vision service to detect Knowzy products and the user's emotion from a captured image.\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 3.1.3\n and all of it's prerequisites.\n\n\nA Microsoft Account\n\n\n\n\nTask\n\n\nCreate a Cognitive Services \nCustom Vision Service\n API\n\n\n\n\nIn your web browser, navigate to \nhttps://customvision.ai\n\n\nClick the \nSign In\n button and enter your Microsoft Account credentials.\n\n\nCreate a new Custom Vision project by clicking the \nNew Project\n tile\n\n\nEnter a name for the project (you will need to remember this later), and select \nGeneral\n for the domain\n\n\nClick the \nCreate Project\n button to create the new Custom Vision project\n\n\nClick the \nSettings\n button and copy both the \nTraining Key\n and \nPrediction Key\n values - these will be required later\n\n\n\n\nUpload Training Images to the Custom Vision Service with Knowzy Products\n\n\nIn order for the Custom Vision Service to detect which Knowzy products appear in images submitted by the app, it must first be \ntrained\n. Training the service requires uploading a small set of images with people wearing Knowzy products in a diverse set of lighting, zooming and other conditions. Each image is \ntagged\n to tell the service what \nclassification\n the image represents. Once the service has sufficient training images, it will then be able to \nclassify\n other images (that are not part of the training set) based on matching characteristics.\n\n\nBecause you need between 10-20 images per tag to successfully train the service, we have provided a set of images that are ready to be ingested and tagged. We have also provided a tool which is able to ingest the training images directly from an \nAzure Storage\n blob account (this will save needing to upload the images). The training images are organized into separate containers for each tag.\n\n\n\n\nYou must first build the training tool. Open the solution at \n\\src\\Tools\\Tools.sln\n in Visual Studio 2017.\n\n\nBuild the solution\n\n\nOpen a command prompt and navigate to the location where Visual Studio output the built \nCustomVisionTrainer.exe\n. This is \nsrc\\Tools\\CustomVisionTrainer\\bin\\Debug\n.\n\n\nRun the \nCustomVisionTrainer.exe\n tool to upload training images for the three different Knowzy products. The tool requires you to specify the \nTraining Key\n and \nProject Name\n of your Custom Vision Service project and the name of the project:\nCustomVisionTrainer.exe {Training Key} {Project Name} https://bthackcustomvisiontrain.blob.core.windows.net/knowzy8s Knowzy8s\nCustomVisionTrainer.exe {Training Key} {Project Name} https://bthackcustomvisiontrain.blob.core.windows.net/knowzyvr KnowzyVR\nCustomVisionTrainer.exe {Training Key} {Project Name} https://bthackcustomvisiontrain.blob.core.windows.net/knowzybowzy KnowzyBowzy\n\n\n\n\n\n\n\nTrain the Model\n\n\n\n\nSwitch back to the \nCustom Vision\n portal in your web browser.\n\n\nOn the \nTraining Images\n tab, verify that the images you just uploaded using the tool are correctly displayed and tagged. \nNote:\n There may be a delay of up to 3 minutes for the images to appear.\n\n\nClick the \nTrain\n button. This will display progress and the training images are processed and the model is constructed. The process should take less than 2 minutes.\n\n\nClick on the \nPerformance\n tab. Verify that a new \nIteration\n has been created after the training has completed. Select the latest iteration and click the \nPrediction URL\n button. Select the URL under the \nIf you have an image file\n heading. This URL will need to be substituted into our code file when you integrate calling this service into our Xamarin application.\n\n\n\n\nGo to the next Task\n where you'll create a Cognitive Services Emotion API to detect the level of excitement of a user.\n\n\nReferences\n\n\n\n\nCustom Vision Service\n\n\n\n\ncontinue to \nnext task", 
            "title": "321 CustomVisionService"
        }, 
        {
            "location": "/stories/3/321_CustomVisionService/#task-321-set-up-cognitive-services-custom-vision-service-to-recognize-people-wearing-knowzy-products", 
            "text": "Our marketing department wants to let users capture pictures of themselves wearing Knowzy products to share with their friends. Knowzy can use this information to automatically detect what products are being worn and determine the user's excitement for each of the products. This information can be used to drive improvements to those products.  Goals for this task:  Enable your Android and UWP app to use a Cognitive Services Custom Vision service to detect Knowzy products and the user's emotion from a captured image.", 
            "title": "Task 3.2.1 - Set up Cognitive Services Custom Vision Service to Recognize People Wearing Knowzy Products"
        }, 
        {
            "location": "/stories/3/321_CustomVisionService/#prerequisites", 
            "text": "This task has a dependency on  Task 3.1.3  and all of it's prerequisites.  A Microsoft Account", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/321_CustomVisionService/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/321_CustomVisionService/#create-a-cognitive-services-custom-vision-service-api", 
            "text": "In your web browser, navigate to  https://customvision.ai  Click the  Sign In  button and enter your Microsoft Account credentials.  Create a new Custom Vision project by clicking the  New Project  tile  Enter a name for the project (you will need to remember this later), and select  General  for the domain  Click the  Create Project  button to create the new Custom Vision project  Click the  Settings  button and copy both the  Training Key  and  Prediction Key  values - these will be required later", 
            "title": "Create a Cognitive Services Custom Vision Service API"
        }, 
        {
            "location": "/stories/3/321_CustomVisionService/#upload-training-images-to-the-custom-vision-service-with-knowzy-products", 
            "text": "In order for the Custom Vision Service to detect which Knowzy products appear in images submitted by the app, it must first be  trained . Training the service requires uploading a small set of images with people wearing Knowzy products in a diverse set of lighting, zooming and other conditions. Each image is  tagged  to tell the service what  classification  the image represents. Once the service has sufficient training images, it will then be able to  classify  other images (that are not part of the training set) based on matching characteristics.  Because you need between 10-20 images per tag to successfully train the service, we have provided a set of images that are ready to be ingested and tagged. We have also provided a tool which is able to ingest the training images directly from an  Azure Storage  blob account (this will save needing to upload the images). The training images are organized into separate containers for each tag.   You must first build the training tool. Open the solution at  \\src\\Tools\\Tools.sln  in Visual Studio 2017.  Build the solution  Open a command prompt and navigate to the location where Visual Studio output the built  CustomVisionTrainer.exe . This is  src\\Tools\\CustomVisionTrainer\\bin\\Debug .  Run the  CustomVisionTrainer.exe  tool to upload training images for the three different Knowzy products. The tool requires you to specify the  Training Key  and  Project Name  of your Custom Vision Service project and the name of the project: CustomVisionTrainer.exe {Training Key} {Project Name} https://bthackcustomvisiontrain.blob.core.windows.net/knowzy8s Knowzy8s\nCustomVisionTrainer.exe {Training Key} {Project Name} https://bthackcustomvisiontrain.blob.core.windows.net/knowzyvr KnowzyVR\nCustomVisionTrainer.exe {Training Key} {Project Name} https://bthackcustomvisiontrain.blob.core.windows.net/knowzybowzy KnowzyBowzy", 
            "title": "Upload Training Images to the Custom Vision Service with Knowzy Products"
        }, 
        {
            "location": "/stories/3/321_CustomVisionService/#train-the-model", 
            "text": "Switch back to the  Custom Vision  portal in your web browser.  On the  Training Images  tab, verify that the images you just uploaded using the tool are correctly displayed and tagged.  Note:  There may be a delay of up to 3 minutes for the images to appear.  Click the  Train  button. This will display progress and the training images are processed and the model is constructed. The process should take less than 2 minutes.  Click on the  Performance  tab. Verify that a new  Iteration  has been created after the training has completed. Select the latest iteration and click the  Prediction URL  button. Select the URL under the  If you have an image file  heading. This URL will need to be substituted into our code file when you integrate calling this service into our Xamarin application.   Go to the next Task  where you'll create a Cognitive Services Emotion API to detect the level of excitement of a user.", 
            "title": "Train the Model"
        }, 
        {
            "location": "/stories/3/321_CustomVisionService/#references", 
            "text": "Custom Vision Service", 
            "title": "References"
        }, 
        {
            "location": "/stories/3/321_CustomVisionService/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/322_EmotionAPI/", 
            "text": "Task 3.2.2 - Set up Cognitive Services Emotion Service to Determine User's Excitement\n\n\nOur marketing department also wants to verify that Knowzy's users are super excited when wearing their Knowzy products. \n\n\nYou will create a Cognitive Services Emotion API to assess the emotional state of user's images. You will subsequently integrate calls to this account into the Xamarin app.\n\n\nGoals for this task:\n Create a Cognitive Services Emotion API account..\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 3.2.1\n and all of it's prerequisites.\n\n\nAn Azure subscription\n\n\n\n\nTask\n\n\nCreate a Cognitive Services \nEmotion API\n account\n\n\n\n\nIn your web browser, open the Azure Portal \nhttps://portal.azure.com\n\n\nCreate a new Emotion API account by clicking the \nNew Resource\n button.\n\n\nSelect \nAI + Cognitive Services\n\n\nClick the \nSee All\n link\n\n\nIn the filter bar, type \nemotion\n and hit Enter. Select the \nEmotion API (Preview)\n item\n\n\nClick the \nCreate\n button\n\n\nEnter a name, subscription and location for your account. Select \nF0\n for the Pricing tier (this tier enables 20 calls / minute). Specify a name for a new \nResource Group\n. Check the acknowledgment and the \nCreate\n button to create a new account.\n\n\nOnce the new Emotions API account has been created, on the \nOverview\n tab, select the \nEndpoint\n value. This value will be required to be specified when you integrate calling this service from the Xamarin application.\n\n\nClick \nShow Access Keys...\n. Copy the value of \nKey 1\n. This value will be required to be specified when you integrate calling this service from the Xamarin application.\n\n\n\n\nGo to the next Task\n where you'll add the calls to your Xamarin app to call both the Custom Vision service and the Emotion API service.\n\n\nReferences\n\n\n\n\nEmotion API Service\n\n\n\n\ncontinue to \nnext task", 
            "title": "322 EmotionAPI"
        }, 
        {
            "location": "/stories/3/322_EmotionAPI/#task-322-set-up-cognitive-services-emotion-service-to-determine-users-excitement", 
            "text": "Our marketing department also wants to verify that Knowzy's users are super excited when wearing their Knowzy products.   You will create a Cognitive Services Emotion API to assess the emotional state of user's images. You will subsequently integrate calls to this account into the Xamarin app.  Goals for this task:  Create a Cognitive Services Emotion API account..", 
            "title": "Task 3.2.2 - Set up Cognitive Services Emotion Service to Determine User's Excitement"
        }, 
        {
            "location": "/stories/3/322_EmotionAPI/#prerequisites", 
            "text": "This task has a dependency on  Task 3.2.1  and all of it's prerequisites.  An Azure subscription", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/322_EmotionAPI/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/322_EmotionAPI/#create-a-cognitive-services-emotion-api-account", 
            "text": "In your web browser, open the Azure Portal  https://portal.azure.com  Create a new Emotion API account by clicking the  New Resource  button.  Select  AI + Cognitive Services  Click the  See All  link  In the filter bar, type  emotion  and hit Enter. Select the  Emotion API (Preview)  item  Click the  Create  button  Enter a name, subscription and location for your account. Select  F0  for the Pricing tier (this tier enables 20 calls / minute). Specify a name for a new  Resource Group . Check the acknowledgment and the  Create  button to create a new account.  Once the new Emotions API account has been created, on the  Overview  tab, select the  Endpoint  value. This value will be required to be specified when you integrate calling this service from the Xamarin application.  Click  Show Access Keys... . Copy the value of  Key 1 . This value will be required to be specified when you integrate calling this service from the Xamarin application.   Go to the next Task  where you'll add the calls to your Xamarin app to call both the Custom Vision service and the Emotion API service.", 
            "title": "Create a Cognitive Services Emotion API account"
        }, 
        {
            "location": "/stories/3/322_EmotionAPI/#references", 
            "text": "Emotion API Service", 
            "title": "References"
        }, 
        {
            "location": "/stories/3/322_EmotionAPI/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/323_IntegrateCogSvc/", 
            "text": "Task 3.2.3 - Update Xamarin App to call Coginitive Services APIs\n\n\nIt is now time to integrate calls to the Cognitive Services that you created in the previous steps into the Xamarin application. These calls can be made directly from the app. An alternative design would be to host functionality on Azure to make these calls.\n\n\nGoals for this task:\n Create new functionality to the previously created Camera Page which will call the Cognitive Services APIs and display the results to the user.\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 3.2.2\n and all of it's prerequisites.\n\n\n\n\nTask\n\n\nAdd a new layout to the Camera Page to display predictions\n\n\n\n\nIn Visual Studio open CameraPage.xaml\n\n\nUpdate the XAML to add a new \nGrid\n and other elements to display prediction results after calling Cognitive Services. Add the following snippet immediately below the \nButton\n element:\nGrid\n\n    \nGrid.ColumnDefinitions\n\n        \nColumnDefinition Width=\"Auto\" /\n\n        \nColumnDefinition Width=\"*\" /\n\n    \n/Grid.ColumnDefinitions\n\n    \nGrid.RowDefinitions\n\n        \nRowDefinition Height=\"Auto\" /\n\n        \nRowDefinition Height=\"Auto\" /\n\n        \nRowDefinition Height=\"Auto\" /\n\n    \n/Grid.RowDefinitions\n\n    \nLabel Grid.Row=\"0\" Grid.Column=\"0\" Text=\"Knowzy Products: \"\n/Label\n\n    \nLabel Grid.Row=\"0\" Grid.Column=\"1\" FontAttributes=\"Bold\"  x:Name=\"productTags\"\n/Label\n\n    \nLabel Grid.Row=\"1\" Grid.Column=\"0\" Text=\"Probability (%): \"\n/Label\n\n    \nLabel Grid.Row=\"1\" Grid.Column=\"1\" FontAttributes=\"Bold\" x:Name=\"productTagProbability\"\n/Label\n\n    \nLabel Grid.Row=\"2\" Grid.Column=\"0\" Text=\"Emotion: \"\n/Label\n\n    \nLabel Grid.Row=\"2\" Grid.Column=\"1\" FontAttributes=\"Bold\" x:Name=\"emotionTag\"\n/Label\n\n\n/Grid\n\n\n\n\n\n\n\n\nAdd code to call the Custom Vision service\n\n\n\n\n\n\nOpen the code-behind file for CameraPage.xaml. \n\n\n\n\n\n\nAdd the following \nusing\n statements at the top of the file:\n\n\nusing System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.IO;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;\n\n\n\n\n\n\n\nNavigate to the \ncaptureButton_Clicked\n method and update the body with the following code to invoke the \nCustom Vision\n service and display the results.\n  \nNote:\n You must replace the \nPrediction-Key\n header with the \nPrediction Key\n value from your Custom Vision project. Additionally, you must replace the \nurl\n with the \nPrediction URL\n you obtained after training your model in the prior task: \n\n\nvar photoService = DependencyService.Get\nIPhotoService\n();\nif (photoService != null)\n{\n    var imageBytes = await photoService.TakePhotoAsync();\n    noseImage.Source = ImageSource.FromUri(new Uri(_nose.Image)); // set source of nose image\n    image.Source = ImageSource.FromStream(() =\n new MemoryStream(imageBytes));\n    imageGrid.IsVisible = true; // set visibility to true\n\n    // Invoke Cognitive Services to get predictions on the image\n    productTags.Text = \"Predicting...\";\n    productTagProbability.Text = \"\";\n    emotionTag.Text = \"\";\n\n    // Invoke the custom vision prediction api\n    var client = new HttpClient();\n\n    // Request headers - replace this example key with your valid subscription key.\n    client.DefaultRequestHeaders.Add(\"Prediction-Key\", \"63fe389c4f96433ba807ee948e7aa98f\");\n\n    // Prediction URL - replace this example URL with your valid prediction URL obtained after training the model.\n    string url = \"https://southcentralus.api.cognitive.microsoft.com/customvision/v1.0/Prediction/a2545d9c-f6e9-41d5-9807-28991bec747c/image?iterationId=2f51acdf-f96c-481c-af49-6cae71e7a2cb\";\n    using (var content = new ByteArrayContent(imageBytes))\n    {\n        content.Headers.ContentType = new MediaTypeHeaderValue(\"application/octet-stream\");\n        var response = await client.PostAsync(url, content);\n        dynamic predictionResponse = await response.Content.ReadAsStringAsync()\n            .ContinueWith((readTask) =\n JsonConvert.DeserializeObject(readTask.Result));\n        productTags.Text = predictionResponse.Predictions[0].Tag;\n        productTagProbability.Text = (predictionResponse.Predictions[0].Probability.Value * 100).ToString();\n    }\n}\n\n\n\n\n\n\n\n\n\n\n\nYou can now build and run the project. When you capture the image, make sure you are wearing one of the Knowzy products. The Custom Vision service will predict which product you are wearing with a specified probability.\n\n\n\n\n\n\nAdd code to call the Emotion API service\n\n\n\n\n\n\nOpen the code-behind file for CameraPage.xaml. \n\n\n\n\nNavigate to the \ncaptureButton_Clicked\n method and update the body with the following code to invoke the \nEmotions API\n services and display the results. \n  Because we are now calling both the \nCustom Vision\n and \nEmotions API\n services, we do this in parallel to improve performance. \n  \nNote:\n You must replace the \nOcp-Apim-Subscription-Key\n header and \nurl\n value with the values from your Emotions API account that you saved in the previous task: \nvar photoService = DependencyService.Get\nIPhotoService\n();\nif (photoService != null)\n{\n    var imageBytes = await photoService.TakePhotoAsync();\n    noseImage.Source = ImageSource.FromUri(new Uri(_nose.Image)); // set source of nose image\n    image.Source = ImageSource.FromStream(() =\n new MemoryStream(imageBytes));\n    imageGrid.IsVisible = true; // set visibility to true\n\n    // Invoke Cognitive Services to get predictions on the image\n    productTags.Text = \"Predicting...\";\n    productTagProbability.Text = \"\";\n    emotionTag.Text = \"\";\n\n    // Invoke the custom vision prediction api\n    var customVisionTask = Task.Run(async () =\n\n    {\n        var client = new HttpClient();\n        // Request headers - replace this example key with your valid subscription key.\n        client.DefaultRequestHeaders.Add(\"Prediction-Key\", \"63fe389c4f96433ba807ee948e7aa98f\");\n\n        // Prediction URL - replace this example URL with your valid prediction URL obtained after training the model.\n        string url = \"https://southcentralus.api.cognitive.microsoft.com/customvision/v1.0/Prediction/a2545d9c-f6e9-41d5-9807-28991bec747c/image?iterationId=2f51acdf-f96c-481c-af49-6cae71e7a2cb\";\n        using (var content = new ByteArrayContent(imageBytes))\n        {\n            content.Headers.ContentType = new MediaTypeHeaderValue(\"application/octet-stream\");\n            var response = await client.PostAsync(url, content);\n            dynamic predictionResponse = await response.Content.ReadAsStringAsync()\n                .ContinueWith((readTask) =\n JsonConvert.DeserializeObject(readTask.Result));\n            return Tuple.Create(predictionResponse.Predictions[0].Tag, predictionResponse.Predictions[0].Probability.Value * 100);\n        }\n    });\n\n    // Invoke the Emotion API in parallel\n    var emotionTask = Task.Run(async () =\n\n    {\n        var client = new HttpClient();\n        // Request headers - replace this example key with your valid key.\n        client.DefaultRequestHeaders.Add(\"Ocp-Apim-Subscription-Key\", \"7af37d1e3e6048539c76274fd4c64d72\");\n\n        // NOTE: You must use the same region in your REST call as you used to obtain your subscription keys.\n        //   For example, if you obtained your subscription keys from westcentralus, replace \"westus\" in the \n        //   URI below with \"westcentralus\".\n        string uri = \"https://westus.api.cognitive.microsoft.com/emotion/v1.0/recognize\";\n        using (var content = new ByteArrayContent(imageBytes))\n        {\n            // This example uses content type \"application/octet-stream\".\n            // The other content types you can use are \"application/json\" and \"multipart/form-data\".\n            content.Headers.ContentType = new MediaTypeHeaderValue(\"application/octet-stream\");\n            var response = await client.PostAsync(uri, content);\n            dynamic detectionResponse = await response.Content.ReadAsStringAsync()\n                .ContinueWith((readTask) =\n JsonConvert.DeserializeObject(readTask.Result));\n            // See the format of the JSON response here: https://westus.dev.cognitive.microsoft.com/docs/services/5639d931ca73072154c1ce89/operations/563b31ea778daf121cc3a5fa\n            JObject scores = detectionResponse[0].scores;\n            var highestScore = scores.Properties().OrderByDescending(score =\n (double)((JValue)score.Value).Value)\n                .First();\n            return Tuple.Create(highestScore.Name, (double)((JValue)highestScore.Value).Value);\n        }\n    });\n\n    await Task.WhenAll(customVisionTask, emotionTask);\n\n    // Update the UI\n    productTags.Text = customVisionTask.Result.Item1;\n    productTagProbability.Text = customVisionTask.Result.Item2.ToString();\n    emotionTag.Text = emotionTask.Result.Item1;\n}\n\n\n\n\n\n\n\n\n\n\n\nYou can now build and run the project. When you now capture an image, both the \nCustom Vision\n AND \nEmotions API\n will be called to detect the Knowzy product and how excited the user feels when wearing it. Make sure you wear a Knowzy product and try out different facial expressions to represent emotions.\n\n\n\n\n\n\nReferences\n\n\n\n\nCustom Vision Service Quickstart\n\n\nEmotion API Service Quickstart\n\n\n\n\ncontinue to \nnext task", 
            "title": "323 IntegrateCogSvc"
        }, 
        {
            "location": "/stories/3/323_IntegrateCogSvc/#task-323-update-xamarin-app-to-call-coginitive-services-apis", 
            "text": "It is now time to integrate calls to the Cognitive Services that you created in the previous steps into the Xamarin application. These calls can be made directly from the app. An alternative design would be to host functionality on Azure to make these calls.  Goals for this task:  Create new functionality to the previously created Camera Page which will call the Cognitive Services APIs and display the results to the user.", 
            "title": "Task 3.2.3 - Update Xamarin App to call Coginitive Services APIs"
        }, 
        {
            "location": "/stories/3/323_IntegrateCogSvc/#prerequisites", 
            "text": "This task has a dependency on  Task 3.2.2  and all of it's prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/323_IntegrateCogSvc/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/323_IntegrateCogSvc/#add-a-new-layout-to-the-camera-page-to-display-predictions", 
            "text": "In Visual Studio open CameraPage.xaml  Update the XAML to add a new  Grid  and other elements to display prediction results after calling Cognitive Services. Add the following snippet immediately below the  Button  element: Grid \n     Grid.ColumnDefinitions \n         ColumnDefinition Width=\"Auto\" / \n         ColumnDefinition Width=\"*\" / \n     /Grid.ColumnDefinitions \n     Grid.RowDefinitions \n         RowDefinition Height=\"Auto\" / \n         RowDefinition Height=\"Auto\" / \n         RowDefinition Height=\"Auto\" / \n     /Grid.RowDefinitions \n     Label Grid.Row=\"0\" Grid.Column=\"0\" Text=\"Knowzy Products: \" /Label \n     Label Grid.Row=\"0\" Grid.Column=\"1\" FontAttributes=\"Bold\"  x:Name=\"productTags\" /Label \n     Label Grid.Row=\"1\" Grid.Column=\"0\" Text=\"Probability (%): \" /Label \n     Label Grid.Row=\"1\" Grid.Column=\"1\" FontAttributes=\"Bold\" x:Name=\"productTagProbability\" /Label \n     Label Grid.Row=\"2\" Grid.Column=\"0\" Text=\"Emotion: \" /Label \n     Label Grid.Row=\"2\" Grid.Column=\"1\" FontAttributes=\"Bold\" x:Name=\"emotionTag\" /Label  /Grid", 
            "title": "Add a new layout to the Camera Page to display predictions"
        }, 
        {
            "location": "/stories/3/323_IntegrateCogSvc/#add-code-to-call-the-custom-vision-service", 
            "text": "Open the code-behind file for CameraPage.xaml.     Add the following  using  statements at the top of the file:  using System.Net.Http;\nusing System.Net.Http.Headers;\nusing System.IO;\nusing Newtonsoft.Json;\nusing Newtonsoft.Json.Linq;    Navigate to the  captureButton_Clicked  method and update the body with the following code to invoke the  Custom Vision  service and display the results.\n   Note:  You must replace the  Prediction-Key  header with the  Prediction Key  value from your Custom Vision project. Additionally, you must replace the  url  with the  Prediction URL  you obtained after training your model in the prior task:   var photoService = DependencyService.Get IPhotoService ();\nif (photoService != null)\n{\n    var imageBytes = await photoService.TakePhotoAsync();\n    noseImage.Source = ImageSource.FromUri(new Uri(_nose.Image)); // set source of nose image\n    image.Source = ImageSource.FromStream(() =  new MemoryStream(imageBytes));\n    imageGrid.IsVisible = true; // set visibility to true\n\n    // Invoke Cognitive Services to get predictions on the image\n    productTags.Text = \"Predicting...\";\n    productTagProbability.Text = \"\";\n    emotionTag.Text = \"\";\n\n    // Invoke the custom vision prediction api\n    var client = new HttpClient();\n\n    // Request headers - replace this example key with your valid subscription key.\n    client.DefaultRequestHeaders.Add(\"Prediction-Key\", \"63fe389c4f96433ba807ee948e7aa98f\");\n\n    // Prediction URL - replace this example URL with your valid prediction URL obtained after training the model.\n    string url = \"https://southcentralus.api.cognitive.microsoft.com/customvision/v1.0/Prediction/a2545d9c-f6e9-41d5-9807-28991bec747c/image?iterationId=2f51acdf-f96c-481c-af49-6cae71e7a2cb\";\n    using (var content = new ByteArrayContent(imageBytes))\n    {\n        content.Headers.ContentType = new MediaTypeHeaderValue(\"application/octet-stream\");\n        var response = await client.PostAsync(url, content);\n        dynamic predictionResponse = await response.Content.ReadAsStringAsync()\n            .ContinueWith((readTask) =  JsonConvert.DeserializeObject(readTask.Result));\n        productTags.Text = predictionResponse.Predictions[0].Tag;\n        productTagProbability.Text = (predictionResponse.Predictions[0].Probability.Value * 100).ToString();\n    }\n}      You can now build and run the project. When you capture the image, make sure you are wearing one of the Knowzy products. The Custom Vision service will predict which product you are wearing with a specified probability.", 
            "title": "Add code to call the Custom Vision service"
        }, 
        {
            "location": "/stories/3/323_IntegrateCogSvc/#add-code-to-call-the-emotion-api-service", 
            "text": "Open the code-behind file for CameraPage.xaml.    Navigate to the  captureButton_Clicked  method and update the body with the following code to invoke the  Emotions API  services and display the results. \n  Because we are now calling both the  Custom Vision  and  Emotions API  services, we do this in parallel to improve performance. \n   Note:  You must replace the  Ocp-Apim-Subscription-Key  header and  url  value with the values from your Emotions API account that you saved in the previous task:  var photoService = DependencyService.Get IPhotoService ();\nif (photoService != null)\n{\n    var imageBytes = await photoService.TakePhotoAsync();\n    noseImage.Source = ImageSource.FromUri(new Uri(_nose.Image)); // set source of nose image\n    image.Source = ImageSource.FromStream(() =  new MemoryStream(imageBytes));\n    imageGrid.IsVisible = true; // set visibility to true\n\n    // Invoke Cognitive Services to get predictions on the image\n    productTags.Text = \"Predicting...\";\n    productTagProbability.Text = \"\";\n    emotionTag.Text = \"\";\n\n    // Invoke the custom vision prediction api\n    var customVisionTask = Task.Run(async () = \n    {\n        var client = new HttpClient();\n        // Request headers - replace this example key with your valid subscription key.\n        client.DefaultRequestHeaders.Add(\"Prediction-Key\", \"63fe389c4f96433ba807ee948e7aa98f\");\n\n        // Prediction URL - replace this example URL with your valid prediction URL obtained after training the model.\n        string url = \"https://southcentralus.api.cognitive.microsoft.com/customvision/v1.0/Prediction/a2545d9c-f6e9-41d5-9807-28991bec747c/image?iterationId=2f51acdf-f96c-481c-af49-6cae71e7a2cb\";\n        using (var content = new ByteArrayContent(imageBytes))\n        {\n            content.Headers.ContentType = new MediaTypeHeaderValue(\"application/octet-stream\");\n            var response = await client.PostAsync(url, content);\n            dynamic predictionResponse = await response.Content.ReadAsStringAsync()\n                .ContinueWith((readTask) =  JsonConvert.DeserializeObject(readTask.Result));\n            return Tuple.Create(predictionResponse.Predictions[0].Tag, predictionResponse.Predictions[0].Probability.Value * 100);\n        }\n    });\n\n    // Invoke the Emotion API in parallel\n    var emotionTask = Task.Run(async () = \n    {\n        var client = new HttpClient();\n        // Request headers - replace this example key with your valid key.\n        client.DefaultRequestHeaders.Add(\"Ocp-Apim-Subscription-Key\", \"7af37d1e3e6048539c76274fd4c64d72\");\n\n        // NOTE: You must use the same region in your REST call as you used to obtain your subscription keys.\n        //   For example, if you obtained your subscription keys from westcentralus, replace \"westus\" in the \n        //   URI below with \"westcentralus\".\n        string uri = \"https://westus.api.cognitive.microsoft.com/emotion/v1.0/recognize\";\n        using (var content = new ByteArrayContent(imageBytes))\n        {\n            // This example uses content type \"application/octet-stream\".\n            // The other content types you can use are \"application/json\" and \"multipart/form-data\".\n            content.Headers.ContentType = new MediaTypeHeaderValue(\"application/octet-stream\");\n            var response = await client.PostAsync(uri, content);\n            dynamic detectionResponse = await response.Content.ReadAsStringAsync()\n                .ContinueWith((readTask) =  JsonConvert.DeserializeObject(readTask.Result));\n            // See the format of the JSON response here: https://westus.dev.cognitive.microsoft.com/docs/services/5639d931ca73072154c1ce89/operations/563b31ea778daf121cc3a5fa\n            JObject scores = detectionResponse[0].scores;\n            var highestScore = scores.Properties().OrderByDescending(score =  (double)((JValue)score.Value).Value)\n                .First();\n            return Tuple.Create(highestScore.Name, (double)((JValue)highestScore.Value).Value);\n        }\n    });\n\n    await Task.WhenAll(customVisionTask, emotionTask);\n\n    // Update the UI\n    productTags.Text = customVisionTask.Result.Item1;\n    productTagProbability.Text = customVisionTask.Result.Item2.ToString();\n    emotionTag.Text = emotionTask.Result.Item1;\n}      You can now build and run the project. When you now capture an image, both the  Custom Vision  AND  Emotions API  will be called to detect the Knowzy product and how excited the user feels when wearing it. Make sure you wear a Knowzy product and try out different facial expressions to represent emotions.", 
            "title": "Add code to call the Emotion API service"
        }, 
        {
            "location": "/stories/3/323_IntegrateCogSvc/#references", 
            "text": "Custom Vision Service Quickstart  Emotion API Service Quickstart", 
            "title": "References"
        }, 
        {
            "location": "/stories/3/323_IntegrateCogSvc/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/331_Social/", 
            "text": "Task 3.3.1 - Support sharing images to Social Networks\n\n\nOur users want to be able to share images with their social networks. We want users to spread the word about our products. Enabling the application to share content on every platform will make everyone happy.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 3.1.2\n and all of it's prerequisites\n\n\nTask\n\n\n\n\nSupport sharing content through each platform's native share integration.\n\n\nSupport sharing to Facebook or Twitter directly from the app (min UWP).\n\n\n\n\nComments\n\n\n@ 9:23am\n\n\nWe can use the same method as in \nTask 3.1.2\n to create a sharing class for every platform. Found \nthis blog\n post that does something similar.\n\n\n@ 10:31am\n\n\nWe can use the UWP Community toolkit to share to \nFacebook\n and/or \nTwitter\n directly on UWP. Sharing to facebook seems super easy:\n\n\n// Initialize service\nFacebookService.Instance.Initialize(\nAppID\n);\n\n// Login to Facebook\nif (!await FacebookService.Instance.LoginAsync())\n{\n    return;\n}\n\n// Post a message with a picture on your wall\nawait FacebookService.Instance.PostPictureToFeedAsync(\nTitle\n, picture.Name, stream);\n\n\n\n\ncontinue to \nnext task", 
            "title": "331 Social"
        }, 
        {
            "location": "/stories/3/331_Social/#task-331-support-sharing-images-to-social-networks", 
            "text": "Our users want to be able to share images with their social networks. We want users to spread the word about our products. Enabling the application to share content on every platform will make everyone happy.", 
            "title": "Task 3.3.1 - Support sharing images to Social Networks"
        }, 
        {
            "location": "/stories/3/331_Social/#prerequisites", 
            "text": "This task has a dependency on  Task 3.1.2  and all of it's prerequisites", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/331_Social/#task", 
            "text": "Support sharing content through each platform's native share integration.  Support sharing to Facebook or Twitter directly from the app (min UWP).", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/331_Social/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/3/331_Social/#923am", 
            "text": "We can use the same method as in  Task 3.1.2  to create a sharing class for every platform. Found  this blog  post that does something similar.", 
            "title": "@ 9:23am"
        }, 
        {
            "location": "/stories/3/331_Social/#1031am", 
            "text": "We can use the UWP Community toolkit to share to  Facebook  and/or  Twitter  directly on UWP. Sharing to facebook seems super easy:  // Initialize service\nFacebookService.Instance.Initialize( AppID );\n\n// Login to Facebook\nif (!await FacebookService.Instance.LoginAsync())\n{\n    return;\n}\n\n// Post a message with a picture on your wall\nawait FacebookService.Instance.PostPictureToFeedAsync( Title , picture.Name, stream);", 
            "title": "@ 10:31am"
        }, 
        {
            "location": "/stories/3/331_Social/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/332_Rome/", 
            "text": "Task 3.3.2 - Capture images remotely\n\n\nMany users like to launch and control desktop apps remotely from their phone.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 3.1.2\n and all of it's prerequisites.\n\n\nTask\n\n\n\n\nSupport launching the app remotely on UWP from Android.\n\n\nSupport controlling the app remotely on UWP from Android.\n\n\n\n\nComments\n\n\n@ 9:12am\n\n\nI found \nthis blog post\n that walks through using the Project Rome SDK to use android to launch and control the app on PC, it's exactly what we need.\n\n\n@ 10:21am\n\n\nCheck out \nProject Rome\n for docs and more samples\n\n\n@ 10:45am\n\n\nWe can use an App Service to support the messaging between Android and UWP. Here is great \nblog post\n on exactly that. I found some resources on creating app services:\n\n\n\n\nDocs on creating and consuming app service\n\n\nDocs on communicating with a remote app service\n\n\nApp service sample\n\n\n\n\ncontinue to \nnext task", 
            "title": "332 Rome"
        }, 
        {
            "location": "/stories/3/332_Rome/#task-332-capture-images-remotely", 
            "text": "Many users like to launch and control desktop apps remotely from their phone.", 
            "title": "Task 3.3.2 - Capture images remotely"
        }, 
        {
            "location": "/stories/3/332_Rome/#prerequisites", 
            "text": "This task has a dependency on  Task 3.1.2  and all of it's prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/332_Rome/#task", 
            "text": "Support launching the app remotely on UWP from Android.  Support controlling the app remotely on UWP from Android.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/332_Rome/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/3/332_Rome/#912am", 
            "text": "I found  this blog post  that walks through using the Project Rome SDK to use android to launch and control the app on PC, it's exactly what we need.", 
            "title": "@ 9:12am"
        }, 
        {
            "location": "/stories/3/332_Rome/#1021am", 
            "text": "Check out  Project Rome  for docs and more samples", 
            "title": "@ 10:21am"
        }, 
        {
            "location": "/stories/3/332_Rome/#1045am", 
            "text": "We can use an App Service to support the messaging between Android and UWP. Here is great  blog post  on exactly that. I found some resources on creating app services:   Docs on creating and consuming app service  Docs on communicating with a remote app service  App service sample", 
            "title": "@ 10:45am"
        }, 
        {
            "location": "/stories/3/332_Rome/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/341_CognitiveServices/", 
            "text": "Task 3.4.1 - Set up Cognitive Services for image face analysis in Azure\n\n\nThis task will require you to set up a Cognitive Service for facial analysis.  You'll use this to allow customers to run your Xamarin app and see what they look like with different KNOWZY noses on their face!\n\n\nPrerequisites\n\n\n\n\nAn Azure Subscription\n\n\n\n\nTask\n\n\n\n\n\n\nCreate a new Cognitive Services \nFace API\n.  \n\n\n\n\n\n\nCopy your Face API's \nName\n and \nKey 1\n for later usage.\n\n\n\n\n\n\nComments\n\n\n@ 2:37am\n\n\nCreating a Face API couldn't be easier, just follow \nthis\n guide I found.\n\n\ncontinue to \nnext task", 
            "title": "341 CognitiveServices"
        }, 
        {
            "location": "/stories/3/341_CognitiveServices/#task-341-set-up-cognitive-services-for-image-face-analysis-in-azure", 
            "text": "This task will require you to set up a Cognitive Service for facial analysis.  You'll use this to allow customers to run your Xamarin app and see what they look like with different KNOWZY noses on their face!", 
            "title": "Task 3.4.1 - Set up Cognitive Services for image face analysis in Azure"
        }, 
        {
            "location": "/stories/3/341_CognitiveServices/#prerequisites", 
            "text": "An Azure Subscription", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/341_CognitiveServices/#task", 
            "text": "Create a new Cognitive Services  Face API .      Copy your Face API's  Name  and  Key 1  for later usage.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/341_CognitiveServices/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/3/341_CognitiveServices/#237am", 
            "text": "Creating a Face API couldn't be easier, just follow  this  guide I found.", 
            "title": "@ 2:37am"
        }, 
        {
            "location": "/stories/3/341_CognitiveServices/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/342_AzureFunction/", 
            "text": "Task 3.4.2 - Create an Azure Function to analyze an image and return nose location\n\n\nNow that you've created a Cognitive Service to tell you where noses are in pictures sent from the Knowzy mobile app, you'll need to create an endpoint to accept those pictures and talk to your Cognitive Service.  This task requires you to set up a new Azure Function, and then code and design it to expose an HTTP endpoint that accepts an image file and returns the location of the nose(s) in any faces found in the picture.\n\n\nPrerequisites\n\n\nThis task has a dependency on \nTask 3.4.1\n and all of it's prerequisites\n\n\nThis walkthrough assumes that you have:\n\n\n\n\nVisual Studio 2017 Preview 3\n.\n\n\nAzure Functions extension\n installed.\n\n\n\n\nTask\n\n\n\n\nCreate a new Azure Functions project in Visual Studio.  \n\n\nCreate an HTTP Trigger which will take in a picture and return data.\n\n\nWithin your Function, use the \nName\n and \nKey\n from \nTask 3.4.1\n to connect to your Cognitive Service and run face detection on the image.\n\n\nReturn the data for the nose location(s) from your Function.\n\n\nPosition Knowzy nose(s) on top of the image in app.\n\n\n\n\nComments\n\n\n@ 11:48am\n\n\nThis\n blog post shows off the Visual Studio tooling that you can use to create a new Azure function.\n\n\n@ 1:03pm\n\n\nI found this explanation for Azure Functions of how to do \nHTTP and Webhook Bindings\n.\n\n\n@ 2:57pm\n\n\nI was curious about what the Face API is capable of so I found the \nREST Docs\n.\n\n\n@ 4:32pm\n\n\nThis \nquickstart\n really walks through how to call the Face API from C#.\n\n\ncontinue to \nnext task", 
            "title": "342 AzureFunction"
        }, 
        {
            "location": "/stories/3/342_AzureFunction/#task-342-create-an-azure-function-to-analyze-an-image-and-return-nose-location", 
            "text": "Now that you've created a Cognitive Service to tell you where noses are in pictures sent from the Knowzy mobile app, you'll need to create an endpoint to accept those pictures and talk to your Cognitive Service.  This task requires you to set up a new Azure Function, and then code and design it to expose an HTTP endpoint that accepts an image file and returns the location of the nose(s) in any faces found in the picture.", 
            "title": "Task 3.4.2 - Create an Azure Function to analyze an image and return nose location"
        }, 
        {
            "location": "/stories/3/342_AzureFunction/#prerequisites", 
            "text": "This task has a dependency on  Task 3.4.1  and all of it's prerequisites  This walkthrough assumes that you have:   Visual Studio 2017 Preview 3 .  Azure Functions extension  installed.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/342_AzureFunction/#task", 
            "text": "Create a new Azure Functions project in Visual Studio.    Create an HTTP Trigger which will take in a picture and return data.  Within your Function, use the  Name  and  Key  from  Task 3.4.1  to connect to your Cognitive Service and run face detection on the image.  Return the data for the nose location(s) from your Function.  Position Knowzy nose(s) on top of the image in app.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/342_AzureFunction/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/3/342_AzureFunction/#1148am", 
            "text": "This  blog post shows off the Visual Studio tooling that you can use to create a new Azure function.", 
            "title": "@ 11:48am"
        }, 
        {
            "location": "/stories/3/342_AzureFunction/#103pm", 
            "text": "I found this explanation for Azure Functions of how to do  HTTP and Webhook Bindings .", 
            "title": "@ 1:03pm"
        }, 
        {
            "location": "/stories/3/342_AzureFunction/#257pm", 
            "text": "I was curious about what the Face API is capable of so I found the  REST Docs .", 
            "title": "@ 2:57pm"
        }, 
        {
            "location": "/stories/3/342_AzureFunction/#432pm", 
            "text": "This  quickstart  really walks through how to call the Face API from C#.", 
            "title": "@ 4:32pm"
        }, 
        {
            "location": "/stories/3/342_AzureFunction/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/351_CICD_WindowsApp/", 
            "text": "Task 3.5.1 - Set up Continuous Integration and Deployment for the Windows app using Visual Studio Mobile Center\n\n\nNow that you've made an app that works, the CTO would like to ensure higher quality by setting up Continuous Integration and Delivery.  To that end, you've been instructed to make sure that after every code check-in the app compiles, all tests are run, and new versions can be delivered to beta testers with ease.  This task will focus on the Windows version of the app with the next task covering Android.\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 3.1.1\n and all of it's prerequisites.\n\n\nIf you've already set up a code repository for [Task 3.4.2][342], you can use that and skip to step 2 below.\n\n\n\n\nTask\n\n\n\n\nAdd your application to a compatible source control system.\n\n\nCreate a UWP app in the Mobile Center, and connect it to your repo.\n\n\nEnsure your app builds the first time.  \n\n\nAdd your teammates so that they will receive notifications on build.\n\n\nMake sure your teammates can install your app.\n\n\n\n\nComments\n\n\n@ 7:37am\n\n\nIt sounds like we can use multiple different source control systems with Mobile Center.  Check out \nthese docs\n I found about connecting to a repository.\n\n\n@ 9:23am\n\n\nIt sounds like the Build config in Mobile Center let's us trigger a build with every code check-in.  That means our builds will happen automatically!\n\n\n@ 11:56am\n\n\nMy friends wanted to know whenever I built an app so I figured out how to create a distribution group \nhere\n.\n\n\ncontinue to \nnext task", 
            "title": "351 CICD WindowsApp"
        }, 
        {
            "location": "/stories/3/351_CICD_WindowsApp/#task-351-set-up-continuous-integration-and-deployment-for-the-windows-app-using-visual-studio-mobile-center", 
            "text": "Now that you've made an app that works, the CTO would like to ensure higher quality by setting up Continuous Integration and Delivery.  To that end, you've been instructed to make sure that after every code check-in the app compiles, all tests are run, and new versions can be delivered to beta testers with ease.  This task will focus on the Windows version of the app with the next task covering Android.", 
            "title": "Task 3.5.1 - Set up Continuous Integration and Deployment for the Windows app using Visual Studio Mobile Center"
        }, 
        {
            "location": "/stories/3/351_CICD_WindowsApp/#prerequisites", 
            "text": "This task has a dependency on  Task 3.1.1  and all of it's prerequisites.  If you've already set up a code repository for [Task 3.4.2][342], you can use that and skip to step 2 below.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/351_CICD_WindowsApp/#task", 
            "text": "Add your application to a compatible source control system.  Create a UWP app in the Mobile Center, and connect it to your repo.  Ensure your app builds the first time.    Add your teammates so that they will receive notifications on build.  Make sure your teammates can install your app.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/351_CICD_WindowsApp/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/3/351_CICD_WindowsApp/#737am", 
            "text": "It sounds like we can use multiple different source control systems with Mobile Center.  Check out  these docs  I found about connecting to a repository.", 
            "title": "@ 7:37am"
        }, 
        {
            "location": "/stories/3/351_CICD_WindowsApp/#923am", 
            "text": "It sounds like the Build config in Mobile Center let's us trigger a build with every code check-in.  That means our builds will happen automatically!", 
            "title": "@ 9:23am"
        }, 
        {
            "location": "/stories/3/351_CICD_WindowsApp/#1156am", 
            "text": "My friends wanted to know whenever I built an app so I figured out how to create a distribution group  here .", 
            "title": "@ 11:56am"
        }, 
        {
            "location": "/stories/3/351_CICD_WindowsApp/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/352_CICD_AndroidApp/", 
            "text": "Task 3.5.2 - Set up Continuous Integration and Deployment for the Android app using Visual Studio Mobile Center\n\n\nNow that you've made an app that works, the CTO would like to ensure higher quality by setting up Continuous Integration and Delivery. To that end, you've been instructed to make sure that after every code check-in the app compiles, all tests are run, and new versions can be delivered to beta testers with ease. This task will focus on the Android version of the app, with the previous task covering Windows.\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 3.1.1\n and all of it's prerequisites.\n\n\nIf you've already set up a code repository for [Task 3.5.1][351], you can use that and skip to step 2 below.\n\n\n\n\nTask\n\n\n\n\nAdd your application to a compatible source control system.\n\n\nCreate an Android app in Mobile Center, and connect it to your repo.\n\n\nEnsure your app builds the first time.  \n\n\nAdd your teammates so that they will receive notifications on build.\n\n\nMake sure your teammates can install your app.\n\n\n\n\nComments\n\n\n@ 9:37am\n\n\nIt sounds like we can use multiple different source control systems with Mobile Center.  Check out \nthese docs\n I found about connecting to a repository.\n\n\n@ 10:04am\n\n\nI finally figured out how to \ncreating a Keystore for signing an app\n.  This should save you some time!\n\n\n@ 1:22pm\n\n\nIt sounds like the Build config in Mobile Center let's us trigger a build with every code check-in.  That means our builds will happen automatically!\n\n\n@ 3:56pm\n\n\nMy friends wanted to know whenever I built an app so I figured out how to create a distribution group \nhere\n.\n\n\ncontinue to \nnext task", 
            "title": "352 CICD AndroidApp"
        }, 
        {
            "location": "/stories/3/352_CICD_AndroidApp/#task-352-set-up-continuous-integration-and-deployment-for-the-android-app-using-visual-studio-mobile-center", 
            "text": "Now that you've made an app that works, the CTO would like to ensure higher quality by setting up Continuous Integration and Delivery. To that end, you've been instructed to make sure that after every code check-in the app compiles, all tests are run, and new versions can be delivered to beta testers with ease. This task will focus on the Android version of the app, with the previous task covering Windows.", 
            "title": "Task 3.5.2 - Set up Continuous Integration and Deployment for the Android app using Visual Studio Mobile Center"
        }, 
        {
            "location": "/stories/3/352_CICD_AndroidApp/#prerequisites", 
            "text": "This task has a dependency on  Task 3.1.1  and all of it's prerequisites.  If you've already set up a code repository for [Task 3.5.1][351], you can use that and skip to step 2 below.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/352_CICD_AndroidApp/#task", 
            "text": "Add your application to a compatible source control system.  Create an Android app in Mobile Center, and connect it to your repo.  Ensure your app builds the first time.    Add your teammates so that they will receive notifications on build.  Make sure your teammates can install your app.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/352_CICD_AndroidApp/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/3/352_CICD_AndroidApp/#937am", 
            "text": "It sounds like we can use multiple different source control systems with Mobile Center.  Check out  these docs  I found about connecting to a repository.", 
            "title": "@ 9:37am"
        }, 
        {
            "location": "/stories/3/352_CICD_AndroidApp/#1004am", 
            "text": "I finally figured out how to  creating a Keystore for signing an app .  This should save you some time!", 
            "title": "@ 10:04am"
        }, 
        {
            "location": "/stories/3/352_CICD_AndroidApp/#122pm", 
            "text": "It sounds like the Build config in Mobile Center let's us trigger a build with every code check-in.  That means our builds will happen automatically!", 
            "title": "@ 1:22pm"
        }, 
        {
            "location": "/stories/3/352_CICD_AndroidApp/#356pm", 
            "text": "My friends wanted to know whenever I built an app so I figured out how to create a distribution group  here .", 
            "title": "@ 3:56pm"
        }, 
        {
            "location": "/stories/3/352_CICD_AndroidApp/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/353_EventLogging/", 
            "text": "Task 3.5.3 - Add Custom Event Logging using Visual Studio Mobile Center\n\n\nNow that you've completed Continuous Integration and Delivery, it's time to get some more value out of Mobile Center.  Specifically, we want you to use the Mobile Center SDK to start recording usage statistics and analytics for your app.  This will help show the execs how many people are using the app and their usage patterns.\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 3.5.1\n or \nTask 3.5.2\n so your app is already connected to Mobile Center.\n\n\n\n\nTask\n\n\n\n\nAdd the Mobile Center SDK to your solution and projects.\n\n\nConfigure the SDK on app start.\n\n\nAdd some custom logging and log an event in your app.\n\n\n\n\nComments\n\n\n@ 12:20pm\n\n\nI found a great walkthrough on installing the Mobile Center SDK \nhere\n.\n\n\n@ 2:31pm\n\n\nThis\n made adding logging to my Xamarin app super easy.\n\n\n@ 4:17pm\n\n\nIt looks like there is a bit of customization you need to do for UWP.  \nCheck it out\n.\n\n\ncontinue to \nnext task", 
            "title": "353 EventLogging"
        }, 
        {
            "location": "/stories/3/353_EventLogging/#task-353-add-custom-event-logging-using-visual-studio-mobile-center", 
            "text": "Now that you've completed Continuous Integration and Delivery, it's time to get some more value out of Mobile Center.  Specifically, we want you to use the Mobile Center SDK to start recording usage statistics and analytics for your app.  This will help show the execs how many people are using the app and their usage patterns.", 
            "title": "Task 3.5.3 - Add Custom Event Logging using Visual Studio Mobile Center"
        }, 
        {
            "location": "/stories/3/353_EventLogging/#prerequisites", 
            "text": "This task has a dependency on  Task 3.5.1  or  Task 3.5.2  so your app is already connected to Mobile Center.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/353_EventLogging/#task", 
            "text": "Add the Mobile Center SDK to your solution and projects.  Configure the SDK on app start.  Add some custom logging and log an event in your app.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/353_EventLogging/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/3/353_EventLogging/#1220pm", 
            "text": "I found a great walkthrough on installing the Mobile Center SDK  here .", 
            "title": "@ 12:20pm"
        }, 
        {
            "location": "/stories/3/353_EventLogging/#231pm", 
            "text": "This  made adding logging to my Xamarin app super easy.", 
            "title": "@ 2:31pm"
        }, 
        {
            "location": "/stories/3/353_EventLogging/#417pm", 
            "text": "It looks like there is a bit of customization you need to do for UWP.   Check it out .", 
            "title": "@ 4:17pm"
        }, 
        {
            "location": "/stories/3/353_EventLogging/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/3/361_Bot/", 
            "text": "Task 3.6.1 - Create a Customer Bot\n\n\nOur users want to be able to check and modify the status of their orders from anywhere, including chat bot platforms like Skype and Facebook. They'd also like to send feedback and create support tickets from the bot.\n\n\nPrerequisites\n\n\nThis task has a dependency on the \nOrders API created under section 4.1.2\n and all of its prerequisites\n\n\nTask\n\n\n\n\nCreate a bot using the Microsoft Bot Framework that asks for the user to log in (a Minimum Viable Product would be asking for the user id to identify the user). \n\n\nOnce the user logs in, the bot can list user orders, find a specific order status from an Order ID, and cancel the order if it hasn't been shipped.\n\n\nThe bot also allows the user to open support tickets and send feedback.\n\n\n\n\nComments\n\n\n@ 9:02am\n\n\nI've done a bit of investigation, found these samples \nin C#\n and \nin Node.js\n that should help us get started.  The core-MultiDialogs and the cards-CarouselCards samples seem interesting.\n\n\n@ 9:23am\n\n\nIf the bot asks the user to sign in we can use this \nnice library called BotAuth\n for it. \n\n\n@ 10:31am\n\n\nWe can use this to keep track of the user's id (\nC#\n and \nNode.js\n) like in the core-State sample. After logging in we can use the user id to get our bot to call the \nOrders API\n to get order details for the user. \n\n\n@ 11:05am\n\n\nWe can use Microsoft Cognitive Services to enhance our bot, like the \nLanguage Understanding Intelligent Service\n to \nunderstand commands\n and the \nText Analytics API\n for sentiment analysis of feedback.", 
            "title": "361 Bot"
        }, 
        {
            "location": "/stories/3/361_Bot/#task-361-create-a-customer-bot", 
            "text": "Our users want to be able to check and modify the status of their orders from anywhere, including chat bot platforms like Skype and Facebook. They'd also like to send feedback and create support tickets from the bot.", 
            "title": "Task 3.6.1 - Create a Customer Bot"
        }, 
        {
            "location": "/stories/3/361_Bot/#prerequisites", 
            "text": "This task has a dependency on the  Orders API created under section 4.1.2  and all of its prerequisites", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/3/361_Bot/#task", 
            "text": "Create a bot using the Microsoft Bot Framework that asks for the user to log in (a Minimum Viable Product would be asking for the user id to identify the user).   Once the user logs in, the bot can list user orders, find a specific order status from an Order ID, and cancel the order if it hasn't been shipped.  The bot also allows the user to open support tickets and send feedback.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/3/361_Bot/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/3/361_Bot/#902am", 
            "text": "I've done a bit of investigation, found these samples  in C#  and  in Node.js  that should help us get started.  The core-MultiDialogs and the cards-CarouselCards samples seem interesting.", 
            "title": "@ 9:02am"
        }, 
        {
            "location": "/stories/3/361_Bot/#923am", 
            "text": "If the bot asks the user to sign in we can use this  nice library called BotAuth  for it.", 
            "title": "@ 9:23am"
        }, 
        {
            "location": "/stories/3/361_Bot/#1031am", 
            "text": "We can use this to keep track of the user's id ( C#  and  Node.js ) like in the core-State sample. After logging in we can use the user id to get our bot to call the  Orders API  to get order details for the user.", 
            "title": "@ 10:31am"
        }, 
        {
            "location": "/stories/3/361_Bot/#1105am", 
            "text": "We can use Microsoft Cognitive Services to enhance our bot, like the  Language Understanding Intelligent Service  to  understand commands  and the  Text Analytics API  for sentiment analysis of feedback.", 
            "title": "@ 11:05am"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/", 
            "text": "Task 4.1.1 - Create a shared CosmosDB to store all data\n\n\n1. Pre-Requisites\n\n\n\n\nYou should download and extract the \nCosmosDB Data Migration Tool\n\n\nYou'll need a Microsoft Azure subscription for this task.\n\n\n\n\na. Working with Cloud Shell\n\n\nAzure Cloud Shell comes with the Azure CLI already configured. This makes setup straightforward. We'll be using Azure Cloud Shell throughout this guide, and we'll need to get Cloud Shell pointed toward the subscription we want to work with.\n\n\nNB: All shell instructions are based on using the Cloud Shell, using a local powershell, bash session or command prompt may cause unexpected results.\n\n\ni) Access Azure Cloud Shell using the \n_\n Icon in the \ntop right corner\n of the portal.\n\n\n\n\nii) Point to your Azure subscription\n\n\nIf you have more than one subscription in your azure portal, it's a good idea to first check which one your CLI is pointed to.  The command for this is:\n\n    az account show\n\nIf it's not pointed to the subscription you want to use, you can re-point your CLI to the correct subscription using:\n\n    az account set --subscription \nSubscriptionId\n\n\nYou can list out all subscriptions you have access to using:\n\n    az account list\n\n\n\nb. Create a resource group\n\n\nWe need to create a resource-group to ring-fence all of our work, and we'll start out by storing a couple of variables we're going to use again in our shell. \n(Note; many resources within Azure require a unique name, as such we recommend you use the guidelines in the published \nnaming conventions\n)\n\n\nc. First store the name you want to use for your resource group:\n\n\nResource group names must be globally unique within Azure, so make sure it's both memorable, and specific to you and your project.\n\n\nRESOURCE_GROUP=\nunique name\n\n\n\n\nd. Then supply the location we're going to create it in \n(for our example you should pick from: 'eastus', 'westeurope' or 'southeastasia')\n\n\nLOCATION=eastus\n\n\n\ne. Create our new resource group within our current subscription:\n\n\n    az group create --name $RESOURCE_GROUP --location $LOCATION\n\n\n\n\n2. Create and initialise CosmosDB\n\n\na. Store the name of our database:\n\n\nLike resource group names, CosmosDB names must be globally unique within Azure, so again we should select something specific.\n\n\nCOSMOSDB_NAME=\nunique database name\n _(names must be all lower case and no symbols)_\n\n\n\nb. Create the CosmosDB instance\n\n\nWe can now go ahead and use the Azure CLI within the Cloud Shell to create our CosmosDB Instance.\n\n\naz cosmosdb create -g $RESOURCE_GROUP -n $COSMOSDB_NAME --locations \"EAST US2\"=0\n\n\n\nThis command will take some time to complete. You'll know it succeeded when the Cloud Shell console outputs something like the below screen, containing the name you specified in step 1 above in the 'documentEndpoint':\n\n\n\n\nc. Import data into collections\n\n\nFor this step we'll need to use the \nCosmosDB Data Migration Tool\n that you should have already downloaded and extracted.\n\n\nWe're going to perform the following steps for the 3 collections we need to add to Azure; Customers, Products and Orders. For convenience sake you can download a zip file containing all three: \nHere\n.\n\n\ni) Load up the UI version of the data migration tool by running 'dtui.exe'\n\n\n\n\nii) You should be greeted with the following screen below, you can just click 'Next' for now.\n\n\n\n\niii) This is the 'Source Information' screen where we specify the information source for our import. Select the JSON file for the collection you want to import (We'll use customers.json for our example) then click 'Next' to move on.\n\n\n\n\niv) You should now see a screen that looks like below named 'Target Information', where you specify information about the destination of our import. First set the 'Export to' option to: 'CosmosDB - Sequential record import (partitioned collection).\n\n\n\n\nv) We'll need to retrieve our 'Connection String' from the Azure Portal. Open the portal, and select your CosmosDB Instance, click on 'Keys', select 'Read/Write Keys', and click the button next to 'PRIMARY CONNECTION STRING' to copy it to your clipboard.\n\n\n\n\nvi) Go back to the CosmosDB Data Migration Tool and paste the value into the box for the connection string. The importer also requires that you specify the database you'll be importing to, so add the following string with the name of your database (which you defined in step 2a) to the end of the connection string you just pasted:\n\n\nDatabase=\nyour CosmosDB name\n\n\n\n\nYou'll have something that looks like this:\n\n\n\n\nv) Click the 'verify' button, and you should get confirmation that the importer can successfully connect to your CosmosDB. Which should look like this:\n\n\n\n\nvi) Now we need to specify the other parameters for the new collection, complete the rest of the form as below:\n\n\n\n\nCollection: [name of collection] - \nThis is the name of the collection that will be created, you should choose from (orders, customers or products) dependent which import you are completing, we chose customers.json so our collection is 'customers'\n\n\nPartition Key: /[partition key] - \nThis is the partition key that will be applied to the collection, for customers and orders we do this for '/companyName' for products we use '/category', be careful of case sensitivity here!\n\n\nCollection Throughput: 400 - _This is the preset throughput to configure the collection for, we want to keep costs down during dev, so we should change this from 1000 (the default) to 400.\n\n\nId Field: id - \nThis is the ID field of the schema, for sake of simplicity we've made them all 'id' (case sensitive), but this is customisable in more advanced scenarios.\n\n\n\n\nOnce your form looks like below, we're ready to click 'Next'!\n\n\n\n\nvii) Click 'Next' on the 'Advanced' settings screen. We want our errors to show in the tool UI so we don't need to specify anything here. Then you should see a screen that looks like this:\n\n\n\n\nviii) Carefully review the import settings, and when you're satisfied click 'Import'. If the import fails, errors will be displayed in the UI. All being well, your import will succeed and you'll see a screen similar to this:\n\n\n\n\nix) You can now return to the portal, select your CosmosDB Instance, and click on 'Document Explorer' to explore your new schema.\n\n\n\n\nx) To import the other two collections (products and orders in our example given here), simply click 'New Import' and follow steps (ii) through (ix) using the next JSON file and schema Name for your chosen collection.\n\n\n\n\n3. References\n\n\nCosmosDB Migration Tool Download\n\n\ncontinue to \nnext task", 
            "title": "411 CosmosDB"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#task-411-create-a-shared-cosmosdb-to-store-all-data", 
            "text": "", 
            "title": "Task 4.1.1 - Create a shared CosmosDB to store all data"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#1-pre-requisites", 
            "text": "You should download and extract the  CosmosDB Data Migration Tool  You'll need a Microsoft Azure subscription for this task.", 
            "title": "1. Pre-Requisites"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#a-working-with-cloud-shell", 
            "text": "Azure Cloud Shell comes with the Azure CLI already configured. This makes setup straightforward. We'll be using Azure Cloud Shell throughout this guide, and we'll need to get Cloud Shell pointed toward the subscription we want to work with.  NB: All shell instructions are based on using the Cloud Shell, using a local powershell, bash session or command prompt may cause unexpected results.  i) Access Azure Cloud Shell using the  _  Icon in the  top right corner  of the portal.   ii) Point to your Azure subscription  If you have more than one subscription in your azure portal, it's a good idea to first check which one your CLI is pointed to.  The command for this is:\n\n    az account show\n\nIf it's not pointed to the subscription you want to use, you can re-point your CLI to the correct subscription using:\n\n    az account set --subscription  SubscriptionId \n\nYou can list out all subscriptions you have access to using:\n\n    az account list", 
            "title": "a. Working with Cloud Shell"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#b-create-a-resource-group", 
            "text": "We need to create a resource-group to ring-fence all of our work, and we'll start out by storing a couple of variables we're going to use again in our shell.  (Note; many resources within Azure require a unique name, as such we recommend you use the guidelines in the published  naming conventions )", 
            "title": "b. Create a resource group"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#c-first-store-the-name-you-want-to-use-for-your-resource-group", 
            "text": "Resource group names must be globally unique within Azure, so make sure it's both memorable, and specific to you and your project.  RESOURCE_GROUP= unique name", 
            "title": "c. First store the name you want to use for your resource group:"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#d-then-supply-the-location-were-going-to-create-it-in-for-our-example-you-should-pick-from-eastus-westeurope-or-southeastasia", 
            "text": "LOCATION=eastus", 
            "title": "d. Then supply the location we're going to create it in (for our example you should pick from: 'eastus', 'westeurope' or 'southeastasia')"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#e-create-our-new-resource-group-within-our-current-subscription", 
            "text": "az group create --name $RESOURCE_GROUP --location $LOCATION", 
            "title": "e. Create our new resource group within our current subscription:"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#2-create-and-initialise-cosmosdb", 
            "text": "", 
            "title": "2. Create and initialise CosmosDB"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#a-store-the-name-of-our-database", 
            "text": "Like resource group names, CosmosDB names must be globally unique within Azure, so again we should select something specific.  COSMOSDB_NAME= unique database name  _(names must be all lower case and no symbols)_", 
            "title": "a. Store the name of our database:"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#b-create-the-cosmosdb-instance", 
            "text": "We can now go ahead and use the Azure CLI within the Cloud Shell to create our CosmosDB Instance.  az cosmosdb create -g $RESOURCE_GROUP -n $COSMOSDB_NAME --locations \"EAST US2\"=0  This command will take some time to complete. You'll know it succeeded when the Cloud Shell console outputs something like the below screen, containing the name you specified in step 1 above in the 'documentEndpoint':", 
            "title": "b. Create the CosmosDB instance"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#c-import-data-into-collections", 
            "text": "For this step we'll need to use the  CosmosDB Data Migration Tool  that you should have already downloaded and extracted.  We're going to perform the following steps for the 3 collections we need to add to Azure; Customers, Products and Orders. For convenience sake you can download a zip file containing all three:  Here .  i) Load up the UI version of the data migration tool by running 'dtui.exe'   ii) You should be greeted with the following screen below, you can just click 'Next' for now.   iii) This is the 'Source Information' screen where we specify the information source for our import. Select the JSON file for the collection you want to import (We'll use customers.json for our example) then click 'Next' to move on.   iv) You should now see a screen that looks like below named 'Target Information', where you specify information about the destination of our import. First set the 'Export to' option to: 'CosmosDB - Sequential record import (partitioned collection).   v) We'll need to retrieve our 'Connection String' from the Azure Portal. Open the portal, and select your CosmosDB Instance, click on 'Keys', select 'Read/Write Keys', and click the button next to 'PRIMARY CONNECTION STRING' to copy it to your clipboard.   vi) Go back to the CosmosDB Data Migration Tool and paste the value into the box for the connection string. The importer also requires that you specify the database you'll be importing to, so add the following string with the name of your database (which you defined in step 2a) to the end of the connection string you just pasted:  Database= your CosmosDB name   You'll have something that looks like this:   v) Click the 'verify' button, and you should get confirmation that the importer can successfully connect to your CosmosDB. Which should look like this:   vi) Now we need to specify the other parameters for the new collection, complete the rest of the form as below:   Collection: [name of collection] -  This is the name of the collection that will be created, you should choose from (orders, customers or products) dependent which import you are completing, we chose customers.json so our collection is 'customers'  Partition Key: /[partition key] -  This is the partition key that will be applied to the collection, for customers and orders we do this for '/companyName' for products we use '/category', be careful of case sensitivity here!  Collection Throughput: 400 - _This is the preset throughput to configure the collection for, we want to keep costs down during dev, so we should change this from 1000 (the default) to 400.  Id Field: id -  This is the ID field of the schema, for sake of simplicity we've made them all 'id' (case sensitive), but this is customisable in more advanced scenarios.   Once your form looks like below, we're ready to click 'Next'!   vii) Click 'Next' on the 'Advanced' settings screen. We want our errors to show in the tool UI so we don't need to specify anything here. Then you should see a screen that looks like this:   viii) Carefully review the import settings, and when you're satisfied click 'Import'. If the import fails, errors will be displayed in the UI. All being well, your import will succeed and you'll see a screen similar to this:   ix) You can now return to the portal, select your CosmosDB Instance, and click on 'Document Explorer' to explore your new schema.   x) To import the other two collections (products and orders in our example given here), simply click 'New Import' and follow steps (ii) through (ix) using the next JSON file and schema Name for your chosen collection.", 
            "title": "c. Import data into collections"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#3-references", 
            "text": "CosmosDB Migration Tool Download", 
            "title": "3. References"
        }, 
        {
            "location": "/stories/4/411_CosmosDB/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/4/412_OrdersAPI/", 
            "text": "Task 4.1.2 - Create API endpoint for shipping and receiving services\n\n\nNow that you've created a database to store your data, it's time to create APIs to access that data.  Knowzy believes in a microservices based architecture so you'll need to start by creating a new API for orders to ensure the Web app does not go directly to the database.\n\n\nThe end goal is a .NET Core based cross-platform solution. The architecture proposes a simplified microservice oriented architecture implementation with multiple autonomous microservices (each one owning its own data/db). The microservices will implement a simple CRUD approach using Http as the current communication protocol.\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on Tasks \n1.1.1\n and \n4.1.1\n and all of their prerequisites.\n\n\n\n\nCreating a .NET Core App\n\n\n1. Create a New WebAPI Project\n\n\nFrom Windows Explorer create a new folder called \nAPIs\n in the \nsrc\\2. Services\n folder of the solution.\n\n\nOpen the \nMicrosoft.Knowzy\n solution in Visual Studio 2017. Add a new solution folder called \nAPIs\n to the \n2. Services\n folder. Create a new \nASP.NET Core Web Application\n project called \nMicrosoft.Knowzy.OrdersAPI\n in that folder:\n\n\n\n\nChoose Web API for the project type, and leave the other options as they are (we will add Docker support later):\n\n\n\n\nLet's test it out to make sure everything is working properly. In Visual Studio, right click on the project and select \nDebug -\n Start New Instance\n. Visual Studio will start a browser window for you to see your app running. Click the \nStop\n button in Visual Studio to stop the API app.\n\n\n2. Using Environment Variables and Connecting to CosmosDB\n\n\nIn a real-world app, you won't check your secrets into source control, and you won't be writing local code that connects directly to your production data store. Depending on your environment, you might not even have access to production. To address these issues and see how they tie in with Docker, we're going to use the \nCOSMOSDB_ENDPOINT\n and \nCOSMOSDB_KEY\n environment variables.\n\n\nThe default Web API template already calls \n.AddEnvironmentVariables()\n (look for it in \nStartup.cs\n), so we just need to set a variable, then access it in our code. \n\n\nAdd these values to the Environment Variables section of the \nMicrosoft.Knowzy.OrdersAPI\n project properties:\n\n\n\n\nTo use these environment variables in our code, we'll just pass the entire configuration object down to a new data access class.\n\n\nIn \nStartup.cs\n, make the following changes:\n\n\npublic void ConfigureServices(IServiceConnection services)\n{\n  // Add framework services.\n  services.AddMvc();\n+ services.AddSingleton\nIConfiguration\n(Configuration);\n}\n\n\n\n\nNow let's connect our solution to our data store in \nCosmosDB\n that was created as part of task \n4.1.1\n. \n\n\nStart by adding a Nuget package reference to the latest stable version of \nMicrosoft.Azure.DocumentDB.Core\n to the \nMicrosoft.Knowzy.OrdersAPI\n project.\n\n\nAdd a new folder called \nData\n to the \nMicrosoft.Knowzy.OrdersAPI\n project. This folder will have the classes that interact with your CosmosDB data store. \n\n\nAdd a new interface called \nIOrdersStore.cs\n to the \nData\n folder and populate it with the following:\n\n\nusing System;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public interface IOrdersStore : IDisposable\n    {\n        Task\nbool\n Connected();\n    }\n}\n\n\n\n\nAdd a new class called \nOrdersStore.cs\n to the \nData\n folder and populate it with a method to check if it can connect to CosmosDB. Make sure to update the database and collection name in this code to match yours:\n\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Azure.Documents.Client;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public class OrdersStore : IOrdersStore\n    {\n        private readonly DocumentClient _client;\n        private Uri _ordersLink;\n        public OrdersStore(IConfiguration config)\n        {\n            var EndpointUri = config[\nCOSMOSDB_ENDPOINT\n];\n            var PrimaryKey = config[\nCOSMOSDB_KEY\n];\n            _client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n            //Make sure the below values match your set up\n            _ordersLink = UriFactory.CreateDocumentCollectionUri(\nknowzydb\n, \norders\n); \n        }\n\n        public async Task\nbool\n Connected()\n        {\n            try\n            {\n                var db = await _client.GetDatabaseAccountAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        private bool disposedValue = false; // To detect redundant calls\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    _client.Dispose();\n                }\n                disposedValue = true;\n            }\n        }\n\n        void IDisposable.Dispose()\n        {\n            Dispose(true);\n        }\n    }\n}\n\n\n\n\nNote how we are using the \nASP.NET Core dependency injection\n to get the config instance passed into the class initializer for us, and with it we get the environment variable values. You can read more about configuration in ASP.NET Core in \nthis help article\n.\n\n\nModify \nStartup.cs\n and register our data access with the list of services (IoC) and with new JSON serialization settings:\n\n\npublic void ConfigureServices(IServiceConnection services)\n{\n  // Add framework services.\n  services.AddMvc();\n  services.AddSingleton\nIConfiguration\n(Configuration);\n+ services.AddSingleton\nData.IOrdersStore, Data.OrdersStore\n();\n}\n...\n// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)\n{\n  loggerFactory.AddConsole(Configuration.GetSection(\nLogging\n));\n  loggerFactory.AddDebug();\n  app.UseMvc();\n\n+ JsonConvert.DefaultSettings = () =\n\n+ {\n+   return new JsonSerializerSettings\n+   {\n+     MissingMemberHandling = MissingMemberHandling.Ignore,\n+     NullValueHandling = NullValueHandling.Ignore\n+   };\n+ };\n }\n\n\n\n\nTo test it outupdate the \nValuesController.cs\n file follows:\n\n\n...\n+ using Microsoft.Knowzy.OrdersAPI.Data;\n...\n   public class ValuesController : Controller\n{\n+        private IOrdersStore _ordersStore;\n+        public ValuesController(IOrdersStore ordersStore)\n+        {\n+            _ordersStore = ordersStore;\n+        }\n\n\n...\n    // GET api/values/5\n    [HttpGet(\n{id}\n)]\n-    public string Get(int id)\n+    public async Task\nstring\n Get(int id)\n    {\n-      return \nvalue\n;\n+      var status = await _ordersStore.Connected() ? \nconnected\n : \nnot connected\n;\n+      return $\nWe are {status} to CosmosDB! and your value is {id}\n;\n    }\n  }\n\n\n\n\nIf you now run the API app again and call \n/api/values/5\n on your API you should see \nWe are connected to CosmosDB! and your value is 5\n returned.\n\n\n3. Implement the Orders API\n\n\nNow it's time to implement the endpoints for the Shipping, Receiving, Postal Carrier, and Customer controllers of our Orders API, running the API app as needed to verify your app locally.\n\n\nIn the \nMicrosoft.Knowzy.OrdersAPI\n add a project reference to the \nMicrosoft.Knowzy.Domain\n project. This reference has the model classes we will use in the Orders API for serialization.\n\n\nEdit the \nIOrdersStore.cs\n interface to add the GetShippings method:\n\n\n...\n+ using System.Collections.Generic;\n...\n    public interface IOrdersStore : IDisposable\n    {\n        Task\nbool\n Connected();\n\n+        IEnumerable\nDomain.Shipping\n GetShippings();\n    }\n\n\n\n\nAnd edit the \nOrdersStore.cs\n class to implement that method to return all orders:\n\n\n...\n+ using System.Collections.Generic;\n+ using System.Linq;\n...\n+        public IEnumerable\nDomain.Shipping\n GetShippings()\n+        {\n+            FeedOptions options = new FeedOptions();\n+            options.EnableCrossPartitionQuery = true;\n+\n+           return _client.CreateDocumentQuery\nDomain.Shipping\n(\n+               _ordersLink,\n+               \nSELECT * FROM orders o WHERE o.type='shipping'\n,\n+               _options).ToList();\n+        }\n\n\n\n\nAdd a new class called \nShippingController.cs\n to the \nControllers\n folder to return all shipping orders in the Get method (choose to add a new class instead of a new Controller as we don't need the scaffolding from adding a Controller:\n\n\nusing System;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Knowzy.OrdersAPI.Data;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Controllers\n{\n    [Route(\napi/[controller]\n)]\n    public class ShippingController : Controller\n    {\n        private IOrdersStore _ordersStore;\n        public ShippingController(IOrdersStore ordersStore)\n        {\n            _ordersStore = ordersStore;\n        }\n        // GET api/values\n        [HttpGet]\n        public IEnumerable\nDomain.Shipping\n Get()\n        {\n            return _ordersStore.GetShippings();\n        }\n    }\n}\n\n\n\n\nNow, when you run and browse your API to \n/api/Shipping\n you should get back the JSON array with all the shipping orders in the CosmosDB \norders\n collection.\n\n\nYou now need to finalize the Orders API. This is the full \nIOrderStore.cs\n interface:\n\n\nusing System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.Knowzy.Domain;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public interface IOrdersStore : IDisposable\n    {\n        Task\nbool\n Connected();\n        IEnumerable\nShipping\n GetShippings();\n        Shipping GetShipping(string orderId);\n        IEnumerable\nReceiving\n GetReceivings();\n        Receiving GetReceiving(string orderId);\n        IEnumerable\nPostalCarrier\n GetPostalCarriers();\n        Task UpsertAsync(Domain.Order order);\n        Task DeleteOrderAsync(string orderId);\n    }\n}\n\n\n\n\nUpdate \nOrdersStore.cs\n to implement the rest of the interface. This should be all you need to implement the rest of the Shipping controller and create the Receiving and PostalCarrier controllers. For example, here is an \nOrdersStore.cs\n implementation:\n\n\nusing System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Azure.Documents.Client;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.Azure.Documents;\nusing Microsoft.Knowzy.Domain;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public class OrdersStore : IOrdersStore\n    {\n        private readonly DocumentClient _client;\n        private Uri _ordersLink;\n        private FeedOptions _options = new FeedOptions();\n\n        public OrdersStore(IConfiguration config)\n        {\n            var EndpointUri = config[\nCOSMOSDB_ENDPOINT\n];\n            var PrimaryKey = config[\nCOSMOSDB_KEY\n];\n            _client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n            //Make sure the below values match your set up\n            _ordersLink = UriFactory.CreateDocumentCollectionUri(\nknowzydb\n, \norders\n);\n            _options.EnableCrossPartitionQuery = true;\n        }\n\n        public async Task\nbool\n Connected()\n        {\n            try\n            {\n                var db = await _client.GetDatabaseAccountAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        public IEnumerable\nShipping\n GetShippings()\n        {\n            return GetOrders\nShipping\n(\nshipping\n);\n        }\n\n        public Shipping GetShipping(string orderId)\n        {\n            return GetOrder\nShipping\n(orderId);\n        }\n\n        public IEnumerable\nReceiving\n GetReceivings()\n        {\n            return GetOrders\nReceiving\n(\nreceiving\n);\n        }\n\n        public Receiving GetReceiving(string orderId)\n        {\n            return GetOrder\nReceiving\n(orderId);\n        }\n\n        public async Task UpsertAsync(Order order)\n        {\n            await _client.UpsertDocumentAsync(_ordersLink.ToString(), order);\n        }\n\n        public async Task DeleteOrderAsync(string orderId)\n        {\n            await _client.DeleteDocumentAsync(UriFactory.CreateDocumentUri(\nknowzydb\n, \norders\n, orderId));\n        }\n\n        public IEnumerable\nPostalCarrier\n GetPostalCarriers()\n        {\n            return _client.CreateDocumentQuery\nPostalCarrier\n(\n                    _ordersLink,\n                    \nSELECT o.postalCarrier.id, o.postalCarrier.name FROM orders o\n,\n                    _options).ToList().GroupBy(x =\n x.Name).Select(x =\n x.First());\n        }\n\n        private IEnumerable\nT\n GetOrders\nT\n(string orderType)\n        {\n            return _client.CreateDocumentQuery\nT\n(\n                _ordersLink,\n                new SqlQuerySpec\n                {\n                    QueryText = \nSELECT * FROM orders o WHERE (o.type = @ordertype)\n,\n                    Parameters = new SqlParameterCollection()\n                        {\n                                     new SqlParameter(\n@ordertype\n, orderType)\n                        }\n                },\n                _options).ToList();\n        }\n\n        private T GetOrder\nT\n(string orderId)\n        {\n            return _client.CreateDocumentQuery\nT\n(\n                    _ordersLink,\n                    new SqlQuerySpec\n                    {\n                        QueryText = \nSELECT TOP 1 * FROM orders o WHERE (o.id = @orderid)\n,\n                        Parameters = new SqlParameterCollection()\n                        {\n                                     new SqlParameter(\n@orderid\n, orderId)\n                        }\n                    },\n                    _options).ToList().FirstOrDefault();\n        }\n\n        private bool disposedValue = false; // To detect redundant calls\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    _client.Dispose();\n                }\n                disposedValue = true;\n            }\n        }\n\n        void IDisposable.Dispose()\n        {\n            Dispose(true);\n        }\n    }\n}\n\n\n\n\nNote how CosmosDB \nsupports parameterized SQL queries\n to avoid SQL injection.\n\n\nNow it's time to finalize the API. We provided an \nend version of the APIs for your reference in the \nazurecompleted\n branch of the \nKnowzyInternalApps\n repo\n. The things to implement are:\n- Update \nShippingController.cs\n to use your updated Orders Store class with Get(id), Put, Post and Delete methods. Use \nthis guide\n to help. \n- Create a new controller called \nReceivingController.cs\n to handle all the CRUD methods for Receiving. Note that this can share most of of the same \nOrderStore.cs\n methods you used for Shipping (both Shipping and Receiving domain classes implement the Order domain class).\n- Create a new controller called \nPostalCarrierController.cs\n to handle just the Get (read all) method for it. You can find the PostalCarriers inside the orders collection in CosmosDB. \n- Create new classes called \nICustomersStore.cs\n and \nCostumersStorecs\n to implement the CRUD methods to go against the \ncustomers\n collection in CosmosDB.\n- Create a new controller called \nCostumerController.cs\n to handle just the Get (read all) method for it. \n\n\nAgain: you have access to an \nend version of the APIs for your reference in the \nazurecompleted\n branch of the \nKnowzyInternalApps\n repo\n to help.\n\n\n4. Package for release\n\n\nNow that we've got a working API app, let's package up all of our required files into a single folder for easy distribution. This time, we'll specify the Release configuration. \n\n\nOr from Visual Studio 2017, change the configuration to \nRelease\n, right click on the API project, select \nPublish\n, and choose \nFolder\n as the destination.\n\n\nBy default, this places your app files in a folder named \nbin/Release/PublishOutput\n. We'll use this output path in \nStep 4.1.4\n when we build a Docker image for our app.\n\n\n5. References\n\n\n\n\nTroubleshooting guide\n\n\n.NET Core CLI reference\n\n\nIntroduction to ASP.NET Core\n\n\nConfiguration in .NET Core\n\n\nAzure Cosmos DB: Getting started with the CosmosDB API and .NET Core\n\n\neShopOnContainers sample reference microservice and container based application\n\n\n\n\ncontinue to \nnext task", 
            "title": "412 OrdersAPI"
        }, 
        {
            "location": "/stories/4/412_OrdersAPI/#task-412-create-api-endpoint-for-shipping-and-receiving-services", 
            "text": "Now that you've created a database to store your data, it's time to create APIs to access that data.  Knowzy believes in a microservices based architecture so you'll need to start by creating a new API for orders to ensure the Web app does not go directly to the database.  The end goal is a .NET Core based cross-platform solution. The architecture proposes a simplified microservice oriented architecture implementation with multiple autonomous microservices (each one owning its own data/db). The microservices will implement a simple CRUD approach using Http as the current communication protocol.", 
            "title": "Task 4.1.2 - Create API endpoint for shipping and receiving services"
        }, 
        {
            "location": "/stories/4/412_OrdersAPI/#prerequisites", 
            "text": "This task has a dependency on Tasks  1.1.1  and  4.1.1  and all of their prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/4/412_OrdersAPI/#creating-a-net-core-app", 
            "text": "", 
            "title": "Creating a .NET Core App"
        }, 
        {
            "location": "/stories/4/412_OrdersAPI/#1-create-a-new-webapi-project", 
            "text": "From Windows Explorer create a new folder called  APIs  in the  src\\2. Services  folder of the solution.  Open the  Microsoft.Knowzy  solution in Visual Studio 2017. Add a new solution folder called  APIs  to the  2. Services  folder. Create a new  ASP.NET Core Web Application  project called  Microsoft.Knowzy.OrdersAPI  in that folder:   Choose Web API for the project type, and leave the other options as they are (we will add Docker support later):   Let's test it out to make sure everything is working properly. In Visual Studio, right click on the project and select  Debug -  Start New Instance . Visual Studio will start a browser window for you to see your app running. Click the  Stop  button in Visual Studio to stop the API app.", 
            "title": "1. Create a New WebAPI Project"
        }, 
        {
            "location": "/stories/4/412_OrdersAPI/#2-using-environment-variables-and-connecting-to-cosmosdb", 
            "text": "In a real-world app, you won't check your secrets into source control, and you won't be writing local code that connects directly to your production data store. Depending on your environment, you might not even have access to production. To address these issues and see how they tie in with Docker, we're going to use the  COSMOSDB_ENDPOINT  and  COSMOSDB_KEY  environment variables.  The default Web API template already calls  .AddEnvironmentVariables()  (look for it in  Startup.cs ), so we just need to set a variable, then access it in our code.   Add these values to the Environment Variables section of the  Microsoft.Knowzy.OrdersAPI  project properties:   To use these environment variables in our code, we'll just pass the entire configuration object down to a new data access class.  In  Startup.cs , make the following changes:  public void ConfigureServices(IServiceConnection services)\n{\n  // Add framework services.\n  services.AddMvc();\n+ services.AddSingleton IConfiguration (Configuration);\n}  Now let's connect our solution to our data store in  CosmosDB  that was created as part of task  4.1.1 .   Start by adding a Nuget package reference to the latest stable version of  Microsoft.Azure.DocumentDB.Core  to the  Microsoft.Knowzy.OrdersAPI  project.  Add a new folder called  Data  to the  Microsoft.Knowzy.OrdersAPI  project. This folder will have the classes that interact with your CosmosDB data store.   Add a new interface called  IOrdersStore.cs  to the  Data  folder and populate it with the following:  using System;\nusing System.Threading.Tasks;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public interface IOrdersStore : IDisposable\n    {\n        Task bool  Connected();\n    }\n}  Add a new class called  OrdersStore.cs  to the  Data  folder and populate it with a method to check if it can connect to CosmosDB. Make sure to update the database and collection name in this code to match yours:  using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Azure.Documents.Client;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public class OrdersStore : IOrdersStore\n    {\n        private readonly DocumentClient _client;\n        private Uri _ordersLink;\n        public OrdersStore(IConfiguration config)\n        {\n            var EndpointUri = config[ COSMOSDB_ENDPOINT ];\n            var PrimaryKey = config[ COSMOSDB_KEY ];\n            _client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n            //Make sure the below values match your set up\n            _ordersLink = UriFactory.CreateDocumentCollectionUri( knowzydb ,  orders ); \n        }\n\n        public async Task bool  Connected()\n        {\n            try\n            {\n                var db = await _client.GetDatabaseAccountAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        private bool disposedValue = false; // To detect redundant calls\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    _client.Dispose();\n                }\n                disposedValue = true;\n            }\n        }\n\n        void IDisposable.Dispose()\n        {\n            Dispose(true);\n        }\n    }\n}  Note how we are using the  ASP.NET Core dependency injection  to get the config instance passed into the class initializer for us, and with it we get the environment variable values. You can read more about configuration in ASP.NET Core in  this help article .  Modify  Startup.cs  and register our data access with the list of services (IoC) and with new JSON serialization settings:  public void ConfigureServices(IServiceConnection services)\n{\n  // Add framework services.\n  services.AddMvc();\n  services.AddSingleton IConfiguration (Configuration);\n+ services.AddSingleton Data.IOrdersStore, Data.OrdersStore ();\n}\n...\n// This method gets called by the runtime. Use this method to configure the HTTP request pipeline.\npublic void Configure(IApplicationBuilder app, IHostingEnvironment env, ILoggerFactory loggerFactory)\n{\n  loggerFactory.AddConsole(Configuration.GetSection( Logging ));\n  loggerFactory.AddDebug();\n  app.UseMvc();\n\n+ JsonConvert.DefaultSettings = () = \n+ {\n+   return new JsonSerializerSettings\n+   {\n+     MissingMemberHandling = MissingMemberHandling.Ignore,\n+     NullValueHandling = NullValueHandling.Ignore\n+   };\n+ };\n }  To test it outupdate the  ValuesController.cs  file follows:  ...\n+ using Microsoft.Knowzy.OrdersAPI.Data;\n...\n   public class ValuesController : Controller\n{\n+        private IOrdersStore _ordersStore;\n+        public ValuesController(IOrdersStore ordersStore)\n+        {\n+            _ordersStore = ordersStore;\n+        }\n\n\n...\n    // GET api/values/5\n    [HttpGet( {id} )]\n-    public string Get(int id)\n+    public async Task string  Get(int id)\n    {\n-      return  value ;\n+      var status = await _ordersStore.Connected() ?  connected  :  not connected ;\n+      return $ We are {status} to CosmosDB! and your value is {id} ;\n    }\n  }  If you now run the API app again and call  /api/values/5  on your API you should see  We are connected to CosmosDB! and your value is 5  returned.", 
            "title": "2. Using Environment Variables and Connecting to CosmosDB"
        }, 
        {
            "location": "/stories/4/412_OrdersAPI/#3-implement-the-orders-api", 
            "text": "Now it's time to implement the endpoints for the Shipping, Receiving, Postal Carrier, and Customer controllers of our Orders API, running the API app as needed to verify your app locally.  In the  Microsoft.Knowzy.OrdersAPI  add a project reference to the  Microsoft.Knowzy.Domain  project. This reference has the model classes we will use in the Orders API for serialization.  Edit the  IOrdersStore.cs  interface to add the GetShippings method:  ...\n+ using System.Collections.Generic;\n...\n    public interface IOrdersStore : IDisposable\n    {\n        Task bool  Connected();\n\n+        IEnumerable Domain.Shipping  GetShippings();\n    }  And edit the  OrdersStore.cs  class to implement that method to return all orders:  ...\n+ using System.Collections.Generic;\n+ using System.Linq;\n...\n+        public IEnumerable Domain.Shipping  GetShippings()\n+        {\n+            FeedOptions options = new FeedOptions();\n+            options.EnableCrossPartitionQuery = true;\n+\n+           return _client.CreateDocumentQuery Domain.Shipping (\n+               _ordersLink,\n+                SELECT * FROM orders o WHERE o.type='shipping' ,\n+               _options).ToList();\n+        }  Add a new class called  ShippingController.cs  to the  Controllers  folder to return all shipping orders in the Get method (choose to add a new class instead of a new Controller as we don't need the scaffolding from adding a Controller:  using System;\nusing System.Collections.Generic;\nusing Microsoft.AspNetCore.Mvc;\nusing Microsoft.Knowzy.OrdersAPI.Data;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Controllers\n{\n    [Route( api/[controller] )]\n    public class ShippingController : Controller\n    {\n        private IOrdersStore _ordersStore;\n        public ShippingController(IOrdersStore ordersStore)\n        {\n            _ordersStore = ordersStore;\n        }\n        // GET api/values\n        [HttpGet]\n        public IEnumerable Domain.Shipping  Get()\n        {\n            return _ordersStore.GetShippings();\n        }\n    }\n}  Now, when you run and browse your API to  /api/Shipping  you should get back the JSON array with all the shipping orders in the CosmosDB  orders  collection.  You now need to finalize the Orders API. This is the full  IOrderStore.cs  interface:  using System;\nusing System.Threading.Tasks;\nusing System.Collections.Generic;\nusing Microsoft.Knowzy.Domain;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public interface IOrdersStore : IDisposable\n    {\n        Task bool  Connected();\n        IEnumerable Shipping  GetShippings();\n        Shipping GetShipping(string orderId);\n        IEnumerable Receiving  GetReceivings();\n        Receiving GetReceiving(string orderId);\n        IEnumerable PostalCarrier  GetPostalCarriers();\n        Task UpsertAsync(Domain.Order order);\n        Task DeleteOrderAsync(string orderId);\n    }\n}  Update  OrdersStore.cs  to implement the rest of the interface. This should be all you need to implement the rest of the Shipping controller and create the Receiving and PostalCarrier controllers. For example, here is an  OrdersStore.cs  implementation:  using System;\nusing System.Threading.Tasks;\nusing Microsoft.Extensions.Configuration;\nusing Microsoft.Azure.Documents.Client;\nusing System.Collections.Generic;\nusing System.Linq;\nusing Microsoft.Azure.Documents;\nusing Microsoft.Knowzy.Domain;\n\nnamespace Microsoft.Knowzy.OrdersAPI.Data\n{\n    public class OrdersStore : IOrdersStore\n    {\n        private readonly DocumentClient _client;\n        private Uri _ordersLink;\n        private FeedOptions _options = new FeedOptions();\n\n        public OrdersStore(IConfiguration config)\n        {\n            var EndpointUri = config[ COSMOSDB_ENDPOINT ];\n            var PrimaryKey = config[ COSMOSDB_KEY ];\n            _client = new DocumentClient(new Uri(EndpointUri), PrimaryKey);\n            //Make sure the below values match your set up\n            _ordersLink = UriFactory.CreateDocumentCollectionUri( knowzydb ,  orders );\n            _options.EnableCrossPartitionQuery = true;\n        }\n\n        public async Task bool  Connected()\n        {\n            try\n            {\n                var db = await _client.GetDatabaseAccountAsync();\n                return true;\n            }\n            catch\n            {\n                return false;\n            }\n        }\n\n        public IEnumerable Shipping  GetShippings()\n        {\n            return GetOrders Shipping ( shipping );\n        }\n\n        public Shipping GetShipping(string orderId)\n        {\n            return GetOrder Shipping (orderId);\n        }\n\n        public IEnumerable Receiving  GetReceivings()\n        {\n            return GetOrders Receiving ( receiving );\n        }\n\n        public Receiving GetReceiving(string orderId)\n        {\n            return GetOrder Receiving (orderId);\n        }\n\n        public async Task UpsertAsync(Order order)\n        {\n            await _client.UpsertDocumentAsync(_ordersLink.ToString(), order);\n        }\n\n        public async Task DeleteOrderAsync(string orderId)\n        {\n            await _client.DeleteDocumentAsync(UriFactory.CreateDocumentUri( knowzydb ,  orders , orderId));\n        }\n\n        public IEnumerable PostalCarrier  GetPostalCarriers()\n        {\n            return _client.CreateDocumentQuery PostalCarrier (\n                    _ordersLink,\n                     SELECT o.postalCarrier.id, o.postalCarrier.name FROM orders o ,\n                    _options).ToList().GroupBy(x =  x.Name).Select(x =  x.First());\n        }\n\n        private IEnumerable T  GetOrders T (string orderType)\n        {\n            return _client.CreateDocumentQuery T (\n                _ordersLink,\n                new SqlQuerySpec\n                {\n                    QueryText =  SELECT * FROM orders o WHERE (o.type = @ordertype) ,\n                    Parameters = new SqlParameterCollection()\n                        {\n                                     new SqlParameter( @ordertype , orderType)\n                        }\n                },\n                _options).ToList();\n        }\n\n        private T GetOrder T (string orderId)\n        {\n            return _client.CreateDocumentQuery T (\n                    _ordersLink,\n                    new SqlQuerySpec\n                    {\n                        QueryText =  SELECT TOP 1 * FROM orders o WHERE (o.id = @orderid) ,\n                        Parameters = new SqlParameterCollection()\n                        {\n                                     new SqlParameter( @orderid , orderId)\n                        }\n                    },\n                    _options).ToList().FirstOrDefault();\n        }\n\n        private bool disposedValue = false; // To detect redundant calls\n        protected virtual void Dispose(bool disposing)\n        {\n            if (!disposedValue)\n            {\n                if (disposing)\n                {\n                    _client.Dispose();\n                }\n                disposedValue = true;\n            }\n        }\n\n        void IDisposable.Dispose()\n        {\n            Dispose(true);\n        }\n    }\n}  Note how CosmosDB  supports parameterized SQL queries  to avoid SQL injection.  Now it's time to finalize the API. We provided an  end version of the APIs for your reference in the  azurecompleted  branch of the  KnowzyInternalApps  repo . The things to implement are:\n- Update  ShippingController.cs  to use your updated Orders Store class with Get(id), Put, Post and Delete methods. Use  this guide  to help. \n- Create a new controller called  ReceivingController.cs  to handle all the CRUD methods for Receiving. Note that this can share most of of the same  OrderStore.cs  methods you used for Shipping (both Shipping and Receiving domain classes implement the Order domain class).\n- Create a new controller called  PostalCarrierController.cs  to handle just the Get (read all) method for it. You can find the PostalCarriers inside the orders collection in CosmosDB. \n- Create new classes called  ICustomersStore.cs  and  CostumersStorecs  to implement the CRUD methods to go against the  customers  collection in CosmosDB.\n- Create a new controller called  CostumerController.cs  to handle just the Get (read all) method for it.   Again: you have access to an  end version of the APIs for your reference in the  azurecompleted  branch of the  KnowzyInternalApps  repo  to help.", 
            "title": "3. Implement the Orders API"
        }, 
        {
            "location": "/stories/4/412_OrdersAPI/#4-package-for-release", 
            "text": "Now that we've got a working API app, let's package up all of our required files into a single folder for easy distribution. This time, we'll specify the Release configuration.   Or from Visual Studio 2017, change the configuration to  Release , right click on the API project, select  Publish , and choose  Folder  as the destination.  By default, this places your app files in a folder named  bin/Release/PublishOutput . We'll use this output path in  Step 4.1.4  when we build a Docker image for our app.", 
            "title": "4. Package for release"
        }, 
        {
            "location": "/stories/4/412_OrdersAPI/#5-references", 
            "text": "Troubleshooting guide  .NET Core CLI reference  Introduction to ASP.NET Core  Configuration in .NET Core  Azure Cosmos DB: Getting started with the CosmosDB API and .NET Core  eShopOnContainers sample reference microservice and container based application", 
            "title": "5. References"
        }, 
        {
            "location": "/stories/4/412_OrdersAPI/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/4/413_ProductsAPI/", 
            "text": "Task 4.1.3 - Create API endpoint for product services\n\n\nYou've finished creating the Orders API, and now it's time to create one for Products.  \n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 4.1.2\n and all of its prerequisites.\n\n\n.NET Core SDK 1.1\n\n\n\n\nCreating a .NET Core App\n\n\n1. Create a New WebAPI Project\n\n\nThe steps to get started with the Products API are the same as our previous step where we created the \nOrders API\n. \n\n\nAgain you can use Visual Studio 2017 to create a new project in the \nsrc\\2. Services\\APIs\\Microsoft.Knowzy.ProductsAPI\n folder.\n\n\n2. Implement the Products API\n\n\nGo ahead and implement the Products API endpoints, using Visual Studio 2017 to test locally.\n\n\nImplement the following methods in the Products API that are used by the website:\n- Get all products\n- Get Product by id (includes product stock availability)\n- Add new product\n\n\nAgain: you have access to an \nend version of the APIs for your reference in the \nazurecompleted\n branch of the \nKnowzyInternalApps\n repo\n to help.\n\n\n3. Package for release\n\n\nLike before, package the Products API using Visual Studio, then continue to \nTask 4.1.4 - Create Docker images\n. \n\n\n4. References\n\n\n\n\nTroubleshooting guide\n\n\nStep 4.1.2 - Orders API\n\n\n\n\ncontinue to \nnext task", 
            "title": "413 ProductsAPI"
        }, 
        {
            "location": "/stories/4/413_ProductsAPI/#task-413-create-api-endpoint-for-product-services", 
            "text": "You've finished creating the Orders API, and now it's time to create one for Products.", 
            "title": "Task 4.1.3 - Create API endpoint for product services"
        }, 
        {
            "location": "/stories/4/413_ProductsAPI/#prerequisites", 
            "text": "This task has a dependency on  Task 4.1.2  and all of its prerequisites.  .NET Core SDK 1.1", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/4/413_ProductsAPI/#creating-a-net-core-app", 
            "text": "", 
            "title": "Creating a .NET Core App"
        }, 
        {
            "location": "/stories/4/413_ProductsAPI/#1-create-a-new-webapi-project", 
            "text": "The steps to get started with the Products API are the same as our previous step where we created the  Orders API .   Again you can use Visual Studio 2017 to create a new project in the  src\\2. Services\\APIs\\Microsoft.Knowzy.ProductsAPI  folder.", 
            "title": "1. Create a New WebAPI Project"
        }, 
        {
            "location": "/stories/4/413_ProductsAPI/#2-implement-the-products-api", 
            "text": "Go ahead and implement the Products API endpoints, using Visual Studio 2017 to test locally.  Implement the following methods in the Products API that are used by the website:\n- Get all products\n- Get Product by id (includes product stock availability)\n- Add new product  Again: you have access to an  end version of the APIs for your reference in the  azurecompleted  branch of the  KnowzyInternalApps  repo  to help.", 
            "title": "2. Implement the Products API"
        }, 
        {
            "location": "/stories/4/413_ProductsAPI/#3-package-for-release", 
            "text": "Like before, package the Products API using Visual Studio, then continue to  Task 4.1.4 - Create Docker images .", 
            "title": "3. Package for release"
        }, 
        {
            "location": "/stories/4/413_ProductsAPI/#4-references", 
            "text": "Troubleshooting guide  Step 4.1.2 - Orders API", 
            "title": "4. References"
        }, 
        {
            "location": "/stories/4/413_ProductsAPI/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/4/414_Docker/", 
            "text": "Task 4.1.4 - Create Docker images\n\n\n1. Prerequisites\n\n\n\n\nDocker for Windows\n (Stable channel)\n\n\n\n\na. Configuring Docker for Windows\n\n\nOn Windows, you'll need to share your drive with Docker in order to build images.\n\n\ni) Open up Docker settings by right-clicking the Docker icon in the taskbar, and choosing Settings.\n\n\nii) Go to the \nShared Drives\n tab and share the C drive \n\n\n\n\nIf you receive a firewall error, try these \nTroubleshooting\n steps. \n\n\n2. Building Images\n\n\nIf you have Visual Studio 2017 you can have it create Docker files for you by doing the following:\n* Right click on the Microsoft.Knowzy.WebApp project, select \nAdd -\n Docker Support\n. If you are on prompted for Target OS, choose \nLinux\n and click OK.\n\n\n\n\n\n\nThis will create a Dockerfile file in your WebApp project, and add a new docker-compose project type to your solution.\n\n\n\n\nUse the same instructions and add Docker Support to the Microsoft.Knowzy.OrdersAPI project \n\n\nUse the same instructions and add Docker Support to the Microsoft.Knowzy.ProductsAPI project\n\n\n\n\nIn the end you should have Dockerfile in each of those three projects, and all three referenced in your Docker compose project. \n\n\nNow under the \ndocker-compose.yml\n file, find the \ndocker-compose.override.yml\n file, and modify it with the following (changing the values of your CosmosDB endpoint and key):\n\n\nversion: '3'\n\nservices:\n  microsoft.knowzy.webapp:\n    environment:\n     - ASPNETCORE_ENVIRONMENT=Development\n     - ASPNETCORE_URLS=http://0.0.0.0:5101\n     - ORDERSAPI_URL=http://microsoft.knowzy.ordersapi:5102\n     - PRODUCTSAPI_URL=http://microsoft.knowzy.productsapi:5103\n    ports:\n      - \n5101:5101\n\n\n  microsoft.knowzy.ordersapi:\n    environment:\n      - ASPNETCORE_ENVIRONMENT=Development\n      - ASPNETCORE_URLS=http://0.0.0.0:5102\n      - COSMOSDB_ENDPOINT=\n**YOUR COSMOSDB ENDPOINT**\n\n      - COSMOSDB_KEY=\n**YOUR KEY**\n\n    ports:\n      - \n5102:5102\n\n\n  microsoft.knowzy.productsapi:\n    environment:\n      - ASPNETCORE_ENVIRONMENT=Development\n      - ASPNETCORE_URLS=http://0.0.0.0:5103\n      - COSMOSDB_ENDPOINT=\n**YOUR COSMOSDB ENDPOINT**\n\n      - COSMOSDB_KEY=\n**YOUR KEY**\n\n    ports:\n      - \n5103:5103\n\n\n\n\n\nYou can now start debugging the Docker Compose project; it will create all three Docker images and run them on your local dev environment.\n\n\nDockerfile Reference\n\n\nIf you're new to Docker, here's a quick overview of the Dockerfile for the Orders API, with an explanation for each statement\n\n\n# Use the aspnetcore image as a base\nFROM microsoft/aspnetcore:1.1\n\n# Create a variable called source that has the path of the publish directory\nARG source\n\n# Use /app inside the created container to hold our files\nWORKDIR /app\n\n# Expose port 80 from our created container. This gets overwritten by the docker compose override file\nEXPOSE 80\n\n# Copy from files in the source folder (or obj/Docker/publish if source was not set) into the current folder (/app). \nCOPY ${source:-obj/Docker/publish} .\n\n# The entrypoint for the container is the command: dotnet Microsoft.Knowzy.OrdersAPI.dll\nENTRYPOINT [\ndotnet\n, \nMicrosoft.Knowzy.OrdersAPI.dll\n]\n\n\n\n\n\n\nNote how we are using \ndotnet\n and the kestrel web server in the configuration to host the APIs and the Web App in their containers. For more information on hosting ASP.NET Core in production see this \narticle\n.\n\n\n\n\ndocker-compose.yml Reference\n\n\nAnd an overview of what's going on in the docker-compose file\n\n\nversion: '3'\n\nservices:\n\n  # Defines a service and gives it a name\n  microsoft.knowzy.webapp:\n\n    # The image tag (in Docker, tags are used as version numbers)\n    image: microsoft.knowzy.webapp\n\n    # Tell Docker to build a new image\n    build:\n      # Specify the location of the Dockerfile used to build the image\n      context: ./src/1. WebApp/Microsoft.Knowzy.WebApp\n      dockerfile: Dockerfile\n\n...\n\n\n\n\n3. Interacting with Docker via PowerShell\n\n\nYou've run your apps by debugging the docker-compose project in Visual Studio. Before you can push your images out to the world, you'll need to know a few things about interacting with Docker. Open up a PowerShell session in the \nKnowzy_Shipping_WebApp\n folder\n\n\n# List your running containers\ndocker ps\n\n\n\n\nCONTAINER ID        IMAGE                          COMMAND               CREATED             STATUS              PORTS                            NAMES\nb0ee3710499e        microsoft.knowzy.webapp        \ntail -f /dev/null\n   2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5101-\n5101/tcp   dockercompose9124822939927181477_microsoft.knowzy.webapp_1\n82a53378a7c6        microsoft.knowzy.ordersapi     \ntail -f /dev/null\n   2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5102-\n5102/tcp   dockercompose9124822939927181477_microsoft.knowzy.ordersapi_1\n88b91969038c        microsoft.knowzy.productsapi   \ntail -f /dev/null\n   2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5103-\n5103/tcp   dockercompose9124822939927181477_microsoft.knowzy.productsapi_1\n\n\n\n\nYou'll see that Visual Studio and Docker have generated 3 images, started 3 containers, and have grouped them all together with the same name prefix, in this case, \ndockercompose9124822939927181477\n.\n\n\nSince you've mapped host ports to containers, you're now able to interact with each of them on localhost by navigating to these urls:\n\n\n\n\nOrders API - \nhttp://localhost:5102/api/values/5\n\n\nProducts API - \nhttp://localhost:5103/api/values/5\n\n\nWeb App - \nhttp://localhost:5101\n\n\n\n\nDocker containers come and go frequently. You may want to practice and stop your currently running containers to free up some computing resources. In your PowerShell window, run the following, using your name prefix, which was displayed by \ndocker ps\n. \n\n\n# Remove resources for your named project\ndocker-compose -p \nYOUR_NAME_PREFIX\n down\n\n\n\n\nIf you want to spin up your containers again, you can debug the docker-compose project in Visual Studio, or interact directly via PowerShell by running the following commands:\n\n\n# Create and start containers\n# -f: Use the compose \n override files\n# -d: Detach (Run containers in the background)\n# --build: Build images before starting containers\ndocker-compose -f \ndocker-compose.yml\n -f \ndocker-compose.override.yml\n up -d --build\n\n# Remove containers. \n# Because we used the defaults, so we don't have to specify a project name\ndocker-compose down\n\n\n\n\nNote that you don't have to use Docker Compose to run your containers. You could do it all using just the \ndocker\n command to create / start / remove the containers, but higher level tooling can greatly increase your productivity.\n\n\nAfter you're done interacting with your containers, run the following to look at the images that you've built\n\n\ndocker image ls \n\n\n\n\nREPOSITORY                                                     TAG                 IMAGE ID            CREATED             SIZE\nmicrosoft.knowzy.productsapi                                   latest              0cf302713f5a        12 minutes ago      325 MB\nmicrosoft.knowzy.webapp                                        latest              a26d42ad4ecd        12 minutes ago      337 MB\nmicrosoft.knowzy.ordersapi                                     latest              f48275db75b4        12 minutes ago      325 MB\n\n\n\n\n4. Deploying to a Docker Registry\n\n\nSo far, you've developed a few applications, packaged them in Docker images, and have tested them in a production-like environment by running them inside a container on your local computer. To get your apps running in the cloud, your next step is to push your images to a Docker registry.\n\n\nYou can use \nAzure Container Registry\n to hold your images. There are a few reasons to do this. First, you want to make sure our images aren't available to just anyone on the Internet. You want to be able to control access to your images! You will also want your images to be available in the same region as your compute resources for quick deployments.\n\n\n a. Create an Azure Container Registry in Azure Cloud Shell\n\n\nUsing the Azure Cloud Shell, set up some variables for your registry. These will be specific to you:\n\n\n# Create some variables using Azure Cloud Shell\nRESOURCE_GROUP=myResourceGroup\nACR_NAME=buildtourregistry\n\n\n\n\n\n\nIf your resource group hasn't been created yet, the following command will create one in the East US region: \naz group create -n $RESOURCE_GROUP -l eastus\n\n\n\n\nNext, use an Azure CLI command to create your container registry. \n\n\nNote the use of the \n--admin-enabled\n switch, which enables a simple username/password logon. In a production environment, you'll likely want to disable this option and create a Service Principal, but this will get us up and running for now.\n\n\naz acr create --resource-group $RESOURCE_GROUP --name $ACR_NAME --sku Basic --admin-enabled\n\n\n\n\nYou're all set up with a registry, with the full name of \n$ACR_NAME.azurecr.io\n.\n\n\nExecute the following command to get the admin password for your newly created registry:\n\n\naz acr credential show -n $ACR_NAME -g $RESOURCE_GROUP\n\n\n\n\nb. Connect to Your Registry with PowerShell\n\n\nGo back to your PowerShell window and login to your registry so we can push some images. Run the following command, using either the \npassword\n or \npassword2\n result from the previous command as your password:\n\n\n# Set up PowerShell variables to match those used in the Cloud Shell\n# Again - these will be specific to you\n$ACR_NAME = \nbuildtourregistry\n\n\ndocker login -u $ACR_NAME -p \nyour password\n \n$ACR_NAME.azurecr.io\n\n\n\n\n\n\n\nIf you're having trouble copy/pasting the password from the Azure Cloud Shell to PowerShell, try highlighting your password and making sure your cursor is over the highlighted text, and then right click.\n\n\n\n\nc. Push an Image\n\n\nYou've already got some tagged images, and now you need to tell Docker that they're associated with your newly created registry. You'll specify the \nknowzy\n namespace before pushing them to keep these apps grouped together. This is as simple as adding another tag for our existing images, using the following commands.\n\n\n# Add additional tags to the existing images\ndocker tag microsoft.knowzy.ordersapi \n$ACR_NAME.azurecr.io/knowzy/ordersapi:1\n\ndocker tag microsoft.knowzy.productsapi \n$ACR_NAME.azurecr.io/knowzy/productsapi:1\n\ndocker tag microsoft.knowzy.webapp \n$ACR_NAME.azurecr.io/knowzy/webapp:1\n\n\n# View the new tags. Notice there are multiple tags for the same image id\ndocker image ls\n\n\n\n\nTo push images to your registry, use the following commands:\n\n\n# The first push will take a moment\ndocker push \n$ACR_NAME.azurecr.io/knowzy/ordersapi:1\n\n\n# The subsequent images will be much faster because they use a common base image\ndocker push \n$ACR_NAME.azurecr.io/knowzy/productsapi:1\n\ndocker push \n$ACR_NAME.azurecr.io/knowzy/webapp:1\n\n\n\n\n\nWhen finished, you can look at your images in your Azure Container Registry by using the following commands in the Azure Cloud Shell:\n\n\n# Use the Cloud Shell to inspect your registry\naz acr repository list -n $ACR_NAME\naz acr repository show-tags -n $ACR_NAME --repository knowzy/ordersapi\n\n\n\n\n4. References\n\n\n\n\nTroubleshooting guide\n\n\nDockerfile reference\n\n\nDocker CLI reference\n\n\nAzure CLI reference\n\n\nAzure Container Registry reference\n\n\n\n\ncontinue to \nnext task", 
            "title": "414 Docker"
        }, 
        {
            "location": "/stories/4/414_Docker/#task-414-create-docker-images", 
            "text": "", 
            "title": "Task 4.1.4 - Create Docker images"
        }, 
        {
            "location": "/stories/4/414_Docker/#1-prerequisites", 
            "text": "Docker for Windows  (Stable channel)", 
            "title": "1. Prerequisites"
        }, 
        {
            "location": "/stories/4/414_Docker/#a-configuring-docker-for-windows", 
            "text": "On Windows, you'll need to share your drive with Docker in order to build images.  i) Open up Docker settings by right-clicking the Docker icon in the taskbar, and choosing Settings.  ii) Go to the  Shared Drives  tab and share the C drive    If you receive a firewall error, try these  Troubleshooting  steps.", 
            "title": "a. Configuring Docker for Windows"
        }, 
        {
            "location": "/stories/4/414_Docker/#2-building-images", 
            "text": "If you have Visual Studio 2017 you can have it create Docker files for you by doing the following:\n* Right click on the Microsoft.Knowzy.WebApp project, select  Add -  Docker Support . If you are on prompted for Target OS, choose  Linux  and click OK.    This will create a Dockerfile file in your WebApp project, and add a new docker-compose project type to your solution.   Use the same instructions and add Docker Support to the Microsoft.Knowzy.OrdersAPI project   Use the same instructions and add Docker Support to the Microsoft.Knowzy.ProductsAPI project   In the end you should have Dockerfile in each of those three projects, and all three referenced in your Docker compose project.   Now under the  docker-compose.yml  file, find the  docker-compose.override.yml  file, and modify it with the following (changing the values of your CosmosDB endpoint and key):  version: '3'\n\nservices:\n  microsoft.knowzy.webapp:\n    environment:\n     - ASPNETCORE_ENVIRONMENT=Development\n     - ASPNETCORE_URLS=http://0.0.0.0:5101\n     - ORDERSAPI_URL=http://microsoft.knowzy.ordersapi:5102\n     - PRODUCTSAPI_URL=http://microsoft.knowzy.productsapi:5103\n    ports:\n      -  5101:5101 \n\n  microsoft.knowzy.ordersapi:\n    environment:\n      - ASPNETCORE_ENVIRONMENT=Development\n      - ASPNETCORE_URLS=http://0.0.0.0:5102\n      - COSMOSDB_ENDPOINT= **YOUR COSMOSDB ENDPOINT** \n      - COSMOSDB_KEY= **YOUR KEY** \n    ports:\n      -  5102:5102 \n\n  microsoft.knowzy.productsapi:\n    environment:\n      - ASPNETCORE_ENVIRONMENT=Development\n      - ASPNETCORE_URLS=http://0.0.0.0:5103\n      - COSMOSDB_ENDPOINT= **YOUR COSMOSDB ENDPOINT** \n      - COSMOSDB_KEY= **YOUR KEY** \n    ports:\n      -  5103:5103   You can now start debugging the Docker Compose project; it will create all three Docker images and run them on your local dev environment.", 
            "title": "2. Building Images"
        }, 
        {
            "location": "/stories/4/414_Docker/#dockerfile-reference", 
            "text": "If you're new to Docker, here's a quick overview of the Dockerfile for the Orders API, with an explanation for each statement  # Use the aspnetcore image as a base\nFROM microsoft/aspnetcore:1.1\n\n# Create a variable called source that has the path of the publish directory\nARG source\n\n# Use /app inside the created container to hold our files\nWORKDIR /app\n\n# Expose port 80 from our created container. This gets overwritten by the docker compose override file\nEXPOSE 80\n\n# Copy from files in the source folder (or obj/Docker/publish if source was not set) into the current folder (/app). \nCOPY ${source:-obj/Docker/publish} .\n\n# The entrypoint for the container is the command: dotnet Microsoft.Knowzy.OrdersAPI.dll\nENTRYPOINT [ dotnet ,  Microsoft.Knowzy.OrdersAPI.dll ]   Note how we are using  dotnet  and the kestrel web server in the configuration to host the APIs and the Web App in their containers. For more information on hosting ASP.NET Core in production see this  article .", 
            "title": "Dockerfile Reference"
        }, 
        {
            "location": "/stories/4/414_Docker/#docker-composeyml-reference", 
            "text": "And an overview of what's going on in the docker-compose file  version: '3'\n\nservices:\n\n  # Defines a service and gives it a name\n  microsoft.knowzy.webapp:\n\n    # The image tag (in Docker, tags are used as version numbers)\n    image: microsoft.knowzy.webapp\n\n    # Tell Docker to build a new image\n    build:\n      # Specify the location of the Dockerfile used to build the image\n      context: ./src/1. WebApp/Microsoft.Knowzy.WebApp\n      dockerfile: Dockerfile\n\n...", 
            "title": "docker-compose.yml Reference"
        }, 
        {
            "location": "/stories/4/414_Docker/#3-interacting-with-docker-via-powershell", 
            "text": "You've run your apps by debugging the docker-compose project in Visual Studio. Before you can push your images out to the world, you'll need to know a few things about interacting with Docker. Open up a PowerShell session in the  Knowzy_Shipping_WebApp  folder  # List your running containers\ndocker ps  CONTAINER ID        IMAGE                          COMMAND               CREATED             STATUS              PORTS                            NAMES\nb0ee3710499e        microsoft.knowzy.webapp         tail -f /dev/null    2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5101- 5101/tcp   dockercompose9124822939927181477_microsoft.knowzy.webapp_1\n82a53378a7c6        microsoft.knowzy.ordersapi      tail -f /dev/null    2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5102- 5102/tcp   dockercompose9124822939927181477_microsoft.knowzy.ordersapi_1\n88b91969038c        microsoft.knowzy.productsapi    tail -f /dev/null    2 minutes ago       Up 2 minutes        80/tcp, 0.0.0.0:5103- 5103/tcp   dockercompose9124822939927181477_microsoft.knowzy.productsapi_1  You'll see that Visual Studio and Docker have generated 3 images, started 3 containers, and have grouped them all together with the same name prefix, in this case,  dockercompose9124822939927181477 .  Since you've mapped host ports to containers, you're now able to interact with each of them on localhost by navigating to these urls:   Orders API -  http://localhost:5102/api/values/5  Products API -  http://localhost:5103/api/values/5  Web App -  http://localhost:5101   Docker containers come and go frequently. You may want to practice and stop your currently running containers to free up some computing resources. In your PowerShell window, run the following, using your name prefix, which was displayed by  docker ps .   # Remove resources for your named project\ndocker-compose -p  YOUR_NAME_PREFIX  down  If you want to spin up your containers again, you can debug the docker-compose project in Visual Studio, or interact directly via PowerShell by running the following commands:  # Create and start containers\n# -f: Use the compose   override files\n# -d: Detach (Run containers in the background)\n# --build: Build images before starting containers\ndocker-compose -f  docker-compose.yml  -f  docker-compose.override.yml  up -d --build\n\n# Remove containers. \n# Because we used the defaults, so we don't have to specify a project name\ndocker-compose down  Note that you don't have to use Docker Compose to run your containers. You could do it all using just the  docker  command to create / start / remove the containers, but higher level tooling can greatly increase your productivity.  After you're done interacting with your containers, run the following to look at the images that you've built  docker image ls   REPOSITORY                                                     TAG                 IMAGE ID            CREATED             SIZE\nmicrosoft.knowzy.productsapi                                   latest              0cf302713f5a        12 minutes ago      325 MB\nmicrosoft.knowzy.webapp                                        latest              a26d42ad4ecd        12 minutes ago      337 MB\nmicrosoft.knowzy.ordersapi                                     latest              f48275db75b4        12 minutes ago      325 MB", 
            "title": "3. Interacting with Docker via PowerShell"
        }, 
        {
            "location": "/stories/4/414_Docker/#4-deploying-to-a-docker-registry", 
            "text": "So far, you've developed a few applications, packaged them in Docker images, and have tested them in a production-like environment by running them inside a container on your local computer. To get your apps running in the cloud, your next step is to push your images to a Docker registry.  You can use  Azure Container Registry  to hold your images. There are a few reasons to do this. First, you want to make sure our images aren't available to just anyone on the Internet. You want to be able to control access to your images! You will also want your images to be available in the same region as your compute resources for quick deployments.", 
            "title": "4. Deploying to a Docker Registry"
        }, 
        {
            "location": "/stories/4/414_Docker/#b-connect-to-your-registry-with-powershell", 
            "text": "Go back to your PowerShell window and login to your registry so we can push some images. Run the following command, using either the  password  or  password2  result from the previous command as your password:  # Set up PowerShell variables to match those used in the Cloud Shell\n# Again - these will be specific to you\n$ACR_NAME =  buildtourregistry \n\ndocker login -u $ACR_NAME -p  your password   $ACR_NAME.azurecr.io    If you're having trouble copy/pasting the password from the Azure Cloud Shell to PowerShell, try highlighting your password and making sure your cursor is over the highlighted text, and then right click.", 
            "title": "b. Connect to Your Registry with PowerShell"
        }, 
        {
            "location": "/stories/4/414_Docker/#c-push-an-image", 
            "text": "You've already got some tagged images, and now you need to tell Docker that they're associated with your newly created registry. You'll specify the  knowzy  namespace before pushing them to keep these apps grouped together. This is as simple as adding another tag for our existing images, using the following commands.  # Add additional tags to the existing images\ndocker tag microsoft.knowzy.ordersapi  $ACR_NAME.azurecr.io/knowzy/ordersapi:1 \ndocker tag microsoft.knowzy.productsapi  $ACR_NAME.azurecr.io/knowzy/productsapi:1 \ndocker tag microsoft.knowzy.webapp  $ACR_NAME.azurecr.io/knowzy/webapp:1 \n\n# View the new tags. Notice there are multiple tags for the same image id\ndocker image ls  To push images to your registry, use the following commands:  # The first push will take a moment\ndocker push  $ACR_NAME.azurecr.io/knowzy/ordersapi:1 \n\n# The subsequent images will be much faster because they use a common base image\ndocker push  $ACR_NAME.azurecr.io/knowzy/productsapi:1 \ndocker push  $ACR_NAME.azurecr.io/knowzy/webapp:1   When finished, you can look at your images in your Azure Container Registry by using the following commands in the Azure Cloud Shell:  # Use the Cloud Shell to inspect your registry\naz acr repository list -n $ACR_NAME\naz acr repository show-tags -n $ACR_NAME --repository knowzy/ordersapi", 
            "title": "c. Push an Image"
        }, 
        {
            "location": "/stories/4/414_Docker/#4-references", 
            "text": "Troubleshooting guide  Dockerfile reference  Docker CLI reference  Azure CLI reference  Azure Container Registry reference", 
            "title": "4. References"
        }, 
        {
            "location": "/stories/4/414_Docker/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/4/415_Kubernetes/", 
            "text": "Task 4.1.5 - Deploy to Kubernetes on Azure Container Services\n\n\n1. Prerequisites\n\n\n\n\nAccess to Azure subscription.\n\n\n\nAzure Cloud shell should be pointed toward the correct subscription, more details in \nStep 4.1.1\n\n\nYou'll also need the name of the resource group created in \nStep 4.1.1\n\n\n\n\n2. Creating and deploying to a Kubernetes cluster in Azure Container Service\n\n\na. Set up the cluster with Azure Cloud Shell\n\n\nWe're going to be working within the Azure Cloud Shell. Lets start by setting up a few variables:\n\n\n# Use the name of the Resource Group created in 4.1.1 if this is not the same Cloud Shell session\nRESOURCE_GROUP=\nresource group name\n\n\n# A unique DNS Prefix for your cluster, which will also be the Kubernetes cluster name\nDNS_PREFIX=\nunique cluster name\n\n\n# The name for the ACS Instance\nACS_NAME=\nunique ACS instance name\n\n\n\n\n\nb. Create the cluster using the Azure CLI\n\n\nWe'll add the \n--generate-ssh-keys\n parameter which generates the necessary SSH key files for the deployment if they don't exist already in the default \n~/.ssh/\n directory.\n\n\n\n\nThese keys are needed to grant access to the cluster, and will be stored in the Storage Account created for your Cloud Shell. You can learn more by visiting the \nCloud Shell documentation\n\n\n\n\naz acs create --orchestrator-type=kubernetes --agent-vm-size Standard_A1 --resource-group $RESOURCE_GROUP --name=$ACS_NAME --dns-prefix=$DNS_PREFIX --generate-ssh-keys\n\n\n\n\nThis will take several minutes as your resources are created and configured. Once your cluster is created, you'll need to get the config from Kubernetes into your Cloud Shell session so that you can interact with it.\n\n\naz acs kubernetes get-credentials --resource-group=$RESOURCE_GROUP --name=$ACS_NAME\n\n\n\n\nVerify that you can used \nkubectl\n to talk to the cluster\n\n\nkubectl cluster-info\n\n\n\n\nc. Deploying your container images \n(from \nStep 4.1.4\n)\n\n\ni) Store the name of your Azure Container Registry\n\n\nThis registry was generated in step \n4.1.4\n, and is where the images containing the apps and services we want to deploy are located.\n\n\nACR_NAME=\nname of registry that contains your images\n\n\n\n\n\nii) Deploy your two services from their respective Docker images. We can deploy by telling kubernetes to get the docker images and deploy them, using the run command in \nkubectl\n, we're passing the \n--env\n parameter, to tell the container images the connection string for your data-store, so the running services once deployed know how to connect to the CosmosDB.\n\n\n# Deploy to Kubernetes\nkubectl run ordersapi --image=$ACR_NAME.azurecr.io/knowzy/ordersapi:1 --env \nCOSMOSDB_ENDPOINT=https://\n your cosmosdb name\n.documents.azure.com:443/\n --env \nCOSMOSDB_KEY=\nyour Cosmos DB key string\n\nkubectl run productsapi --image=$ACR_NAME.azurecr.io/knowzy/productsapi:1 --env \nCOSMOSDB_ENDPOINT=https://\n your cosmosdb name\n.documents.azure.com:443/\n --env \nCOSMOSDB_KEY=\nyour Cosmos DB key string\n\nkubectl run webapp --image=$ACR_NAME.azurecr.io/knowzy/webapp:1\n\n# View your running pods\nkubectl get pods\n\n\n\n\niii) Expose your services\n\n\nYou've got containers running on Kubernetes, but they're not yet exposed to the outside world. Let's do that now\n\n\n# This will create an Azure Load Balancer to direct traffic to your app\nkubectl expose deployment ordersapi --port=80 --type=LoadBalancer\nkubectl expose deployment productsapi --port=80 --type=LoadBalancer\n\n# List Kubernetes services, which includes the external IP\nkubectl get svc\n\n\n\n\nNAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE\nkubernetes   10.0.0.1     \nnone\n        443/TCP        2d\nordersapi    10.0.8.27    \npending\n     80:30213/TCP   3h\nproductsapi  10.0.8.28    \npending\n     80:30175/TCP   19s\n\n\n\n\nInitially, you will see something similar to the above. Wait a couple of minutes for the IP's and load balancers to be provisioned, and re-run \nkubectl get svc\n to see your public-facing IP's.\n\n\nNAME          CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE\nkubernetes    10.0.0.1       \nnone\n          443/TCP          2d\nordersapi     10.0.8.27      13.81.60.236    80:30213/TCP     3h\nproductsapi   10.0.8.28      52.232.72.172   80:30175/TCP     5m\n\n\n\n\nYou can test your deployment as soon as the \npending\n external IP is provided. Simply go into your browser to the url provided \nhttp://\nExternal IP\n/api/values\n.\n\n\niii) Deploy your webapp from the Docker image. We deploy the same way as above, but we don't need the database parameter, as the front end web application should have no direct access to the CosmosDB. Instead we should provide the url to the api services\n\n\nkubectl run webapp --image=$ACR_NAME.azurecr.io/knowzy/webapp:1 --env \nPRODUCTSAPI_URL=\nOrders API IP\n --env \nORDERAPI_URL=\nOrders API IP\n\n\n\n\n\niv) Expose your webapp and consume your APIs\n\n\nkubectl expose deployment webapp --port=80 --type=LoadBalancer\n\n\n\n\nWait for the IP to come back \nkubectl get sv\n and access it in your browser\n\n\nNAME          CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE\nkubernetes    10.0.0.1       \nnone\n          443/TCP          2d\nordersapi     10.0.8.27      13.8.60.236    8080:30213/TCP   3h\nproductsapi   10.0.148.198   52.232.72.12   80:30175/TCP     5m\nwebapp   10.0.142.191   54.22.172.17   80:31945/TCP     5m\n\n\n\n\n3. References\n\n\n\n\nPersisting Files in Azure Cloud Shell\n\n\nAzure resource naming best practices\n\n\nAzure CLI reference\n\n\nkubectl overview\n\n\n\n\ncontinue to \nnext task", 
            "title": "415 Kubernetes"
        }, 
        {
            "location": "/stories/4/415_Kubernetes/#task-415-deploy-to-kubernetes-on-azure-container-services", 
            "text": "", 
            "title": "Task 4.1.5 - Deploy to Kubernetes on Azure Container Services"
        }, 
        {
            "location": "/stories/4/415_Kubernetes/#1-prerequisites", 
            "text": "Access to Azure subscription.  Azure Cloud shell should be pointed toward the correct subscription, more details in  Step 4.1.1  You'll also need the name of the resource group created in  Step 4.1.1", 
            "title": "1. Prerequisites"
        }, 
        {
            "location": "/stories/4/415_Kubernetes/#2-creating-and-deploying-to-a-kubernetes-cluster-in-azure-container-service", 
            "text": "", 
            "title": "2. Creating and deploying to a Kubernetes cluster in Azure Container Service"
        }, 
        {
            "location": "/stories/4/415_Kubernetes/#a-set-up-the-cluster-with-azure-cloud-shell", 
            "text": "We're going to be working within the Azure Cloud Shell. Lets start by setting up a few variables:  # Use the name of the Resource Group created in 4.1.1 if this is not the same Cloud Shell session\nRESOURCE_GROUP= resource group name \n\n# A unique DNS Prefix for your cluster, which will also be the Kubernetes cluster name\nDNS_PREFIX= unique cluster name \n\n# The name for the ACS Instance\nACS_NAME= unique ACS instance name", 
            "title": "a. Set up the cluster with Azure Cloud Shell"
        }, 
        {
            "location": "/stories/4/415_Kubernetes/#b-create-the-cluster-using-the-azure-cli", 
            "text": "We'll add the  --generate-ssh-keys  parameter which generates the necessary SSH key files for the deployment if they don't exist already in the default  ~/.ssh/  directory.   These keys are needed to grant access to the cluster, and will be stored in the Storage Account created for your Cloud Shell. You can learn more by visiting the  Cloud Shell documentation   az acs create --orchestrator-type=kubernetes --agent-vm-size Standard_A1 --resource-group $RESOURCE_GROUP --name=$ACS_NAME --dns-prefix=$DNS_PREFIX --generate-ssh-keys  This will take several minutes as your resources are created and configured. Once your cluster is created, you'll need to get the config from Kubernetes into your Cloud Shell session so that you can interact with it.  az acs kubernetes get-credentials --resource-group=$RESOURCE_GROUP --name=$ACS_NAME  Verify that you can used  kubectl  to talk to the cluster  kubectl cluster-info", 
            "title": "b. Create the cluster using the Azure CLI"
        }, 
        {
            "location": "/stories/4/415_Kubernetes/#c-deploying-your-container-images-from-step-414", 
            "text": "i) Store the name of your Azure Container Registry  This registry was generated in step  4.1.4 , and is where the images containing the apps and services we want to deploy are located.  ACR_NAME= name of registry that contains your images   ii) Deploy your two services from their respective Docker images. We can deploy by telling kubernetes to get the docker images and deploy them, using the run command in  kubectl , we're passing the  --env  parameter, to tell the container images the connection string for your data-store, so the running services once deployed know how to connect to the CosmosDB.  # Deploy to Kubernetes\nkubectl run ordersapi --image=$ACR_NAME.azurecr.io/knowzy/ordersapi:1 --env  COSMOSDB_ENDPOINT=https://  your cosmosdb name .documents.azure.com:443/  --env  COSMOSDB_KEY= your Cosmos DB key string \nkubectl run productsapi --image=$ACR_NAME.azurecr.io/knowzy/productsapi:1 --env  COSMOSDB_ENDPOINT=https://  your cosmosdb name .documents.azure.com:443/  --env  COSMOSDB_KEY= your Cosmos DB key string \nkubectl run webapp --image=$ACR_NAME.azurecr.io/knowzy/webapp:1\n\n# View your running pods\nkubectl get pods  iii) Expose your services  You've got containers running on Kubernetes, but they're not yet exposed to the outside world. Let's do that now  # This will create an Azure Load Balancer to direct traffic to your app\nkubectl expose deployment ordersapi --port=80 --type=LoadBalancer\nkubectl expose deployment productsapi --port=80 --type=LoadBalancer\n\n# List Kubernetes services, which includes the external IP\nkubectl get svc  NAME         CLUSTER-IP   EXTERNAL-IP   PORT(S)        AGE\nkubernetes   10.0.0.1      none         443/TCP        2d\nordersapi    10.0.8.27     pending      80:30213/TCP   3h\nproductsapi  10.0.8.28     pending      80:30175/TCP   19s  Initially, you will see something similar to the above. Wait a couple of minutes for the IP's and load balancers to be provisioned, and re-run  kubectl get svc  to see your public-facing IP's.  NAME          CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE\nkubernetes    10.0.0.1        none           443/TCP          2d\nordersapi     10.0.8.27      13.81.60.236    80:30213/TCP     3h\nproductsapi   10.0.8.28      52.232.72.172   80:30175/TCP     5m  You can test your deployment as soon as the  pending  external IP is provided. Simply go into your browser to the url provided  http:// External IP /api/values .  iii) Deploy your webapp from the Docker image. We deploy the same way as above, but we don't need the database parameter, as the front end web application should have no direct access to the CosmosDB. Instead we should provide the url to the api services  kubectl run webapp --image=$ACR_NAME.azurecr.io/knowzy/webapp:1 --env  PRODUCTSAPI_URL= Orders API IP  --env  ORDERAPI_URL= Orders API IP   iv) Expose your webapp and consume your APIs  kubectl expose deployment webapp --port=80 --type=LoadBalancer  Wait for the IP to come back  kubectl get sv  and access it in your browser  NAME          CLUSTER-IP     EXTERNAL-IP     PORT(S)          AGE\nkubernetes    10.0.0.1        none           443/TCP          2d\nordersapi     10.0.8.27      13.8.60.236    8080:30213/TCP   3h\nproductsapi   10.0.148.198   52.232.72.12   80:30175/TCP     5m\nwebapp   10.0.142.191   54.22.172.17   80:31945/TCP     5m", 
            "title": "c. Deploying your container images (from Step 4.1.4)"
        }, 
        {
            "location": "/stories/4/415_Kubernetes/#3-references", 
            "text": "Persisting Files in Azure Cloud Shell  Azure resource naming best practices  Azure CLI reference  kubectl overview", 
            "title": "3. References"
        }, 
        {
            "location": "/stories/4/415_Kubernetes/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/4/416_Integrate/", 
            "text": "Task 4.1.6 - Integrate Website and APIs\n\n\nNow that the APIs and the website and clients have been implemented, our team wants to integrate the website code with the APIs. \n\n\nPrerequisites\n\n\nThis task has a dependency on the Web App from \n1.1.1\n, the APIs created under section \n4.1.2\n and \n4.1.3\n, and the deployment to Kubernetes steps in section \n4.1.5\n, and all of their prerequisites.\n\n\nTask\n\n\n\n\n\n\nUpdate the website code to use the APIs instead of static files for data access.\n\n\n\n\n\n\nRedeploy the website with the updates.\n\n\n\n\n\n\nComments\n\n\n@ 9:02am\n\n\nI looked at the website code, and it seems to currently use a mock implementation of the API/data access. It's getting the initial data from static json files, and keeping the data in memory. In order to override the existing implementation for accesing data and integrate with the APIs we should implement the \nIOrderRepository\n interface whith our own custom class implementation that calls the APIs (using \nOrderRepositoryMock.cs\n as guidance), and then change the service configuration in \nStartup.cs\n class adding the new implementation files:\n\n\nc#\nservices.AddScoped\nIOrderRepository, OrderRepository\n();\n\n\n@ 9:15am\n\n\nWe can check the \nend version of the code for reference, in the \nazurecompleted\n branch of the \nKnowzyInternalApps\n repo\n to help. Especially the implementation of \nOrderRepository\n.\n\n\n@ 11:15am\n\n\nIn the Docker instructions in \n4.1.4\n for the dev machine, and Kubernetes instructions in \n4.1.5\n the web app container has the ORDERSAPI_URL and PRODUCTSAPI_URL environment variables with the two API endpoints URLs passed in to it. Now we can run website in the dev machine and deploy it via kubernetes again to get it to use the APIs.\n\n\ncontinue to \nnext task", 
            "title": "416 Integrate"
        }, 
        {
            "location": "/stories/4/416_Integrate/#task-416-integrate-website-and-apis", 
            "text": "Now that the APIs and the website and clients have been implemented, our team wants to integrate the website code with the APIs.", 
            "title": "Task 4.1.6 - Integrate Website and APIs"
        }, 
        {
            "location": "/stories/4/416_Integrate/#prerequisites", 
            "text": "This task has a dependency on the Web App from  1.1.1 , the APIs created under section  4.1.2  and  4.1.3 , and the deployment to Kubernetes steps in section  4.1.5 , and all of their prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/4/416_Integrate/#task", 
            "text": "Update the website code to use the APIs instead of static files for data access.    Redeploy the website with the updates.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/4/416_Integrate/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/4/416_Integrate/#902am", 
            "text": "I looked at the website code, and it seems to currently use a mock implementation of the API/data access. It's getting the initial data from static json files, and keeping the data in memory. In order to override the existing implementation for accesing data and integrate with the APIs we should implement the  IOrderRepository  interface whith our own custom class implementation that calls the APIs (using  OrderRepositoryMock.cs  as guidance), and then change the service configuration in  Startup.cs  class adding the new implementation files:  c#\nservices.AddScoped IOrderRepository, OrderRepository ();", 
            "title": "@ 9:02am"
        }, 
        {
            "location": "/stories/4/416_Integrate/#915am", 
            "text": "We can check the  end version of the code for reference, in the  azurecompleted  branch of the  KnowzyInternalApps  repo  to help. Especially the implementation of  OrderRepository .", 
            "title": "@ 9:15am"
        }, 
        {
            "location": "/stories/4/416_Integrate/#1115am", 
            "text": "In the Docker instructions in  4.1.4  for the dev machine, and Kubernetes instructions in  4.1.5  the web app container has the ORDERSAPI_URL and PRODUCTSAPI_URL environment variables with the two API endpoints URLs passed in to it. Now we can run website in the dev machine and deploy it via kubernetes again to get it to use the APIs.", 
            "title": "@ 11:15am"
        }, 
        {
            "location": "/stories/4/416_Integrate/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/4/421_SetupVSTS/", 
            "text": "Task 4.2.1 - Setup Visual Studio Team Services\n\n\nIn order to collaborate as a team, it would be best to store your source code in a Version Control System.  While there are many options for this, the CTO of Knowzy has asked you to use Visual Studio Team Services (VSTS) so that later on your can use it for Continuous Integration, Continuous Delivery, program management, and project planning.  In this task, you'll set up a VSTS instance to share with the team.\n\n\nPrerequisites\n\n\nThe only prerequisite for this task is that you have a Microsoft account.  If you do not already have one you can \nsign up for one here\n.\n\n\nTask\n\n\n\n\nSign up for a free Visual Studio Team Services account. \n\n\n\n\nOR\n\n\n\n\nSelect a Visual Studio Team Services account you already have access to and can share with your team.\n\n\n\n\nReferences\n\n\n\n\nVisual Studio Team Services landing page\n\n\n\n\ncontinue to \nnext task", 
            "title": "421 SetupVSTS"
        }, 
        {
            "location": "/stories/4/421_SetupVSTS/#task-421-setup-visual-studio-team-services", 
            "text": "In order to collaborate as a team, it would be best to store your source code in a Version Control System.  While there are many options for this, the CTO of Knowzy has asked you to use Visual Studio Team Services (VSTS) so that later on your can use it for Continuous Integration, Continuous Delivery, program management, and project planning.  In this task, you'll set up a VSTS instance to share with the team.", 
            "title": "Task 4.2.1 - Setup Visual Studio Team Services"
        }, 
        {
            "location": "/stories/4/421_SetupVSTS/#prerequisites", 
            "text": "The only prerequisite for this task is that you have a Microsoft account.  If you do not already have one you can  sign up for one here .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/4/421_SetupVSTS/#task", 
            "text": "Sign up for a free Visual Studio Team Services account.    OR   Select a Visual Studio Team Services account you already have access to and can share with your team.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/4/421_SetupVSTS/#references", 
            "text": "Visual Studio Team Services landing page", 
            "title": "References"
        }, 
        {
            "location": "/stories/4/421_SetupVSTS/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/4/422_DevopsKubernetes/", 
            "text": "Challenge 4.2.2 - Continuous Delivery to Kubernetes using VSTS\n\n\nThe CTO is pleased that you've deployed to Azure and Kubernetes.  However, now they'd like you to set up Continuous Delivery using the Visual Studio Team Services (VSTS) account you set up in \nTask 4.2.1\n.  Using VSTS will enable our development and operations department to have work together efficiently as a team and push new stable releases into production. The primary goal of this challenge is to automatically post a new release of our code into our production Kubernetes cluster with any commit to our git repository.\n\n\n\n\nPrerequisites\n\n\n\n\nThis task has a dependency on \nTask 4.1.5\n, \nTask 4.2.1\n, and all of their prerequisites.\n\n\nAccess to the Azure subscription you used in \nTask 4.1.5\n.\n\n\n\n\nTask\n\n\n\n\nSet up CI / CD with your application and Kubernetes on Azure.\n\n\n\n\nComments\n\n\n@ 3:37am\n\n\nI wasn't really sure where to get started with continuous integration or delivery but \nthis\n really helped me understand!\n\n\n@ 5:23am\n\n\nIt looks like you can install the \nKubernetes Extension for VSTS here\n.\n\n\n@ 10:15am\n\n\nI think I found \nstep by step instructions\n on setting this up!\n\n\n@ 4:58pm\n\n\nIf all goes according to plan, I should be able to demonstrate this working by \nfollowing this\n.\n\n\ncontinue to \nnext task", 
            "title": "422 DevopsKubernetes"
        }, 
        {
            "location": "/stories/4/422_DevopsKubernetes/#challenge-422-continuous-delivery-to-kubernetes-using-vsts", 
            "text": "The CTO is pleased that you've deployed to Azure and Kubernetes.  However, now they'd like you to set up Continuous Delivery using the Visual Studio Team Services (VSTS) account you set up in  Task 4.2.1 .  Using VSTS will enable our development and operations department to have work together efficiently as a team and push new stable releases into production. The primary goal of this challenge is to automatically post a new release of our code into our production Kubernetes cluster with any commit to our git repository.", 
            "title": "Challenge 4.2.2 - Continuous Delivery to Kubernetes using VSTS"
        }, 
        {
            "location": "/stories/4/422_DevopsKubernetes/#prerequisites", 
            "text": "This task has a dependency on  Task 4.1.5 ,  Task 4.2.1 , and all of their prerequisites.  Access to the Azure subscription you used in  Task 4.1.5 .", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/4/422_DevopsKubernetes/#task", 
            "text": "Set up CI / CD with your application and Kubernetes on Azure.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/4/422_DevopsKubernetes/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/4/422_DevopsKubernetes/#337am", 
            "text": "I wasn't really sure where to get started with continuous integration or delivery but  this  really helped me understand!", 
            "title": "@ 3:37am"
        }, 
        {
            "location": "/stories/4/422_DevopsKubernetes/#523am", 
            "text": "It looks like you can install the  Kubernetes Extension for VSTS here .", 
            "title": "@ 5:23am"
        }, 
        {
            "location": "/stories/4/422_DevopsKubernetes/#1015am", 
            "text": "I think I found  step by step instructions  on setting this up!", 
            "title": "@ 10:15am"
        }, 
        {
            "location": "/stories/4/422_DevopsKubernetes/#458pm", 
            "text": "If all goes according to plan, I should be able to demonstrate this working by  following this .", 
            "title": "@ 4:58pm"
        }, 
        {
            "location": "/stories/4/422_DevopsKubernetes/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/4/431_Telemetry/", 
            "text": "Task 4.3.1 - Set up Telemetry\n\n\nOur development team want to be able to monitor the health of the applications as well as find the source of bugs. The team also want to learn from production and use it to decide on future projects. \n\n\nPrerequisites\n\n\nThis task has a dependency on the Web App from \n1.1.1\n and the APIs created under section \n4.1.2\n and \n4.1.3\n and all of their prerequisites.\n\n\nTask\n\n\n\n\nCreate an Application Insights account from the Azure Portal or Visual Studio. \n\n\nAdd Application Insights telemetry logging to the Web App, Orders API, and Products API.\n\n\nUpdate the containers and kubernetes implementation to pass in the value of your instrumentation key to the applications in the containers.\n\n\nUse the Azure Portal to see the telemetry that is being captured.\n\n\n\n\nComments\n\n\n@ 9:02am\n\n\nI've found the following instructions that should help us get started:\n\n \nApplication Insights for ASP.NET Core\n\n\n \nManaging ASP.NET Core App Settings on Kubernetes", 
            "title": "431 Telemetry"
        }, 
        {
            "location": "/stories/4/431_Telemetry/#task-431-set-up-telemetry", 
            "text": "Our development team want to be able to monitor the health of the applications as well as find the source of bugs. The team also want to learn from production and use it to decide on future projects.", 
            "title": "Task 4.3.1 - Set up Telemetry"
        }, 
        {
            "location": "/stories/4/431_Telemetry/#prerequisites", 
            "text": "This task has a dependency on the Web App from  1.1.1  and the APIs created under section  4.1.2  and  4.1.3  and all of their prerequisites.", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/4/431_Telemetry/#task", 
            "text": "Create an Application Insights account from the Azure Portal or Visual Studio.   Add Application Insights telemetry logging to the Web App, Orders API, and Products API.  Update the containers and kubernetes implementation to pass in the value of your instrumentation key to the applications in the containers.  Use the Azure Portal to see the telemetry that is being captured.", 
            "title": "Task"
        }, 
        {
            "location": "/stories/4/431_Telemetry/#comments", 
            "text": "", 
            "title": "Comments"
        }, 
        {
            "location": "/stories/4/431_Telemetry/#902am", 
            "text": "I've found the following instructions that should help us get started:   Application Insights for ASP.NET Core    Managing ASP.NET Core App Settings on Kubernetes", 
            "title": "@ 9:02am"
        }, 
        {
            "location": "/stories/4/497_KubernetesVSTS/", 
            "text": "Setting Up Kubernetes and VSTS\n\n\nFor the sake of this exercise, \nlets focus only on the API code\n and any new releases you have. These changes will be tested by VSTS and, pushed into Azure Container Registry (ACR) once all your tests have passed (we won't go into writing tests today). Then VSTS will automatically deploy the latest version of the app into your cluster by obtaining the latest image from ACR.\n\n\nThe following two resources will provide you all the answers on how to accomplish this task, it\u00b4s your duty to understand them and consolidate the concepts to set up a full development cycle. Please note that none of these are a step-by-step tutorial to achieve what you want, but jointly you will be able to make it work:\n\n\n\n\nCI/CD to Kubernetes clusters using VSTS\n\n\nBuild and deploy your ASP.NET Core app to Azure\n\n\n\n\nYou should be able to do the following steps to provide CI/CD in a Kubernetes cluster using Azure.\n\n\n\n\nCreate a new project in your VSTS account.\n\n\nPush your API code into the project's repository in VSTS.\n\n\nInstall the VSTS Kubernetes \nextension\n.\n\n\nProvide Continuous Integration with VSTS by pushing your docker images with the latest version of the tested code into ACR.\n\n\nSet up a trigger to pull your new docker image into your Kubernetes cluster after it has been properly tested and deployed.", 
            "title": "497 KubernetesVSTS"
        }, 
        {
            "location": "/stories/4/497_KubernetesVSTS/#setting-up-kubernetes-and-vsts", 
            "text": "For the sake of this exercise,  lets focus only on the API code  and any new releases you have. These changes will be tested by VSTS and, pushed into Azure Container Registry (ACR) once all your tests have passed (we won't go into writing tests today). Then VSTS will automatically deploy the latest version of the app into your cluster by obtaining the latest image from ACR.  The following two resources will provide you all the answers on how to accomplish this task, it\u00b4s your duty to understand them and consolidate the concepts to set up a full development cycle. Please note that none of these are a step-by-step tutorial to achieve what you want, but jointly you will be able to make it work:   CI/CD to Kubernetes clusters using VSTS  Build and deploy your ASP.NET Core app to Azure   You should be able to do the following steps to provide CI/CD in a Kubernetes cluster using Azure.   Create a new project in your VSTS account.  Push your API code into the project's repository in VSTS.  Install the VSTS Kubernetes  extension .  Provide Continuous Integration with VSTS by pushing your docker images with the latest version of the tested code into ACR.  Set up a trigger to pull your new docker image into your Kubernetes cluster after it has been properly tested and deployed.", 
            "title": "Setting Up Kubernetes and VSTS"
        }, 
        {
            "location": "/stories/4/498_KubernetesCICDBehavior/", 
            "text": "Kubernetes and VSTS Expected Behavior\n\n\nAt the end of this challenge you should be able to follow these steps and get similar results:\n\n\n\n\nCommit a new change into your \nmaster\n branch.\n\n\nVSTS will build your project and test it.\n\n\nIf all the tests have been passed, VSTS will create and push a new Docker image with the new code. Please refer to previous section \n'Create Docker images'\n for the definition of the image.\n\n\nYour Kubernetes task created with the help of the VSTS Kubernetes \nextension\n will now run to pull the new image into the cluster.\n\n\nDo a request into your freshly deployed API and verify that your new changes are up and running.", 
            "title": "498 KubernetesCICDBehavior"
        }, 
        {
            "location": "/stories/4/498_KubernetesCICDBehavior/#kubernetes-and-vsts-expected-behavior", 
            "text": "At the end of this challenge you should be able to follow these steps and get similar results:   Commit a new change into your  master  branch.  VSTS will build your project and test it.  If all the tests have been passed, VSTS will create and push a new Docker image with the new code. Please refer to previous section  'Create Docker images'  for the definition of the image.  Your Kubernetes task created with the help of the VSTS Kubernetes  extension  will now run to pull the new image into the cluster.  Do a request into your freshly deployed API and verify that your new changes are up and running.", 
            "title": "Kubernetes and VSTS Expected Behavior"
        }, 
        {
            "location": "/stories/4/499_Troubleshooting/", 
            "text": "Task 4 Troubleshooting Guide\n\n\n\"Firewall detected\" when sharing drive\n\n\nIf you encounter a firewall error when sharing drives with Docker, you may need to reset Windows File and Printer sharing on your Hyper-V virtual switch.\n\n\n\n\nRight click your network connection in the taskbar, and choose \nNetwork and Sharing Center\n\n\nIn the left menu, select \nChange Adapter Settings\n\n\nRight click and open the properties for the \"vEthernet (DockerNAT)\" adapter\n\n\nUncheck the box for \nFile and Printer Sharing for Windows\n and hit OK\n\n\n\nOpen the properties again, re-enable \nFile and Printer Sharing for Windows\n and hit OK\n\n\nYou should now be able to share drives with Docker\n\n\n\n\nCase sensitivity\n\n\nIf you're using Windows to follow along, it's important to note that we're using Linux containers on Docker.\nThis means that if you have a case mismatch between file/folder names, you may encounter errors when building or\nrunning containers because Linux uses a case-sensitive file system.\n\n\nFor example, this could happen if you named your folder \nordersApi\n, which by default will produce a dll with\nthe path \nordersApi/bin/Release/netcoreapp1.1/publish/ordersApi.dll\n. When the supplied \nDockerfile\n is\nexecuted inside \nordersApi\n, everything looks great! But when you run the container, it will fail because\nthe \nENTRYPOINT\n is specified to look for \nordersapi.dll", 
            "title": "499 Troubleshooting"
        }, 
        {
            "location": "/stories/4/499_Troubleshooting/#task-4-troubleshooting-guide", 
            "text": "", 
            "title": "Task 4 Troubleshooting Guide"
        }, 
        {
            "location": "/stories/4/499_Troubleshooting/#firewall-detected-when-sharing-drive", 
            "text": "If you encounter a firewall error when sharing drives with Docker, you may need to reset Windows File and Printer sharing on your Hyper-V virtual switch.   Right click your network connection in the taskbar, and choose  Network and Sharing Center  In the left menu, select  Change Adapter Settings  Right click and open the properties for the \"vEthernet (DockerNAT)\" adapter  Uncheck the box for  File and Printer Sharing for Windows  and hit OK  Open the properties again, re-enable  File and Printer Sharing for Windows  and hit OK  You should now be able to share drives with Docker", 
            "title": "\"Firewall detected\" when sharing drive"
        }, 
        {
            "location": "/stories/4/499_Troubleshooting/#case-sensitivity", 
            "text": "If you're using Windows to follow along, it's important to note that we're using Linux containers on Docker.\nThis means that if you have a case mismatch between file/folder names, you may encounter errors when building or\nrunning containers because Linux uses a case-sensitive file system.  For example, this could happen if you named your folder  ordersApi , which by default will produce a dll with\nthe path  ordersApi/bin/Release/netcoreapp1.1/publish/ordersApi.dll . When the supplied  Dockerfile  is\nexecuted inside  ordersApi , everything looks great! But when you run the container, it will fail because\nthe  ENTRYPOINT  is specified to look for  ordersapi.dll", 
            "title": "Case sensitivity"
        }, 
        {
            "location": "/stories/5/511_Paint3d/", 
            "text": "Task 5.1.1 - Create the model in Paint3D\n\n\nCreating 3D models of our products opens up a world of opportunities. We can 3D print prototype noses, render them in 3D to see how they look, and even view them in Virtual Reality!\n\n\n3D Paint is a simple tool available in the Windows 10 Creators Update that allows us to create and paint 3D models. Perfect for this task!\n\n\nPrerequisites\n\n\nThis walkthrough assumes that you have:\n\n\n\n\nWindows 10 Creators Update\n\n\nPaint 3D\n\n\n\n\nTask\n\n\nCreate the basic 3D nose model\n\n\nFirst we will create the nose 3D model with a base color.\n\n\n\n\nFrom the Windows Start menu, launch \nPaint 3D\n. If the \nWelcome\n screen is displayed, Click \nNew\n.\n\n\nYou will see a blank white canvas where you will create your Knowzy nose prototype.\n\n\nThe menu at the top of the screen is where you select the tools you want to use. The brush icon (Art Tools) is for painting and coloring. The cube icon (3d objects) is for creating 3D objects. Click the cube icon to open the 3d objects menu. Ensure that the sphere in the 3D objects collection is selected:\n    \n\n\nUse the color palette to choose a color for the nose. You can click on the materials dropdown above the color palette to get different effects. For example, select \nGloss\n to make the nose shiny. Play with the colors and materials options to get the color you want.\n\n\nDraw a sphere on the canvas by placing the mouse pointer on the canvas. Press and hold the left mouse button while dragging the mouse until the sphere is the size you want. You can force the shape to be a circle by holding \nShift\n down while dragging the mouse. This is how our first prototype looked:\n    \n\n\n\n\nAdd details to the nose\n\n\nThe second task is to add details to the nose. You can use stickers, color variations and drawings.\n1. On the menu at the top of the screen, click the brush icon (Art tools) to see the tools available for drawing.\n\n\n\n\nNote: For these steps, it is important not to draw outside of the model on the white canvas because it will become part of the 3D model.\n\n\n\n\n\n\n\n\nUse any of the art tools to draw on the model. Be creative! For our first prototype, we used the Calligraphy pen with the \nThickness\n set to 36px to draw nostrils.\n\n\n\n\n\n\n\n\nThe Stickers menu (third icon from the left on the main menu) allows you to place stickers on the model. Feel free to play around with the various tools.\n\n\n\n\n\n\nSave and Export the model.\n\n\nThe last task is to save the model and export it to the Filmbox (FBX) format so we can use the model in Unity or BabylonJS. (For BabylonJS, we will convert it from .FBX to .OBJ. We will handle that in a future task.)\n\n\n\n\nClick the Folder icon located at the top-left corner of the Paint3d window to open the \nSave\n menu. Under \nSave in Paint 3D\n, click \nPaint 3d Project\n, provide a name, and press \nEnter\n to save the model.\n\n\n\n\nBack in the Paint3D editor, click the folder icon to open the \nSave\n menu again. Under \nExport\n, click \nFBX\n:\n\n\n\n\n\n\n\n\nThe \nSave As\n dialog appears. Save the FBX file in a location you can remember for the tasks ahead.\n\n\n\n\n\n\nCongratulations, you now have a 3d Nose model that we can use in Unity or BablyonJS!\n\n\nReferences\n\n\nOur first Nose Prototype:\n\nNose Prototype (FBX)\n\n\nContinue to the \nnext task", 
            "title": "511 Paint3d"
        }, 
        {
            "location": "/stories/5/511_Paint3d/#task-511-create-the-model-in-paint3d", 
            "text": "Creating 3D models of our products opens up a world of opportunities. We can 3D print prototype noses, render them in 3D to see how they look, and even view them in Virtual Reality!  3D Paint is a simple tool available in the Windows 10 Creators Update that allows us to create and paint 3D models. Perfect for this task!", 
            "title": "Task 5.1.1 - Create the model in Paint3D"
        }, 
        {
            "location": "/stories/5/511_Paint3d/#prerequisites", 
            "text": "This walkthrough assumes that you have:   Windows 10 Creators Update  Paint 3D", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/5/511_Paint3d/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/5/511_Paint3d/#create-the-basic-3d-nose-model", 
            "text": "First we will create the nose 3D model with a base color.   From the Windows Start menu, launch  Paint 3D . If the  Welcome  screen is displayed, Click  New .  You will see a blank white canvas where you will create your Knowzy nose prototype.  The menu at the top of the screen is where you select the tools you want to use. The brush icon (Art Tools) is for painting and coloring. The cube icon (3d objects) is for creating 3D objects. Click the cube icon to open the 3d objects menu. Ensure that the sphere in the 3D objects collection is selected:\n      Use the color palette to choose a color for the nose. You can click on the materials dropdown above the color palette to get different effects. For example, select  Gloss  to make the nose shiny. Play with the colors and materials options to get the color you want.  Draw a sphere on the canvas by placing the mouse pointer on the canvas. Press and hold the left mouse button while dragging the mouse until the sphere is the size you want. You can force the shape to be a circle by holding  Shift  down while dragging the mouse. This is how our first prototype looked:", 
            "title": "Create the basic 3D nose model"
        }, 
        {
            "location": "/stories/5/511_Paint3d/#add-details-to-the-nose", 
            "text": "The second task is to add details to the nose. You can use stickers, color variations and drawings.\n1. On the menu at the top of the screen, click the brush icon (Art tools) to see the tools available for drawing.   Note: For these steps, it is important not to draw outside of the model on the white canvas because it will become part of the 3D model.     Use any of the art tools to draw on the model. Be creative! For our first prototype, we used the Calligraphy pen with the  Thickness  set to 36px to draw nostrils.     The Stickers menu (third icon from the left on the main menu) allows you to place stickers on the model. Feel free to play around with the various tools.", 
            "title": "Add details to the nose"
        }, 
        {
            "location": "/stories/5/511_Paint3d/#save-and-export-the-model", 
            "text": "The last task is to save the model and export it to the Filmbox (FBX) format so we can use the model in Unity or BabylonJS. (For BabylonJS, we will convert it from .FBX to .OBJ. We will handle that in a future task.)   Click the Folder icon located at the top-left corner of the Paint3d window to open the  Save  menu. Under  Save in Paint 3D , click  Paint 3d Project , provide a name, and press  Enter  to save the model.   Back in the Paint3D editor, click the folder icon to open the  Save  menu again. Under  Export , click  FBX :     The  Save As  dialog appears. Save the FBX file in a location you can remember for the tasks ahead.    Congratulations, you now have a 3d Nose model that we can use in Unity or BablyonJS!", 
            "title": "Save and Export the model."
        }, 
        {
            "location": "/stories/5/511_Paint3d/#references", 
            "text": "Our first Nose Prototype: Nose Prototype (FBX)", 
            "title": "References"
        }, 
        {
            "location": "/stories/5/511_Paint3d/#continue-to-the-next-task", 
            "text": "", 
            "title": "Continue to the next task &gt;&gt;"
        }, 
        {
            "location": "/stories/5/512a_Unity/", 
            "text": "Task 5.1.2a - Create a Unity solution to visualize 3D Model\n\n\nNow that we have a 3D model of a nose, we can render it in real-time in a UWP app. To create the app, we will use the Unity 3D rendering engine.\nUnity 3D has built-in support for loading Filmbox (FBX) files. We just need to load the model, add it to a scene, and export it as a UWP. This will allow us to simulate how our prototypes looks in the real world!\n\n\nPrerequisites\n\n\nThis walkthrough assumes that you have:\n\n\n\n\nWindows 10 Creators Update\n\n\n3D Nose Model from Paint 5.1.1\n\n\nUnity 5.6 and the UWP Plugin for exporting a Unity project to a UWP app\n\n\n\n\nTask\n\n\nCreate a new project\n\n\n\n\n\n\nFrom the Windows Start menu, launch Unity. When the Project dialog appears, click the \nNew\n icon.\n    \n Note: If you are launching Unity for the first time, log in with your free unity3d account.\n\n\n\n\n\n\nIn the New Project dialog, give the project a name, click \n3D\n, and specify a location for your project. Then click \nCreate Project\n.\n\n\n\n\n\n\n\n\nWhen the Unity designer appears, press \nCTRL+S\n to save the empty scene. The \nSave Scene\n dialog appears. Name the file \nMain.unity\n and save it in the \nAssets\n folder that  should be selected by default (the path appears in the top of the dialog).\n\n\n\n\n\n\nThe interface\n\n\n\n\nThe Unity interface has five main areas. The 3D view in the center is your scene. Above the 3D view is a \nScene\n tab and a \nGame\n tab. The \nScene\n tab is where you will be working. The \nGame\n tab is where you will preview the scene when you click the play icon at the top.\n\n\nThe \nHierarchy\n pane, on the left, lists the objects in your scene. If the \nMain\n scene is collapsed, click the chevron to expand the tree-view control. By default, the scene has a \nMain Camera\n (your point-of-view when you preview the scene in the \nGame\n tab), and a \nDirectional Light\n (think of this as the sun).\nThis is where we will be adding our own objects to build up the scene. Each of these items is a GameObject.\n\n\nThe \nProject\n tab, at the bottom, displays the project file structure. Everything you work with needs to be in the default \nAssets\n folder.\n\n\nThe \nInspector\n tab displays the properties of the selected GameObject. GameObjects in unity are composed of properties and components. For example, if you select the \nMain Camera\n from the Hierarchy window, you will see its properties and components.\n\n\nLoad the 3D Nose model\n\n\nLet's load the 3D Nose model that you created earlier in Paint 3D into Unity.\n\n\n\n\n\n\nClick the \nProject\n tab in the bottom pane. Within the \nAssets\n pane, right-click and select \nCreate \n Folder\n. Name the folder \nModels\n.\n\n\n\n\n\n\n\n\nUsing File Explorer, Locate the NosePrototype FBX model that you exported from Paint 3D in step 5.1.1, and copy it into the new \nModels\n folder (you can drag-and-drop from File Explorer onto the \nModels\n folder).\n\n\n\n\n\n\nOpen the \nModels\n folder in the \nProject\n pane. You should see the NosePrototype FBX file in the Assets/Models folder:\n\n\n\n\n\n\n\n\nDrag \nNosePrototype\n from the \nModels\n folder to the \nHierarchy\n window. You should see the nose in the \nHierarchy\n view, but it may not be visible in the \nScene\n view.\n\n\n\n\n\n\nTo make the nose visible in the \nScene\n view, click on \nNosePrototype\n in the hierarchy view, hover the mouse over the \nScene\n view, and press \nF\n on the keyboard to focus on the object. It should now be visible:\n\n\n\n\nClick the \nGame\n tab on top of the \nScene\n view to see how the scene appears from the camera. In the end, we want to position the nose so that it is visible from the camera.\n\n\n\n\nThere are some issues we need to address:\n\n\n\n\nThe scale is different between Unity and Paint 3D, so the nose object we imported is very big.\n\n\nThe origin for the polygons in the 3D model is not the center of the GameObject.\n\n\nThe color is a bit dark.\n\n\n\n\n\n\n\n\nTo solve the scale issue, in the \nHierarchy\n view click on the \nNosePrototype\n object. Then click the \nInspector\n tab to the right of the game view to see the \nPosition\n, \nScale\n and \nRotation\n properties. Set the \nScale\n to \n0.01\n\n\n\n\n\n\n\n\nTo solve the origin issue, add a new, empty GameObject to the scene by clicking the small \nCreate\n button in the top-left of the \nHierarchy\n panel. Then click \nCreate Empty\n.\n\n\n\n\nA new \nGameObject\n item appears in the \nHierarchy\n window. Click the \nScene\n tab and then click on the  \nGameObject\n in the \nHierarchy\n window. You can then view its properties in the \nInspector\n window.\n\n\nSet the name to \nNose\n, and then set the all the \nPosition\n fields to \n0\n to center the empty \nGameObject\n in the scene. Hover your mouse over the \nScene\n view and focus the GameObject by pressing \nF\n. You will then see the empty GameObject in the center of the scene, with the nose somewhere next to it.\n\n\n\n\nIn the \nHierarchy\n windows, click \nNosePrototype\n. In the \nScene\n view use the axis handles to position it as close to the center of the grid (thus overlapping the Nose object) as possible. Drag the red and green handles using the mouse to do so. It does not need to be 100% accurate; just get as close as you can.\n\n\n\n\nTip: The handles allow you to move the object along the selected axis. You can use the Grid and these handles to align them to the center. Look closely in the image below and note how the nose has been positioned so that the grid aligns with the axis handles:\n\n\n\n\n\n\nWith \nNosePrototype\n in the center, we need to use the \nHierarchy\n view to make it a child of the new empty \nNose\n GameObject. In the \nHierarchy\n view, drag the \nNosePrototype\n GameObject and drop it on the \nNose\n GameObject to make it a child.\n\n\n\n\nChildren are positioned relative to their parent. This means that if we rotate or move the parent GameObject, the child GameObject will follow.\n\n\n\n\n\n\nLet's fix the dark color issue. Each GameObject that has a visible surface, such as our \nNosePrototype\n 3D model, gets a material property. A material describes how the surface to which the material is assigned to will look and behave. This includes color, texture assignment and light calculations. For those who are familiar with graphics programming, a material is the shader used to render the polygons.\n\n\nTo find the assigned material that was generated when the model was imported, navigate to the \nMaterials\n subfolder in the Assets folder, and click on \n4755\n.\n\n\n\n\nWhen we imported the object, Unity automatically generated a material, set the texture to what we made in Paint 3D, and assigned it to the model. The property that controls the texture is the \nAlbedo\n property in the \nMain Maps\n section of the \nInspector\n window.\n\n\nYou can see the texture on the left of the property in a thumbnail. To the right of the property is a gray color. This is multiplied against the texture, which darkens it. Set this color to white to fix the darkness issue. Feel free to play around with the metallic and smoothness settings to give it a metallic or matte look based on your preference.\n\n\n\n\n\n\n\n\nWith the scale and color issues addressed, the color now looks more natural, the object has a better size and is centered.\n\n\n\n\nClick the \nGame\n tab to verify what the user will see when they launch the app. From this view, you can continue to modify the scale and position if needed. In my case, it now looks like this:\n\n\n\n\n\n\n\n\nMake the nose rotate\n\n\nTo make the nose rotate, we will create a custom component using C#.\n\n\n\n\n\n\nIn the \nAssets\n folder at the bottom of the screen, create a new folder named \nScripts\n:\n\n\n\n\n\n\n\n\nIn the Scripts folder, right click and click \nCreate \n C# script\n. Name it \nNoseRotator\n\n\n\n\n\n\n\n\nIf the \nNose\n GameObject in the \nHierarchy\n view is not collapsed, collapse it now. Then drag and drop the \nNoseRotator\n script onto the \nNose\n GameObject in the \nHierarchy\n View, which adds it as a component to the \nNose\n object:\n\n\n\n\n\n\n\n\nIn the \nHierarchy\n view, click on the \nNose\n GameObject to see the component you added in the \nInspector\n.\n\n\n\n\n\n\n\n\nIn the \nProject\n view, double-click the \nNoseRotator\n to edit the code. (Note: you can use the Unity Preferences (\nEdit \n Preferences\n) to set which Editor you want to use. By default, Visual Studio opens.)\n\n\n\n\n\n\nThe script has two functions by default: \nStart()\n and \nUpdate()\n. \nStart()\n is called when the app launches. \nUpdate()\n is called every time a frame is rendered.\nTo animate the nose, we will rotate it slightly every time \nUpdate()\n is called. In \nUpdate()\n, add the following code:\n\n\ntransform.Rotate(Time.deltaTime * Vector3.up * speed);\n\n\n\nAdd a new public floating point variable called \nspeed\n to the class, just above \nStart()\n. The code should now look like this:\n\n\nusing System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class NoseRotator : MonoBehaviour {\n    public float speed = 50.0f;\n\n    // Use this for initialization\n    void Start () {\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n        transform.Rotate(Time.deltaTime * Vector3.up * speed);\n    }\n}\n\n\n\nThe \nRotate\n function rotates the GameObject this script is attached to. \nTime.deltaTime\n is the amount of time since the last frame was rendered, so it can be used to sync the timing with the clock. \nVector3.up\n is a Vector that describes the X, Y, and Z-axis and is set to: 0,1,0 which means the object will only rotate around the Y-axis. \nspeed\n determines how fast it will rotate. Since we multiply \nspeed\n against \nTime.deltaTime\n,  \nspeed\n determines how many degrees it will rotate per second.\n\n\nSave the code and return to Unity.\n\n\n\n\n\n\nTest the app\n: Before we export the project to a UWP app, we need to verify that the project is working. Click the \nPlay\n button on top of the scene to automatically enter the \nGame\n tab and start running the code. You should now see the nose rotating in the center of the screen. It may be offset somewhat depending on how accurate you were when you centered it earlier.\n\n\n\n\n\n\nTip: With the Nose GameObject selected, you can see that the speed variable is visible in the \nInspector\n window, and is set to 50. Because the speed variable is public, you can set its value directly in the \nInspector\n window instead of changing the script.\n\n\n\n\n\n\n\n\nExport to a UWP app\n\n\nThe final step is to export our Nose 3D visualizer as a UWP app so that we can distribute it.\n\n\n\n\n\n\nOn the main menu, click \nFile \n Build Settings\n. The \nBuild Settings\n dialog appears. A gray area is visible named \nScene in Build\n. Click the button below it named \nAdd Open Scenes\n to add the scene we have created to the list.\n\n\n\n\n\n\nIn the \nPlatform\n list, select \nWindows Store\n and then click \nBuild\n:\n\n\n\n\nWhen the \nBuild Windows Store\n dialog appears, choose a location on your PC for the UWP app and click OK to begin exporting the project. This will take a minute.\n\n\n\n\n\n\nWhen the build completes, the folder will open in File Explorer. Open \nNose3D.sln\n in Visual Studio.\n\n\n\n\n\n\nIn Visual Studio, from the \nBuild Configuration\n dropdown, change the Build Configuration to \nMaster\n and the platform to \nx64\n.  Press \nF5\n to build, deploy, and run the project.\n\n\n   \n\n\n\n\n\n\nThe project will take a few minutes to build. When it completes, you should see the rotating 3D nose in the center of the app.\n\n\n\n\n\n\nCongratulations, you have created a 3D Nose visualizer UWP app using Unity! Since this is a Windows Store app, you can access it from the Windows Start Menu.\n\n\nContinue to \nnext task", 
            "title": "512a Unity"
        }, 
        {
            "location": "/stories/5/512a_Unity/#task-512a-create-a-unity-solution-to-visualize-3d-model", 
            "text": "Now that we have a 3D model of a nose, we can render it in real-time in a UWP app. To create the app, we will use the Unity 3D rendering engine.\nUnity 3D has built-in support for loading Filmbox (FBX) files. We just need to load the model, add it to a scene, and export it as a UWP. This will allow us to simulate how our prototypes looks in the real world!", 
            "title": "Task 5.1.2a - Create a Unity solution to visualize 3D Model"
        }, 
        {
            "location": "/stories/5/512a_Unity/#prerequisites", 
            "text": "This walkthrough assumes that you have:   Windows 10 Creators Update  3D Nose Model from Paint 5.1.1  Unity 5.6 and the UWP Plugin for exporting a Unity project to a UWP app", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/5/512a_Unity/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/5/512a_Unity/#create-a-new-project", 
            "text": "From the Windows Start menu, launch Unity. When the Project dialog appears, click the  New  icon.\n      Note: If you are launching Unity for the first time, log in with your free unity3d account.    In the New Project dialog, give the project a name, click  3D , and specify a location for your project. Then click  Create Project .     When the Unity designer appears, press  CTRL+S  to save the empty scene. The  Save Scene  dialog appears. Name the file  Main.unity  and save it in the  Assets  folder that  should be selected by default (the path appears in the top of the dialog).    The interface   The Unity interface has five main areas. The 3D view in the center is your scene. Above the 3D view is a  Scene  tab and a  Game  tab. The  Scene  tab is where you will be working. The  Game  tab is where you will preview the scene when you click the play icon at the top.  The  Hierarchy  pane, on the left, lists the objects in your scene. If the  Main  scene is collapsed, click the chevron to expand the tree-view control. By default, the scene has a  Main Camera  (your point-of-view when you preview the scene in the  Game  tab), and a  Directional Light  (think of this as the sun).\nThis is where we will be adding our own objects to build up the scene. Each of these items is a GameObject.  The  Project  tab, at the bottom, displays the project file structure. Everything you work with needs to be in the default  Assets  folder.  The  Inspector  tab displays the properties of the selected GameObject. GameObjects in unity are composed of properties and components. For example, if you select the  Main Camera  from the Hierarchy window, you will see its properties and components.", 
            "title": "Create a new project"
        }, 
        {
            "location": "/stories/5/512a_Unity/#load-the-3d-nose-model", 
            "text": "Let's load the 3D Nose model that you created earlier in Paint 3D into Unity.    Click the  Project  tab in the bottom pane. Within the  Assets  pane, right-click and select  Create   Folder . Name the folder  Models .     Using File Explorer, Locate the NosePrototype FBX model that you exported from Paint 3D in step 5.1.1, and copy it into the new  Models  folder (you can drag-and-drop from File Explorer onto the  Models  folder).    Open the  Models  folder in the  Project  pane. You should see the NosePrototype FBX file in the Assets/Models folder:     Drag  NosePrototype  from the  Models  folder to the  Hierarchy  window. You should see the nose in the  Hierarchy  view, but it may not be visible in the  Scene  view.    To make the nose visible in the  Scene  view, click on  NosePrototype  in the hierarchy view, hover the mouse over the  Scene  view, and press  F  on the keyboard to focus on the object. It should now be visible:   Click the  Game  tab on top of the  Scene  view to see how the scene appears from the camera. In the end, we want to position the nose so that it is visible from the camera.   There are some issues we need to address:   The scale is different between Unity and Paint 3D, so the nose object we imported is very big.  The origin for the polygons in the 3D model is not the center of the GameObject.  The color is a bit dark.     To solve the scale issue, in the  Hierarchy  view click on the  NosePrototype  object. Then click the  Inspector  tab to the right of the game view to see the  Position ,  Scale  and  Rotation  properties. Set the  Scale  to  0.01     To solve the origin issue, add a new, empty GameObject to the scene by clicking the small  Create  button in the top-left of the  Hierarchy  panel. Then click  Create Empty .   A new  GameObject  item appears in the  Hierarchy  window. Click the  Scene  tab and then click on the   GameObject  in the  Hierarchy  window. You can then view its properties in the  Inspector  window.  Set the name to  Nose , and then set the all the  Position  fields to  0  to center the empty  GameObject  in the scene. Hover your mouse over the  Scene  view and focus the GameObject by pressing  F . You will then see the empty GameObject in the center of the scene, with the nose somewhere next to it.   In the  Hierarchy  windows, click  NosePrototype . In the  Scene  view use the axis handles to position it as close to the center of the grid (thus overlapping the Nose object) as possible. Drag the red and green handles using the mouse to do so. It does not need to be 100% accurate; just get as close as you can.   Tip: The handles allow you to move the object along the selected axis. You can use the Grid and these handles to align them to the center. Look closely in the image below and note how the nose has been positioned so that the grid aligns with the axis handles:    With  NosePrototype  in the center, we need to use the  Hierarchy  view to make it a child of the new empty  Nose  GameObject. In the  Hierarchy  view, drag the  NosePrototype  GameObject and drop it on the  Nose  GameObject to make it a child.   Children are positioned relative to their parent. This means that if we rotate or move the parent GameObject, the child GameObject will follow.    Let's fix the dark color issue. Each GameObject that has a visible surface, such as our  NosePrototype  3D model, gets a material property. A material describes how the surface to which the material is assigned to will look and behave. This includes color, texture assignment and light calculations. For those who are familiar with graphics programming, a material is the shader used to render the polygons.  To find the assigned material that was generated when the model was imported, navigate to the  Materials  subfolder in the Assets folder, and click on  4755 .   When we imported the object, Unity automatically generated a material, set the texture to what we made in Paint 3D, and assigned it to the model. The property that controls the texture is the  Albedo  property in the  Main Maps  section of the  Inspector  window.  You can see the texture on the left of the property in a thumbnail. To the right of the property is a gray color. This is multiplied against the texture, which darkens it. Set this color to white to fix the darkness issue. Feel free to play around with the metallic and smoothness settings to give it a metallic or matte look based on your preference.     With the scale and color issues addressed, the color now looks more natural, the object has a better size and is centered.   Click the  Game  tab to verify what the user will see when they launch the app. From this view, you can continue to modify the scale and position if needed. In my case, it now looks like this:", 
            "title": "Load the 3D Nose model"
        }, 
        {
            "location": "/stories/5/512a_Unity/#make-the-nose-rotate", 
            "text": "To make the nose rotate, we will create a custom component using C#.    In the  Assets  folder at the bottom of the screen, create a new folder named  Scripts :     In the Scripts folder, right click and click  Create   C# script . Name it  NoseRotator     If the  Nose  GameObject in the  Hierarchy  view is not collapsed, collapse it now. Then drag and drop the  NoseRotator  script onto the  Nose  GameObject in the  Hierarchy  View, which adds it as a component to the  Nose  object:     In the  Hierarchy  view, click on the  Nose  GameObject to see the component you added in the  Inspector .     In the  Project  view, double-click the  NoseRotator  to edit the code. (Note: you can use the Unity Preferences ( Edit   Preferences ) to set which Editor you want to use. By default, Visual Studio opens.)    The script has two functions by default:  Start()  and  Update() .  Start()  is called when the app launches.  Update()  is called every time a frame is rendered.\nTo animate the nose, we will rotate it slightly every time  Update()  is called. In  Update() , add the following code:  transform.Rotate(Time.deltaTime * Vector3.up * speed);  Add a new public floating point variable called  speed  to the class, just above  Start() . The code should now look like this:  using System.Collections;\nusing System.Collections.Generic;\nusing UnityEngine;\n\npublic class NoseRotator : MonoBehaviour {\n    public float speed = 50.0f;\n\n    // Use this for initialization\n    void Start () {\n\n    }\n\n    // Update is called once per frame\n    void Update () {\n        transform.Rotate(Time.deltaTime * Vector3.up * speed);\n    }\n}  The  Rotate  function rotates the GameObject this script is attached to.  Time.deltaTime  is the amount of time since the last frame was rendered, so it can be used to sync the timing with the clock.  Vector3.up  is a Vector that describes the X, Y, and Z-axis and is set to: 0,1,0 which means the object will only rotate around the Y-axis.  speed  determines how fast it will rotate. Since we multiply  speed  against  Time.deltaTime ,   speed  determines how many degrees it will rotate per second.  Save the code and return to Unity.    Test the app : Before we export the project to a UWP app, we need to verify that the project is working. Click the  Play  button on top of the scene to automatically enter the  Game  tab and start running the code. You should now see the nose rotating in the center of the screen. It may be offset somewhat depending on how accurate you were when you centered it earlier.    Tip: With the Nose GameObject selected, you can see that the speed variable is visible in the  Inspector  window, and is set to 50. Because the speed variable is public, you can set its value directly in the  Inspector  window instead of changing the script.", 
            "title": "Make the nose rotate"
        }, 
        {
            "location": "/stories/5/512a_Unity/#export-to-a-uwp-app", 
            "text": "The final step is to export our Nose 3D visualizer as a UWP app so that we can distribute it.    On the main menu, click  File   Build Settings . The  Build Settings  dialog appears. A gray area is visible named  Scene in Build . Click the button below it named  Add Open Scenes  to add the scene we have created to the list.    In the  Platform  list, select  Windows Store  and then click  Build :   When the  Build Windows Store  dialog appears, choose a location on your PC for the UWP app and click OK to begin exporting the project. This will take a minute.    When the build completes, the folder will open in File Explorer. Open  Nose3D.sln  in Visual Studio.    In Visual Studio, from the  Build Configuration  dropdown, change the Build Configuration to  Master  and the platform to  x64 .  Press  F5  to build, deploy, and run the project.         The project will take a few minutes to build. When it completes, you should see the rotating 3D nose in the center of the app.    Congratulations, you have created a 3D Nose visualizer UWP app using Unity! Since this is a Windows Store app, you can access it from the Windows Start Menu.", 
            "title": "Export to a UWP app"
        }, 
        {
            "location": "/stories/5/512a_Unity/#continue-to-next-task", 
            "text": "", 
            "title": "Continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/5/512b_Babylon/", 
            "text": "Task 5.1.2b - Create a BabylonJS solution to visualize 3D Model\n\n\nNow that we have a proper 3D model of our nose prototype, we can start rendering it in real-time through a Javascript UWP app. To create the app, we will use the Visual Studio 2017 Javascript UWP template. To load and render our model, we will use Babylon JS, which is a WebGL-based 3D engine.\n\n\nBecause Babylon does not support FBX, we first need to convert our FBX file to a Bablylon-supported format (babylon, glTF, or OBJ).\n\n\nPrerequisites\n\n\nThis walkthrough assumes that you have:\n\n\n\n\nWindows 10 Creators Update\n\n\n3D Nose Model from Paint 5.1.1\n\n\nVisual Studio 2017 with the Universal Windows Platform Development Workload to create a Javascript UWP app\n\n\n\n\nTask\n\n\nConvert the model to OBJ\n\n\nTo convert the model, we will use the online FBX to OBJ converter, using the FBX we exported in 5.1.1.\n1. Go to: \nOnline Model Converter\n\n2. Follow the steps in the tool to convert the FBX to OBJ, and download the OBJ file. The MTL file is not needed.\n\n\nOne problem with the conversion is that we don't get the texture. However, you can use any PNG file for this. For the steps below, create a new image in any paint program and fill it with red color to use as the texture. \n\n\nCreating a new project\n\n\n\n\n\n\nLaunch Visual Studio 2017 and then select File | New | Project.\n    \n Note: If you are launching Visual Studio for the first time, log in with your Microsoft account.\n\n\n\n\n\n\nIn the Templates section of the New Project window, select Javascript | Windows Universal | Blank App (Universal Windows). Name the project \"BabylonUWP\".\n\n\n\n\n\n\n\n\nClick OK to create your project. \n\n\n\n\nNote: You may be asked to turn on the developer mode in the Windows settings in order to create the project.\n\n\n\n\n\n\n\n\nLaunch the app by pressing F5 (for debug mode) or Ctrl+F5 (for normal mode). It should appear with a white page containing the text \"Content goes here!\".\n\n\n\n\n\n\n\n\nAdding Babylon JS as a dependency\n\n\nIt is now time to add content to our app.\n\n\n\n\n\n\nAdd babylon.js to your project to enable it to work offline. In Solution Explorer, right-click the \njs\n folder and select \nAdd | Existing Item\n. Then paste \nhttps://preview.babylonjs.com/babylon.js\n) into the \nFile name\n box and click \nAdd\n. \n\n\n\n\n\n\n\n\nAdd the babylon.js OBJ Loader dependency to your project to enable it to work offline. As in the previous step, add an existing item to the js folder and use \nhttps://preview.babylonjs.com/loaders/babylon.objFileLoader.js\n as the file name.\n\n\n\n\n\n\nThe solution folder should now look like this:\n\n\n\n\n\n\n\n\nIt is now time to integrate those files into the application. Open the \nindex.html\n file and add the two following script references \nbefore\n the main.js one:\n\n\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n\n    \nmeta charset=\"utf-8\" /\n\n    \ntitle\nBabylonUWP\n/title\n\n    \nlink href=\"css/default.css\" rel=\"stylesheet\" /\n\n\n/head\n\n\nbody\n\n    \ndiv\nContent goes here!\n/div\n\n\n    \nscript src=\"js/babylon.js\"\n/script\n\n    \nscript src=\"js/babylon.objFileLoader.js\"\n/script\n\n    \nscript src=\"js/main.js\"\n/script\n\n\n/body\n\n\n/html\n\n\n\n\n\n\n\n\nYou can now launch by pressing F5 to ensure that the setup is correct. No error should appear in the JavaScript console.\n\n\n\n\n\n\nCreate your first scene\n\n\nNow that the project is ready, we can create our first 3D scene as explained in the \nBasic Tutorial\n for Babylon JS.\n\n\n\n\nReplace the \ndiv\n element containing the text \"Content goes here!\" with a canvas enabling WebGL rendering in HTML.\n\n\n\n\ncanvas id=\"renderCanvas\"\n/canvas\n.\n\n\n\n\n\n\nThe \nindex.html\n file should now look like this:\n\n\n!DOCTYPE html\n\n\nhtml\n\n\nhead\n\n    \nmeta charset=\"utf-8\" /\n\n    \ntitle\nBabylonUWP\n/title\n\n    \nlink href=\"css/default.css\" rel=\"stylesheet\" /\n\n\n/head\n\n\nbody\n\n    \ncanvas id=\"renderCanvas\"\n/canvas\n\n\n    \nscript src=\"js/babylon.js\"\n/script\n\n    \nscript src=\"js/babylon.objFileLoader.js\"\n/script\n\n    \nscript src=\"js/main.js\"\n/script\n\n\n/body\n\n\n/html\n\n\n\n\n\n\n\n\nTo ensure that the canvas is rendered in full screen, replace the contents of the file \ncss/default.css\n with the following:\n\n\nhtml, body {\n    overflow: hidden;\n    width: 100%;\n    height: 100%;\n    margin: 0;\n    padding: 0;\n}\n\n#renderCanvas {\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n}\n\n\n\n\n\n\n\nOpen the \njs/main.js\n file and replace its content with the following:\n\n\n// Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's try our built-in 'box' shape. Params: name, size.\nvar box1 = BABYLON.Mesh.CreateBox(\"box1\", 1);\n\n// Creates a default light and camera.\nscene.createDefaultCameraOrLight(true);\n\n// This attaches the input camera controls to the canvas\nscene.activeCamera.attachControl(canvas, false);\n\n// Register a render loop to repeatedly render the scene\nengine.runRenderLoop(function () {\n    scene.render();\n});\n\n\n\n\n\n\n\nYou can now launch the project to see a cube in 3D. You can rotate the camera by dragging while pressing the left mouse button. You can control the zoom level with the mouse wheel.\n\n\n\n\n\n\n\n\nLoading the 3D Nose model\n\n\n\n\n\n\nCreate a folder named \nassets\n at the root of the solution and copy your red-nose OBJ file into this folder.\n\n\n\n\n\n\nNext, load the model by replacing the contents of the \njs/main.js\n file with the following:\n\n\n// Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's load the red nose model.\nBABYLON.SceneLoader.ImportMesh(null, \"assets/\", \"redNose.obj\", scene, function (meshes) {\n    // Keeps track of our model root.\n    var redNoseModel = meshes[0];\n\n    // Creates a default light and camera.\n    scene.createDefaultCameraOrLight(true);\n\n    // This attaches the input camera controls to the canvas\n    scene.activeCamera.attachControl(canvas, false);\n\n    // Register a render loop to repeatedly render the scene\n    engine.runRenderLoop(function () {\n        scene.render();\n    });\n});\n\n\n\n\n\n\n\nLaunch the project to see red nose model displayed in the app.\n\n\n\n\n\n\nMaking the nose rotate\n\n\nWe will now animate the nose model.\n\n\n\n\n\n\nReplace the contents of the \nmain.js\n file with the following code:\n\n\n\n\nNote: This codes demonstrates the animation system but you could rely upon the manual animation as well: \nAnimation Tutorial\n.\n\n\n\n\n// Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's load the red nose model.\nBABYLON.SceneLoader.ImportMesh(null, \"assets/\", \"redNose.obj\", scene, function (meshes) {\n    // Keeps track of our model root.\n    var redNoseModel = meshes[0];\n\n    // Creates a default light and camera.\n    scene.createDefaultCameraOrLight(true);\n\n    // This attaches the input camera controls to the canvas\n    scene.activeCamera.attachControl(canvas, false);\n\n    // Create a rotation animation at 30 FPS\n    var animation = new BABYLON.Animation(\"rotationAnimation\", \"rotation.y\", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);\n\n    // Add the animation key frames.\n    var keys = [];\n    // At the animation key 0, the value of rotation is \"0\"\n    keys.push({\n        frame: 30 * 0,\n        value: 0\n    });\n\n    // At the animation key at 1 second, the value of scaling is a quarter of turn\n    keys.push({\n        frame: 30 * 1,\n        value: Math.PI / 2\n    });\n\n    // At the animation key at 2 seconds, the value of scaling is a half of turn\n    keys.push({\n        frame: 30 * 2,\n        value: Math.PI\n    });\n\n    // At the animation key at 3 seconds, the value of scaling is 3 quarter of turn\n    keys.push({\n        frame: 30 * 3,\n        value: Math.PI / 2 * 3\n    });\n\n    // At the animation key at 4 seconds, the value of scaling is a full turn\n    keys.push({\n        frame: 30 * 4,\n        value: Math.PI * 2\n    });\n\n    // Adding keys to the animation object\n    animation.setKeys(keys);\n\n    // Then add the animation object to redNoseModel\n    redNoseModel.animations.push(animation);\n\n    // Finally, launch animations on box1, from key 0 to key 60 * 4 with loop activated\n    scene.beginAnimation(redNoseModel, 0, 60 * 4, true);\n\n    // Register a render loop to repeatedly render the scene\n    engine.runRenderLoop(function () {\n        scene.render();\n    });\n});\n\n\n\n\n\n\n\nReferences\n\n\n\n\nBabylon JS Documentation\n\n\n\n\ncontinue to \nnext task", 
            "title": "512b Babylon"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#task-512b-create-a-babylonjs-solution-to-visualize-3d-model", 
            "text": "Now that we have a proper 3D model of our nose prototype, we can start rendering it in real-time through a Javascript UWP app. To create the app, we will use the Visual Studio 2017 Javascript UWP template. To load and render our model, we will use Babylon JS, which is a WebGL-based 3D engine.  Because Babylon does not support FBX, we first need to convert our FBX file to a Bablylon-supported format (babylon, glTF, or OBJ).", 
            "title": "Task 5.1.2b - Create a BabylonJS solution to visualize 3D Model"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#prerequisites", 
            "text": "This walkthrough assumes that you have:   Windows 10 Creators Update  3D Nose Model from Paint 5.1.1  Visual Studio 2017 with the Universal Windows Platform Development Workload to create a Javascript UWP app", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#convert-the-model-to-obj", 
            "text": "To convert the model, we will use the online FBX to OBJ converter, using the FBX we exported in 5.1.1.\n1. Go to:  Online Model Converter \n2. Follow the steps in the tool to convert the FBX to OBJ, and download the OBJ file. The MTL file is not needed.  One problem with the conversion is that we don't get the texture. However, you can use any PNG file for this. For the steps below, create a new image in any paint program and fill it with red color to use as the texture.", 
            "title": "Convert the model to OBJ"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#creating-a-new-project", 
            "text": "Launch Visual Studio 2017 and then select File | New | Project.\n      Note: If you are launching Visual Studio for the first time, log in with your Microsoft account.    In the Templates section of the New Project window, select Javascript | Windows Universal | Blank App (Universal Windows). Name the project \"BabylonUWP\".     Click OK to create your project.    Note: You may be asked to turn on the developer mode in the Windows settings in order to create the project.     Launch the app by pressing F5 (for debug mode) or Ctrl+F5 (for normal mode). It should appear with a white page containing the text \"Content goes here!\".", 
            "title": "Creating a new project"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#adding-babylon-js-as-a-dependency", 
            "text": "It is now time to add content to our app.    Add babylon.js to your project to enable it to work offline. In Solution Explorer, right-click the  js  folder and select  Add | Existing Item . Then paste  https://preview.babylonjs.com/babylon.js ) into the  File name  box and click  Add .      Add the babylon.js OBJ Loader dependency to your project to enable it to work offline. As in the previous step, add an existing item to the js folder and use  https://preview.babylonjs.com/loaders/babylon.objFileLoader.js  as the file name.    The solution folder should now look like this:     It is now time to integrate those files into the application. Open the  index.html  file and add the two following script references  before  the main.js one:  !DOCTYPE html  html  head \n     meta charset=\"utf-8\" / \n     title BabylonUWP /title \n     link href=\"css/default.css\" rel=\"stylesheet\" /  /head  body \n     div Content goes here! /div \n\n     script src=\"js/babylon.js\" /script \n     script src=\"js/babylon.objFileLoader.js\" /script \n     script src=\"js/main.js\" /script  /body  /html     You can now launch by pressing F5 to ensure that the setup is correct. No error should appear in the JavaScript console.", 
            "title": "Adding Babylon JS as a dependency"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#create-your-first-scene", 
            "text": "Now that the project is ready, we can create our first 3D scene as explained in the  Basic Tutorial  for Babylon JS.   Replace the  div  element containing the text \"Content goes here!\" with a canvas enabling WebGL rendering in HTML.   canvas id=\"renderCanvas\" /canvas .    The  index.html  file should now look like this:  !DOCTYPE html  html  head \n     meta charset=\"utf-8\" / \n     title BabylonUWP /title \n     link href=\"css/default.css\" rel=\"stylesheet\" /  /head  body \n     canvas id=\"renderCanvas\" /canvas \n\n     script src=\"js/babylon.js\" /script \n     script src=\"js/babylon.objFileLoader.js\" /script \n     script src=\"js/main.js\" /script  /body  /html     To ensure that the canvas is rendered in full screen, replace the contents of the file  css/default.css  with the following:  html, body {\n    overflow: hidden;\n    width: 100%;\n    height: 100%;\n    margin: 0;\n    padding: 0;\n}\n\n#renderCanvas {\n    width: 100%;\n    height: 100%;\n    touch-action: none;\n}    Open the  js/main.js  file and replace its content with the following:  // Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's try our built-in 'box' shape. Params: name, size.\nvar box1 = BABYLON.Mesh.CreateBox(\"box1\", 1);\n\n// Creates a default light and camera.\nscene.createDefaultCameraOrLight(true);\n\n// This attaches the input camera controls to the canvas\nscene.activeCamera.attachControl(canvas, false);\n\n// Register a render loop to repeatedly render the scene\nengine.runRenderLoop(function () {\n    scene.render();\n});    You can now launch the project to see a cube in 3D. You can rotate the camera by dragging while pressing the left mouse button. You can control the zoom level with the mouse wheel.", 
            "title": "Create your first scene"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#loading-the-3d-nose-model", 
            "text": "Create a folder named  assets  at the root of the solution and copy your red-nose OBJ file into this folder.    Next, load the model by replacing the contents of the  js/main.js  file with the following:  // Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's load the red nose model.\nBABYLON.SceneLoader.ImportMesh(null, \"assets/\", \"redNose.obj\", scene, function (meshes) {\n    // Keeps track of our model root.\n    var redNoseModel = meshes[0];\n\n    // Creates a default light and camera.\n    scene.createDefaultCameraOrLight(true);\n\n    // This attaches the input camera controls to the canvas\n    scene.activeCamera.attachControl(canvas, false);\n\n    // Register a render loop to repeatedly render the scene\n    engine.runRenderLoop(function () {\n        scene.render();\n    });\n});    Launch the project to see red nose model displayed in the app.", 
            "title": "Loading the 3D Nose model"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#making-the-nose-rotate", 
            "text": "We will now animate the nose model.    Replace the contents of the  main.js  file with the following code:   Note: This codes demonstrates the animation system but you could rely upon the manual animation as well:  Animation Tutorial .   // Get the canvas element from our HTML above\nvar canvas = document.getElementById(\"renderCanvas\");\n\n// Load the BABYLON 3D engine\nvar engine = new BABYLON.Engine(canvas, true);\n\n// Now create a basic Babylon Scene object\nvar scene = new BABYLON.Scene(engine);\n\n// Let's load the red nose model.\nBABYLON.SceneLoader.ImportMesh(null, \"assets/\", \"redNose.obj\", scene, function (meshes) {\n    // Keeps track of our model root.\n    var redNoseModel = meshes[0];\n\n    // Creates a default light and camera.\n    scene.createDefaultCameraOrLight(true);\n\n    // This attaches the input camera controls to the canvas\n    scene.activeCamera.attachControl(canvas, false);\n\n    // Create a rotation animation at 30 FPS\n    var animation = new BABYLON.Animation(\"rotationAnimation\", \"rotation.y\", 30, BABYLON.Animation.ANIMATIONTYPE_FLOAT, BABYLON.Animation.ANIMATIONLOOPMODE_CYCLE);\n\n    // Add the animation key frames.\n    var keys = [];\n    // At the animation key 0, the value of rotation is \"0\"\n    keys.push({\n        frame: 30 * 0,\n        value: 0\n    });\n\n    // At the animation key at 1 second, the value of scaling is a quarter of turn\n    keys.push({\n        frame: 30 * 1,\n        value: Math.PI / 2\n    });\n\n    // At the animation key at 2 seconds, the value of scaling is a half of turn\n    keys.push({\n        frame: 30 * 2,\n        value: Math.PI\n    });\n\n    // At the animation key at 3 seconds, the value of scaling is 3 quarter of turn\n    keys.push({\n        frame: 30 * 3,\n        value: Math.PI / 2 * 3\n    });\n\n    // At the animation key at 4 seconds, the value of scaling is a full turn\n    keys.push({\n        frame: 30 * 4,\n        value: Math.PI * 2\n    });\n\n    // Adding keys to the animation object\n    animation.setKeys(keys);\n\n    // Then add the animation object to redNoseModel\n    redNoseModel.animations.push(animation);\n\n    // Finally, launch animations on box1, from key 0 to key 60 * 4 with loop activated\n    scene.beginAnimation(redNoseModel, 0, 60 * 4, true);\n\n    // Register a render loop to repeatedly render the scene\n    engine.runRenderLoop(function () {\n        scene.render();\n    });\n});", 
            "title": "Making the nose rotate"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#references", 
            "text": "Babylon JS Documentation", 
            "title": "References"
        }, 
        {
            "location": "/stories/5/512b_Babylon/#continue-to-next-task", 
            "text": "", 
            "title": "continue to next task &gt;&gt;"
        }, 
        {
            "location": "/stories/5/521_MR/", 
            "text": "Task 5.2.1 - Retarget UWP app to Mixed Reality Platform\n\n\nThe keynote is at a VR conference so we need a VR demo showing our Nose Prototypes. Having our 3D UWP app from 5.1.2a we can easily turn this into a VR-enabled app.\n\n\nPrerequisites\n\n\nThis walkthrough assumes that you have:\n\n\n\n\nWindows 10 Creators Update\n\n\n3D Nose Model from Paint 5.1.1 and 3D UWP from 5.1.2a\n\n\nUnity 5.6 with UWP Plugin for exporting UWP\n\n\n\n\nTask\n\n\nUsing Unity 3D to enable Mixed Reality\n\n\nSupporting Mixed Reality in Unity is just a simple toggle on the Build Settings in Unity.\n\n\n\n\nOpen the Nose3D project you created in Unity.\n\n\nGo to \nFile | Build Settings\n and click \nPlayer Settings\n\n\nA new Player Settings property pane appears on the right side of the Unity3D window.\n\n\nClick \nOther Settings\n to reveal a new set of properties.\n\n\n\n\nSelect \nVirtual Reality Supported\n. Windows Holographic should appear automatically.\n\n\n\n\n\n\n\n\nExport the project again, replacing the folder you exported to in 5.1.2a.\n\n\n\n\nOpen the Nose3D.sln solution and build/deploy/run the app. It will now automatically detect that VR is enabled and will run in the connected VR headset.\n\n\n\n\n\n\nNote: Connecting a new VR headset requires the latest Windows 10 build. Windows will automatically detect the headset and launch the Mixed Reality portal. Follow the configuration steps here to set it up correctly.\n\n\n\n\nReferences", 
            "title": "521 MR"
        }, 
        {
            "location": "/stories/5/521_MR/#task-521-retarget-uwp-app-to-mixed-reality-platform", 
            "text": "The keynote is at a VR conference so we need a VR demo showing our Nose Prototypes. Having our 3D UWP app from 5.1.2a we can easily turn this into a VR-enabled app.", 
            "title": "Task 5.2.1 - Retarget UWP app to Mixed Reality Platform"
        }, 
        {
            "location": "/stories/5/521_MR/#prerequisites", 
            "text": "This walkthrough assumes that you have:   Windows 10 Creators Update  3D Nose Model from Paint 5.1.1 and 3D UWP from 5.1.2a  Unity 5.6 with UWP Plugin for exporting UWP", 
            "title": "Prerequisites"
        }, 
        {
            "location": "/stories/5/521_MR/#task", 
            "text": "", 
            "title": "Task"
        }, 
        {
            "location": "/stories/5/521_MR/#using-unity-3d-to-enable-mixed-reality", 
            "text": "Supporting Mixed Reality in Unity is just a simple toggle on the Build Settings in Unity.   Open the Nose3D project you created in Unity.  Go to  File | Build Settings  and click  Player Settings  A new Player Settings property pane appears on the right side of the Unity3D window.  Click  Other Settings  to reveal a new set of properties.   Select  Virtual Reality Supported . Windows Holographic should appear automatically.     Export the project again, replacing the folder you exported to in 5.1.2a.   Open the Nose3D.sln solution and build/deploy/run the app. It will now automatically detect that VR is enabled and will run in the connected VR headset.    Note: Connecting a new VR headset requires the latest Windows 10 build. Windows will automatically detect the headset and launch the Mixed Reality portal. Follow the configuration steps here to set it up correctly.", 
            "title": "Using Unity 3D to enable Mixed Reality"
        }, 
        {
            "location": "/stories/5/521_MR/#references", 
            "text": "", 
            "title": "References"
        }, 
        {
            "location": "/stories/5/story_5/", 
            "text": "A great opportunity has developed! We are invited to speak in the keynote of NoseCon 2017! The topic is how 3D and VR is helping us with rapid prototyping. We need to create a keynote demo for NoseCon that renders a Nose Prototype in 3D, or even in VR if we find the time. This is highly confidential. \n\n\n\n\nDeliverable\n - Build a UWP 3D Visualizer\n\n\n5.1.1 - [Required] Create the model in Paint3D\n\n\n5.1.2a - [Required] Create a Unity solution to visualize 3D Model (d 5.1.1)\n or\n\n\n5.1.2b - [Required] Create a BabylonJS solution to visualize 3D Model (d 5.1.1)\n\n\n\n\n\n\nDeliverable\n - Visualize noses in VR\n\n\n5.2.1 - [Required] Re-target UWP app to Mixed Reality Platform (d 5.1.2)", 
            "title": "Story 5"
        }
    ]
}